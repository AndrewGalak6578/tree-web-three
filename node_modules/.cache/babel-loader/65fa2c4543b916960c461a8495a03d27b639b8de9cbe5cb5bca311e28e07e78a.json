{"ast":null,"code":"import { JsonRpcClient } from \"../rpc/client.js\";\nimport { PaginatedTransactionResponse, SuiAddress, SuiMoveFunctionArgTypes, SuiMoveNormalizedFunction, SuiMoveNormalizedModule, SuiMoveNormalizedModules, SuiMoveNormalizedStruct, SuiTransactionBlockResponse, PaginatedEvents, DevInspectResults, isValidTransactionDigest, isValidSuiAddress, isValidSuiObjectId, normalizeSuiAddress, normalizeSuiObjectId, CoinMetadataStruct, PaginatedCoins, SuiObjectResponse, DelegatedStake, CoinBalance, CoinSupply, Checkpoint, CommitteeInfo, DryRunTransactionBlockResponse, SuiSystemStateSummary, PaginatedObjectsResponse, ValidatorsApy, MoveCallMetrics, ObjectRead, ResolvedNameServiceNames, ProtocolConfig } from \"../types/index.js\";\nimport { DynamicFieldPage } from \"../types/dynamic_fields.js\";\nimport { DEFAULT_CLIENT_OPTIONS, WebsocketClient } from \"../rpc/websocket-client.js\";\nimport { requestSuiFromFaucet } from \"../rpc/faucet-client.js\";\nimport { any, array, string, nullable } from \"superstruct\";\nimport { fromB58, toB64, toHEX } from \"@mysten/bcs\";\nimport { devnetConnection } from \"../rpc/connection.js\";\nimport { TransactionBlock } from \"../builder/index.js\";\nimport { CheckpointPage } from \"../types/checkpoints.js\";\nimport { NetworkMetrics, AddressMetrics } from \"../types/metrics.js\";\nimport { EpochInfo, EpochPage } from \"../types/epochs.js\";\nconst DEFAULT_OPTIONS = {\n  socketOptions: DEFAULT_CLIENT_OPTIONS,\n  versionCacheTimeoutInSeconds: 600\n};\nclass JsonRpcProvider {\n  /**\n   * Establish a connection to a Sui RPC endpoint\n   *\n   * @param connection The `Connection` object containing configuration for the network.\n   * @param options configuration options for the provider\n   */\n  constructor() {\n    let connection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : devnetConnection;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_OPTIONS;\n    this.options = options;\n    this.connection = connection;\n    const opts = {\n      ...DEFAULT_OPTIONS,\n      ...options\n    };\n    this.options = opts;\n    this.client = opts.rpcClient ?? new JsonRpcClient(this.connection.fullnode);\n    this.wsClient = opts.websocketClient ?? new WebsocketClient(this.connection.websocket, opts.socketOptions);\n  }\n  async getRpcApiVersion() {\n    if (this.rpcApiVersion && this.cacheExpiry && this.cacheExpiry <= Date.now()) {\n      return this.rpcApiVersion;\n    }\n    try {\n      const resp = await this.client.requestWithType(\"rpc.discover\", [], any());\n      this.rpcApiVersion = resp.info.version;\n      this.cacheExpiry =\n      // Date.now() is in milliseconds, but the timeout is in seconds\n      Date.now() + (this.options.versionCacheTimeoutInSeconds ?? 0) * 1e3;\n      return this.rpcApiVersion;\n    } catch (err) {\n      console.warn(\"Error fetching version number of the RPC API\", err);\n    }\n    return void 0;\n  }\n  async requestSuiFromFaucet(recipient, httpHeaders) {\n    if (!this.connection.faucet) {\n      throw new Error(\"Faucet URL is not specified\");\n    }\n    return requestSuiFromFaucet(this.connection.faucet, recipient, httpHeaders);\n  }\n  /**\n   * Get all Coin<`coin_type`> objects owned by an address.\n   */\n  async getCoins(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getCoins\", [input.owner, input.coinType, input.cursor, input.limit], PaginatedCoins);\n  }\n  /**\n   * Get all Coin objects owned by an address.\n   */\n  async getAllCoins(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getAllCoins\", [input.owner, input.cursor, input.limit], PaginatedCoins);\n  }\n  /**\n   * Get the total coin balance for one coin type, owned by the address owner.\n   */\n  async getBalance(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getBalance\", [input.owner, input.coinType], CoinBalance);\n  }\n  /**\n   * Get the total coin balance for all coin types, owned by the address owner.\n   */\n  async getAllBalances(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getAllBalances\", [input.owner], array(CoinBalance));\n  }\n  /**\n   * Fetch CoinMetadata for a given coin type\n   */\n  async getCoinMetadata(input) {\n    return await this.client.requestWithType(\"suix_getCoinMetadata\", [input.coinType], CoinMetadataStruct);\n  }\n  /**\n   *  Fetch total supply for a coin\n   */\n  async getTotalSupply(input) {\n    return await this.client.requestWithType(\"suix_getTotalSupply\", [input.coinType], CoinSupply);\n  }\n  /**\n   * Invoke any RPC method\n   * @param method the method to be invoked\n   * @param args the arguments to be passed to the RPC request\n   */\n  async call(method, params) {\n    return await this.client.request(method, params);\n  }\n  /**\n   * Get Move function argument types like read, write and full access\n   */\n  async getMoveFunctionArgTypes(input) {\n    return await this.client.requestWithType(\"sui_getMoveFunctionArgTypes\", [input.package, input.module, input.function], SuiMoveFunctionArgTypes);\n  }\n  /**\n   * Get a map from module name to\n   * structured representations of Move modules\n   */\n  async getNormalizedMoveModulesByPackage(input) {\n    return await this.client.requestWithType(\"sui_getNormalizedMoveModulesByPackage\", [input.package], SuiMoveNormalizedModules);\n  }\n  /**\n   * Get a structured representation of Move module\n   */\n  async getNormalizedMoveModule(input) {\n    return await this.client.requestWithType(\"sui_getNormalizedMoveModule\", [input.package, input.module], SuiMoveNormalizedModule);\n  }\n  /**\n   * Get a structured representation of Move function\n   */\n  async getNormalizedMoveFunction(input) {\n    return await this.client.requestWithType(\"sui_getNormalizedMoveFunction\", [input.package, input.module, input.function], SuiMoveNormalizedFunction);\n  }\n  /**\n   * Get a structured representation of Move struct\n   */\n  async getNormalizedMoveStruct(input) {\n    return await this.client.requestWithType(\"sui_getNormalizedMoveStruct\", [input.package, input.module, input.struct], SuiMoveNormalizedStruct);\n  }\n  /**\n   * Get all objects owned by an address\n   */\n  async getOwnedObjects(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getOwnedObjects\", [input.owner, {\n      filter: input.filter,\n      options: input.options\n    }, input.cursor, input.limit], PaginatedObjectsResponse);\n  }\n  /**\n   * Get details about an object\n   */\n  async getObject(input) {\n    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {\n      throw new Error(\"Invalid Sui Object id\");\n    }\n    return await this.client.requestWithType(\"sui_getObject\", [input.id, input.options], SuiObjectResponse);\n  }\n  async tryGetPastObject(input) {\n    return await this.client.requestWithType(\"sui_tryGetPastObject\", [input.id, input.version, input.options], ObjectRead);\n  }\n  /**\n   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail\n   */\n  async multiGetObjects(input) {\n    input.ids.forEach(id => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(`Invalid Sui Object id ${id}`);\n      }\n    });\n    const hasDuplicates = input.ids.length !== new Set(input.ids).size;\n    if (hasDuplicates) {\n      throw new Error(`Duplicate object ids in batch call ${input.ids}`);\n    }\n    return await this.client.requestWithType(\"sui_multiGetObjects\", [input.ids, input.options], array(SuiObjectResponse));\n  }\n  /**\n   * Get transaction blocks for a given query criteria\n   */\n  async queryTransactionBlocks(input) {\n    return await this.client.requestWithType(\"suix_queryTransactionBlocks\", [{\n      filter: input.filter,\n      options: input.options\n    }, input.cursor, input.limit, (input.order || \"descending\") === \"descending\"], PaginatedTransactionResponse);\n  }\n  async getTransactionBlock(input) {\n    if (!isValidTransactionDigest(input.digest)) {\n      throw new Error(\"Invalid Transaction digest\");\n    }\n    return await this.client.requestWithType(\"sui_getTransactionBlock\", [input.digest, input.options], SuiTransactionBlockResponse);\n  }\n  async multiGetTransactionBlocks(input) {\n    input.digests.forEach(d => {\n      if (!isValidTransactionDigest(d)) {\n        throw new Error(`Invalid Transaction digest ${d}`);\n      }\n    });\n    const hasDuplicates = input.digests.length !== new Set(input.digests).size;\n    if (hasDuplicates) {\n      throw new Error(`Duplicate digests in batch call ${input.digests}`);\n    }\n    return await this.client.requestWithType(\"sui_multiGetTransactionBlocks\", [input.digests, input.options], array(SuiTransactionBlockResponse));\n  }\n  async executeTransactionBlock(input) {\n    return await this.client.requestWithType(\"sui_executeTransactionBlock\", [typeof input.transactionBlock === \"string\" ? input.transactionBlock : toB64(input.transactionBlock), Array.isArray(input.signature) ? input.signature : [input.signature], input.options, input.requestType], SuiTransactionBlockResponse);\n  }\n  /**\n   * Get total number of transactions\n   */\n  async getTotalTransactionBlocks() {\n    const resp = await this.client.requestWithType(\"sui_getTotalTransactionBlocks\", [], string());\n    return BigInt(resp);\n  }\n  /**\n   * Getting the reference gas price for the network\n   */\n  async getReferenceGasPrice() {\n    const resp = await this.client.requestWithType(\"suix_getReferenceGasPrice\", [], string());\n    return BigInt(resp);\n  }\n  /**\n   * Return the delegated stakes for an address\n   */\n  async getStakes(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getStakes\", [input.owner], array(DelegatedStake));\n  }\n  /**\n   * Return the delegated stakes queried by id.\n   */\n  async getStakesByIds(input) {\n    input.stakedSuiIds.forEach(id => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(`Invalid Sui Stake id ${id}`);\n      }\n    });\n    return await this.client.requestWithType(\"suix_getStakesByIds\", [input.stakedSuiIds], array(DelegatedStake));\n  }\n  /**\n   * Return the latest system state content.\n   */\n  async getLatestSuiSystemState() {\n    return await this.client.requestWithType(\"suix_getLatestSuiSystemState\", [], SuiSystemStateSummary);\n  }\n  /**\n   * Get events for a given query criteria\n   */\n  async queryEvents(input) {\n    return await this.client.requestWithType(\"suix_queryEvents\", [input.query, input.cursor, input.limit, (input.order || \"descending\") === \"descending\"], PaginatedEvents);\n  }\n  /**\n   * Subscribe to get notifications whenever an event matching the filter occurs\n   */\n  async subscribeEvent(input) {\n    return this.wsClient.request({\n      method: \"suix_subscribeEvent\",\n      unsubscribe: \"suix_unsubscribeEvent\",\n      params: [input.filter],\n      onMessage: input.onMessage\n    });\n  }\n  async subscribeTransaction(input) {\n    return this.wsClient.request({\n      method: \"suix_subscribeTransaction\",\n      unsubscribe: \"suix_unsubscribeTransaction\",\n      params: [input.filter],\n      onMessage: input.onMessage\n    });\n  }\n  /**\n   * Runs the transaction block in dev-inspect mode. Which allows for nearly any\n   * transaction (or Move call) with any arguments. Detailed results are\n   * provided, including both the transaction effects and any return values.\n   */\n  async devInspectTransactionBlock(input) {\n    let devInspectTxBytes;\n    if (TransactionBlock.is(input.transactionBlock)) {\n      input.transactionBlock.setSenderIfNotSet(input.sender);\n      devInspectTxBytes = toB64(await input.transactionBlock.build({\n        provider: this,\n        onlyTransactionKind: true\n      }));\n    } else if (typeof input.transactionBlock === \"string\") {\n      devInspectTxBytes = input.transactionBlock;\n    } else if (input.transactionBlock instanceof Uint8Array) {\n      devInspectTxBytes = toB64(input.transactionBlock);\n    } else {\n      throw new Error(\"Unknown transaction block format.\");\n    }\n    return await this.client.requestWithType(\"sui_devInspectTransactionBlock\", [input.sender, devInspectTxBytes, input.gasPrice, input.epoch], DevInspectResults);\n  }\n  /**\n   * Dry run a transaction block and return the result.\n   */\n  async dryRunTransactionBlock(input) {\n    return await this.client.requestWithType(\"sui_dryRunTransactionBlock\", [typeof input.transactionBlock === \"string\" ? input.transactionBlock : toB64(input.transactionBlock)], DryRunTransactionBlockResponse);\n  }\n  /**\n   * Return the list of dynamic field objects owned by an object\n   */\n  async getDynamicFields(input) {\n    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {\n      throw new Error(\"Invalid Sui Object id\");\n    }\n    return await this.client.requestWithType(\"suix_getDynamicFields\", [input.parentId, input.cursor, input.limit], DynamicFieldPage);\n  }\n  /**\n   * Return the dynamic field object information for a specified object\n   */\n  async getDynamicFieldObject(input) {\n    return await this.client.requestWithType(\"suix_getDynamicFieldObject\", [input.parentId, input.name], SuiObjectResponse);\n  }\n  /**\n   * Get the sequence number of the latest checkpoint that has been executed\n   */\n  async getLatestCheckpointSequenceNumber() {\n    const resp = await this.client.requestWithType(\"sui_getLatestCheckpointSequenceNumber\", [], string());\n    return String(resp);\n  }\n  /**\n   * Returns information about a given checkpoint\n   */\n  async getCheckpoint(input) {\n    return await this.client.requestWithType(\"sui_getCheckpoint\", [input.id], Checkpoint);\n  }\n  /**\n   * Returns historical checkpoints paginated\n   */\n  async getCheckpoints(input) {\n    const resp = await this.client.requestWithType(\"sui_getCheckpoints\", [input.cursor, input?.limit, input.descendingOrder], CheckpointPage);\n    return resp;\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCommitteeInfo(input) {\n    return await this.client.requestWithType(\"suix_getCommitteeInfo\", [input?.epoch], CommitteeInfo);\n  }\n  async getNetworkMetrics() {\n    return await this.client.requestWithType(\"suix_getNetworkMetrics\", [], NetworkMetrics);\n  }\n  async getAddressMetrics() {\n    return await this.client.requestWithType(\"suix_getLatestAddressMetrics\", [], AddressMetrics);\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getEpochs(input) {\n    return await this.client.requestWithType(\"suix_getEpochs\", [input?.cursor, input?.limit, input?.descendingOrder], EpochPage);\n  }\n  /**\n   * Returns list of top move calls by usage\n   */\n  async getMoveCallMetrics() {\n    return await this.client.requestWithType(\"suix_getMoveCallMetrics\", [], MoveCallMetrics);\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCurrentEpoch() {\n    return await this.client.requestWithType(\"suix_getCurrentEpoch\", [], EpochInfo);\n  }\n  /**\n   * Return the Validators APYs\n   */\n  async getValidatorsApy() {\n    return await this.client.requestWithType(\"suix_getValidatorsApy\", [], ValidatorsApy);\n  }\n  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.\n  async getChainIdentifier() {\n    const checkpoint = await this.getCheckpoint({\n      id: \"0\"\n    });\n    const bytes = fromB58(checkpoint.digest);\n    return toHEX(bytes.slice(0, 4));\n  }\n  async resolveNameServiceAddress(input) {\n    return await this.client.requestWithType(\"suix_resolveNameServiceAddress\", [input.name], nullable(SuiAddress));\n  }\n  async resolveNameServiceNames(input) {\n    return await this.client.requestWithType(\"suix_resolveNameServiceNames\", [input.address], ResolvedNameServiceNames);\n  }\n  async getProtocolConfig(input) {\n    return await this.client.requestWithType(\"sui_getProtocolConfig\", [input?.version], ProtocolConfig);\n  }\n  /**\n   * Wait for a transaction block result to be available over the API.\n   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to\n   * be available via the API.\n   * This currently polls the `getTransactionBlock` API to check for the transaction.\n   */\n  async waitForTransactionBlock(_ref) {\n    let {\n      signal,\n      timeout = 60 * 1e3,\n      pollInterval = 2 * 1e3,\n      ...input\n    } = _ref;\n    const timeoutSignal = AbortSignal.timeout(timeout);\n    const timeoutPromise = new Promise((_, reject) => {\n      timeoutSignal.addEventListener(\"abort\", () => reject(timeoutSignal.reason));\n    });\n    timeoutPromise.catch(() => {});\n    while (!timeoutSignal.aborted) {\n      signal?.throwIfAborted();\n      try {\n        return await this.getTransactionBlock(input);\n      } catch (e) {\n        await Promise.race([new Promise(resolve => setTimeout(resolve, pollInterval)), timeoutPromise]);\n      }\n    }\n    timeoutSignal.throwIfAborted();\n    throw new Error(\"Unexpected error while waiting for transaction block.\");\n  }\n}\nexport { JsonRpcProvider };","map":{"version":3,"names":["JsonRpcClient","PaginatedTransactionResponse","SuiAddress","SuiMoveFunctionArgTypes","SuiMoveNormalizedFunction","SuiMoveNormalizedModule","SuiMoveNormalizedModules","SuiMoveNormalizedStruct","SuiTransactionBlockResponse","PaginatedEvents","DevInspectResults","isValidTransactionDigest","isValidSuiAddress","isValidSuiObjectId","normalizeSuiAddress","normalizeSuiObjectId","CoinMetadataStruct","PaginatedCoins","SuiObjectResponse","DelegatedStake","CoinBalance","CoinSupply","Checkpoint","CommitteeInfo","DryRunTransactionBlockResponse","SuiSystemStateSummary","PaginatedObjectsResponse","ValidatorsApy","MoveCallMetrics","ObjectRead","ResolvedNameServiceNames","ProtocolConfig","DynamicFieldPage","DEFAULT_CLIENT_OPTIONS","WebsocketClient","requestSuiFromFaucet","any","array","string","nullable","fromB58","toB64","toHEX","devnetConnection","TransactionBlock","CheckpointPage","NetworkMetrics","AddressMetrics","EpochInfo","EpochPage","DEFAULT_OPTIONS","socketOptions","versionCacheTimeoutInSeconds","JsonRpcProvider","constructor","connection","arguments","length","undefined","options","opts","client","rpcClient","fullnode","wsClient","websocketClient","websocket","getRpcApiVersion","rpcApiVersion","cacheExpiry","Date","now","resp","requestWithType","info","version","err","console","warn","recipient","httpHeaders","faucet","Error","getCoins","input","owner","coinType","cursor","limit","getAllCoins","getBalance","getAllBalances","getCoinMetadata","getTotalSupply","call","method","params","request","getMoveFunctionArgTypes","package","module","function","getNormalizedMoveModulesByPackage","getNormalizedMoveModule","getNormalizedMoveFunction","getNormalizedMoveStruct","struct","getOwnedObjects","filter","getObject","id","tryGetPastObject","multiGetObjects","ids","forEach","hasDuplicates","Set","size","queryTransactionBlocks","order","getTransactionBlock","digest","multiGetTransactionBlocks","digests","d","executeTransactionBlock","transactionBlock","Array","isArray","signature","requestType","getTotalTransactionBlocks","BigInt","getReferenceGasPrice","getStakes","getStakesByIds","stakedSuiIds","getLatestSuiSystemState","queryEvents","query","subscribeEvent","unsubscribe","onMessage","subscribeTransaction","devInspectTransactionBlock","devInspectTxBytes","is","setSenderIfNotSet","sender","build","provider","onlyTransactionKind","Uint8Array","gasPrice","epoch","dryRunTransactionBlock","getDynamicFields","parentId","getDynamicFieldObject","name","getLatestCheckpointSequenceNumber","String","getCheckpoint","getCheckpoints","descendingOrder","getCommitteeInfo","getNetworkMetrics","getAddressMetrics","getEpochs","getMoveCallMetrics","getCurrentEpoch","getValidatorsApy","getChainIdentifier","checkpoint","bytes","slice","resolveNameServiceAddress","resolveNameServiceNames","address","getProtocolConfig","waitForTransactionBlock","_ref","signal","timeout","pollInterval","timeoutSignal","AbortSignal","timeoutPromise","Promise","_","reject","addEventListener","reason","catch","aborted","throwIfAborted","e","race","resolve","setTimeout"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/providers/json-rpc-provider.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { HttpHeaders } from '../rpc/client.js';\nimport { JsonRpcClient } from '../rpc/client.js';\nimport type {\n\tExecuteTransactionRequestType,\n\tObjectId,\n\tSuiEventFilter,\n\tTransactionDigest,\n\tSuiTransactionBlockResponseQuery,\n\tFaucetResponse,\n\tOrder,\n\tCoinMetadata,\n\tCheckpointDigest,\n\tSuiObjectDataOptions,\n\tSuiTransactionBlockResponseOptions,\n\tSuiEvent,\n\tSuiObjectResponseQuery,\n\tTransactionFilter,\n\tTransactionEffects,\n\tUnsubscribe,\n} from '../types/index.js';\nimport {\n\tPaginatedTransactionResponse,\n\tSuiAddress,\n\tSuiMoveFunctionArgTypes,\n\tSuiMoveNormalizedFunction,\n\tSuiMoveNormalizedModule,\n\tSuiMoveNormalizedModules,\n\tSuiMoveNormalizedStruct,\n\tSuiTransactionBlockResponse,\n\tPaginatedEvents,\n\tDevInspectResults,\n\tisValidTransactionDigest,\n\tisValidSuiAddress,\n\tisValidSuiObjectId,\n\tnormalizeSuiAddress,\n\tnormalizeSuiObjectId,\n\tCoinMetadataStruct,\n\tPaginatedCoins,\n\tSuiObjectResponse,\n\tDelegatedStake,\n\tCoinBalance,\n\tCoinSupply,\n\tCheckpoint,\n\tCommitteeInfo,\n\tDryRunTransactionBlockResponse,\n\tSuiSystemStateSummary,\n\tPaginatedObjectsResponse,\n\tValidatorsApy,\n\tMoveCallMetrics,\n\tObjectRead,\n\tResolvedNameServiceNames,\n\tProtocolConfig,\n} from '../types/index.js';\nimport type { DynamicFieldName } from '../types/dynamic_fields.js';\nimport { DynamicFieldPage } from '../types/dynamic_fields.js';\nimport type { WebsocketClientOptions } from '../rpc/websocket-client.js';\nimport { DEFAULT_CLIENT_OPTIONS, WebsocketClient } from '../rpc/websocket-client.js';\nimport { requestSuiFromFaucet } from '../rpc/faucet-client.js';\nimport { any, array, string, nullable } from 'superstruct';\nimport { fromB58, toB64, toHEX } from '@mysten/bcs';\nimport type { SerializedSignature } from '../cryptography/signature.js';\nimport type { Connection } from '../rpc/connection.js';\nimport { devnetConnection } from '../rpc/connection.js';\nimport { TransactionBlock } from '../builder/index.js';\nimport { CheckpointPage } from '../types/checkpoints.js';\nimport { NetworkMetrics, AddressMetrics } from '../types/metrics.js';\nimport { EpochInfo, EpochPage } from '../types/epochs.js';\n\nexport interface PaginationArguments<Cursor> {\n\t/** Optional paging cursor */\n\tcursor?: Cursor;\n\t/** Maximum item returned per page */\n\tlimit?: number | null;\n}\n\nexport interface OrderArguments {\n\torder?: Order | null;\n}\n\n/**\n * Configuration options for the JsonRpcProvider. If the value of a field is not provided,\n * value in `DEFAULT_OPTIONS` for that field will be used\n */\nexport type RpcProviderOptions = {\n\t/**\n\t * Configuration options for the websocket connection\n\t * TODO: Move to connection.\n\t */\n\tsocketOptions?: WebsocketClientOptions;\n\t/**\n\t * Cache timeout in seconds for the RPC API Version\n\t */\n\tversionCacheTimeoutInSeconds?: number;\n\n\t/** Allow defining a custom RPC client to use */\n\trpcClient?: JsonRpcClient;\n\n\t/** Allow defining a custom websocket client to use */\n\twebsocketClient?: WebsocketClient;\n};\n\nconst DEFAULT_OPTIONS: RpcProviderOptions = {\n\tsocketOptions: DEFAULT_CLIENT_OPTIONS,\n\tversionCacheTimeoutInSeconds: 600,\n};\n\nexport class JsonRpcProvider {\n\tpublic connection: Connection;\n\tprotected client: JsonRpcClient;\n\tprotected wsClient: WebsocketClient;\n\tprivate rpcApiVersion: string | undefined;\n\tprivate cacheExpiry: number | undefined;\n\t/**\n\t * Establish a connection to a Sui RPC endpoint\n\t *\n\t * @param connection The `Connection` object containing configuration for the network.\n\t * @param options configuration options for the provider\n\t */\n\tconstructor(\n\t\t// TODO: Probably remove the default endpoint here:\n\t\tconnection: Connection = devnetConnection,\n\t\tpublic options: RpcProviderOptions = DEFAULT_OPTIONS,\n\t) {\n\t\tthis.connection = connection;\n\n\t\tconst opts = { ...DEFAULT_OPTIONS, ...options };\n\t\tthis.options = opts;\n\t\t// TODO: add header for websocket request\n\t\tthis.client = opts.rpcClient ?? new JsonRpcClient(this.connection.fullnode);\n\n\t\tthis.wsClient =\n\t\t\topts.websocketClient ?? new WebsocketClient(this.connection.websocket, opts.socketOptions);\n\t}\n\n\tasync getRpcApiVersion(): Promise<string | undefined> {\n\t\tif (this.rpcApiVersion && this.cacheExpiry && this.cacheExpiry <= Date.now()) {\n\t\t\treturn this.rpcApiVersion;\n\t\t}\n\n\t\ttry {\n\t\t\tconst resp = await this.client.requestWithType('rpc.discover', [], any());\n\t\t\tthis.rpcApiVersion = resp.info.version;\n\t\t\tthis.cacheExpiry =\n\t\t\t\t// Date.now() is in milliseconds, but the timeout is in seconds\n\t\t\t\tDate.now() + (this.options.versionCacheTimeoutInSeconds ?? 0) * 1000;\n\t\t\treturn this.rpcApiVersion;\n\t\t} catch (err) {\n\t\t\tconsole.warn('Error fetching version number of the RPC API', err);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tasync requestSuiFromFaucet(\n\t\trecipient: SuiAddress,\n\t\thttpHeaders?: HttpHeaders,\n\t): Promise<FaucetResponse> {\n\t\tif (!this.connection.faucet) {\n\t\t\tthrow new Error('Faucet URL is not specified');\n\t\t}\n\t\treturn requestSuiFromFaucet(this.connection.faucet, recipient, httpHeaders);\n\t}\n\n\t/**\n\t * Get all Coin<`coin_type`> objects owned by an address.\n\t */\n\tasync getCoins(\n\t\tinput: {\n\t\t\towner: SuiAddress;\n\t\t\tcoinType?: string | null;\n\t\t} & PaginationArguments<PaginatedCoins['nextCursor']>,\n\t): Promise<PaginatedCoins> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getCoins',\n\t\t\t[input.owner, input.coinType, input.cursor, input.limit],\n\t\t\tPaginatedCoins,\n\t\t);\n\t}\n\n\t/**\n\t * Get all Coin objects owned by an address.\n\t */\n\tasync getAllCoins(\n\t\tinput: {\n\t\t\towner: SuiAddress;\n\t\t} & PaginationArguments<PaginatedCoins['nextCursor']>,\n\t): Promise<PaginatedCoins> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getAllCoins',\n\t\t\t[input.owner, input.cursor, input.limit],\n\t\t\tPaginatedCoins,\n\t\t);\n\t}\n\n\t/**\n\t * Get the total coin balance for one coin type, owned by the address owner.\n\t */\n\tasync getBalance(input: {\n\t\towner: SuiAddress;\n\t\t/** optional fully qualified type names for the coin (e.g., 0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC), default to 0x2::sui::SUI if not specified. */\n\t\tcoinType?: string | null;\n\t}): Promise<CoinBalance> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getBalance',\n\t\t\t[input.owner, input.coinType],\n\t\t\tCoinBalance,\n\t\t);\n\t}\n\n\t/**\n\t * Get the total coin balance for all coin types, owned by the address owner.\n\t */\n\tasync getAllBalances(input: { owner: SuiAddress }): Promise<CoinBalance[]> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getAllBalances',\n\t\t\t[input.owner],\n\t\t\tarray(CoinBalance),\n\t\t);\n\t}\n\n\t/**\n\t * Fetch CoinMetadata for a given coin type\n\t */\n\tasync getCoinMetadata(input: { coinType: string }): Promise<CoinMetadata | null> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getCoinMetadata',\n\t\t\t[input.coinType],\n\t\t\tCoinMetadataStruct,\n\t\t);\n\t}\n\n\t/**\n\t *  Fetch total supply for a coin\n\t */\n\tasync getTotalSupply(input: { coinType: string }): Promise<CoinSupply> {\n\t\treturn await this.client.requestWithType('suix_getTotalSupply', [input.coinType], CoinSupply);\n\t}\n\n\t/**\n\t * Invoke any RPC method\n\t * @param method the method to be invoked\n\t * @param args the arguments to be passed to the RPC request\n\t */\n\tasync call(method: string, params: any[]): Promise<any> {\n\t\treturn await this.client.request(method, params);\n\t}\n\n\t/**\n\t * Get Move function argument types like read, write and full access\n\t */\n\tasync getMoveFunctionArgTypes(input: {\n\t\tpackage: string;\n\t\tmodule: string;\n\t\tfunction: string;\n\t}): Promise<SuiMoveFunctionArgTypes> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_getMoveFunctionArgTypes',\n\t\t\t[input.package, input.module, input.function],\n\t\t\tSuiMoveFunctionArgTypes,\n\t\t);\n\t}\n\n\t/**\n\t * Get a map from module name to\n\t * structured representations of Move modules\n\t */\n\tasync getNormalizedMoveModulesByPackage(input: {\n\t\tpackage: string;\n\t}): Promise<SuiMoveNormalizedModules> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_getNormalizedMoveModulesByPackage',\n\t\t\t[input.package],\n\t\t\tSuiMoveNormalizedModules,\n\t\t);\n\t}\n\n\t/**\n\t * Get a structured representation of Move module\n\t */\n\tasync getNormalizedMoveModule(input: {\n\t\tpackage: string;\n\t\tmodule: string;\n\t}): Promise<SuiMoveNormalizedModule> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_getNormalizedMoveModule',\n\t\t\t[input.package, input.module],\n\t\t\tSuiMoveNormalizedModule,\n\t\t);\n\t}\n\n\t/**\n\t * Get a structured representation of Move function\n\t */\n\tasync getNormalizedMoveFunction(input: {\n\t\tpackage: string;\n\t\tmodule: string;\n\t\tfunction: string;\n\t}): Promise<SuiMoveNormalizedFunction> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_getNormalizedMoveFunction',\n\t\t\t[input.package, input.module, input.function],\n\t\t\tSuiMoveNormalizedFunction,\n\t\t);\n\t}\n\n\t/**\n\t * Get a structured representation of Move struct\n\t */\n\tasync getNormalizedMoveStruct(input: {\n\t\tpackage: string;\n\t\tmodule: string;\n\t\tstruct: string;\n\t}): Promise<SuiMoveNormalizedStruct> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_getNormalizedMoveStruct',\n\t\t\t[input.package, input.module, input.struct],\n\t\t\tSuiMoveNormalizedStruct,\n\t\t);\n\t}\n\n\t/**\n\t * Get all objects owned by an address\n\t */\n\tasync getOwnedObjects(\n\t\tinput: {\n\t\t\towner: SuiAddress;\n\t\t} & PaginationArguments<PaginatedObjectsResponse['nextCursor']> &\n\t\t\tSuiObjectResponseQuery,\n\t): Promise<PaginatedObjectsResponse> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getOwnedObjects',\n\t\t\t[\n\t\t\t\tinput.owner,\n\t\t\t\t{\n\t\t\t\t\tfilter: input.filter,\n\t\t\t\t\toptions: input.options,\n\t\t\t\t} as SuiObjectResponseQuery,\n\t\t\t\tinput.cursor,\n\t\t\t\tinput.limit,\n\t\t\t],\n\t\t\tPaginatedObjectsResponse,\n\t\t);\n\t}\n\n\t/**\n\t * Get details about an object\n\t */\n\tasync getObject(input: {\n\t\tid: ObjectId;\n\t\toptions?: SuiObjectDataOptions;\n\t}): Promise<SuiObjectResponse> {\n\t\tif (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {\n\t\t\tthrow new Error('Invalid Sui Object id');\n\t\t}\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_getObject',\n\t\t\t[input.id, input.options],\n\t\t\tSuiObjectResponse,\n\t\t);\n\t}\n\n\tasync tryGetPastObject(input: {\n\t\tid: ObjectId;\n\t\tversion: number;\n\t\toptions?: SuiObjectDataOptions;\n\t}): Promise<ObjectRead> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_tryGetPastObject',\n\t\t\t[input.id, input.version, input.options],\n\t\t\tObjectRead,\n\t\t);\n\t}\n\n\t/**\n\t * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail\n\t */\n\tasync multiGetObjects(input: {\n\t\tids: ObjectId[];\n\t\toptions?: SuiObjectDataOptions;\n\t}): Promise<SuiObjectResponse[]> {\n\t\tinput.ids.forEach((id) => {\n\t\t\tif (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n\t\t\t\tthrow new Error(`Invalid Sui Object id ${id}`);\n\t\t\t}\n\t\t});\n\t\tconst hasDuplicates = input.ids.length !== new Set(input.ids).size;\n\t\tif (hasDuplicates) {\n\t\t\tthrow new Error(`Duplicate object ids in batch call ${input.ids}`);\n\t\t}\n\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_multiGetObjects',\n\t\t\t[input.ids, input.options],\n\t\t\tarray(SuiObjectResponse),\n\t\t);\n\t}\n\n\t/**\n\t * Get transaction blocks for a given query criteria\n\t */\n\tasync queryTransactionBlocks(\n\t\tinput: SuiTransactionBlockResponseQuery &\n\t\t\tPaginationArguments<PaginatedTransactionResponse['nextCursor']> &\n\t\t\tOrderArguments,\n\t): Promise<PaginatedTransactionResponse> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_queryTransactionBlocks',\n\t\t\t[\n\t\t\t\t{\n\t\t\t\t\tfilter: input.filter,\n\t\t\t\t\toptions: input.options,\n\t\t\t\t} as SuiTransactionBlockResponseQuery,\n\t\t\t\tinput.cursor,\n\t\t\t\tinput.limit,\n\t\t\t\t(input.order || 'descending') === 'descending',\n\t\t\t],\n\t\t\tPaginatedTransactionResponse,\n\t\t);\n\t}\n\n\tasync getTransactionBlock(input: {\n\t\tdigest: TransactionDigest;\n\t\toptions?: SuiTransactionBlockResponseOptions;\n\t}): Promise<SuiTransactionBlockResponse> {\n\t\tif (!isValidTransactionDigest(input.digest)) {\n\t\t\tthrow new Error('Invalid Transaction digest');\n\t\t}\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_getTransactionBlock',\n\t\t\t[input.digest, input.options],\n\t\t\tSuiTransactionBlockResponse,\n\t\t);\n\t}\n\n\tasync multiGetTransactionBlocks(input: {\n\t\tdigests: TransactionDigest[];\n\t\toptions?: SuiTransactionBlockResponseOptions;\n\t}): Promise<SuiTransactionBlockResponse[]> {\n\t\tinput.digests.forEach((d) => {\n\t\t\tif (!isValidTransactionDigest(d)) {\n\t\t\t\tthrow new Error(`Invalid Transaction digest ${d}`);\n\t\t\t}\n\t\t});\n\n\t\tconst hasDuplicates = input.digests.length !== new Set(input.digests).size;\n\t\tif (hasDuplicates) {\n\t\t\tthrow new Error(`Duplicate digests in batch call ${input.digests}`);\n\t\t}\n\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_multiGetTransactionBlocks',\n\t\t\t[input.digests, input.options],\n\t\t\tarray(SuiTransactionBlockResponse),\n\t\t);\n\t}\n\n\tasync executeTransactionBlock(input: {\n\t\ttransactionBlock: Uint8Array | string;\n\t\tsignature: SerializedSignature | SerializedSignature[];\n\t\toptions?: SuiTransactionBlockResponseOptions;\n\t\trequestType?: ExecuteTransactionRequestType;\n\t}): Promise<SuiTransactionBlockResponse> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_executeTransactionBlock',\n\t\t\t[\n\t\t\t\ttypeof input.transactionBlock === 'string'\n\t\t\t\t\t? input.transactionBlock\n\t\t\t\t\t: toB64(input.transactionBlock),\n\t\t\t\tArray.isArray(input.signature) ? input.signature : [input.signature],\n\t\t\t\tinput.options,\n\t\t\t\tinput.requestType,\n\t\t\t],\n\t\t\tSuiTransactionBlockResponse,\n\t\t);\n\t}\n\n\t/**\n\t * Get total number of transactions\n\t */\n\n\tasync getTotalTransactionBlocks(): Promise<bigint> {\n\t\tconst resp = await this.client.requestWithType('sui_getTotalTransactionBlocks', [], string());\n\t\treturn BigInt(resp);\n\t}\n\n\t/**\n\t * Getting the reference gas price for the network\n\t */\n\tasync getReferenceGasPrice(): Promise<bigint> {\n\t\tconst resp = await this.client.requestWithType('suix_getReferenceGasPrice', [], string());\n\t\treturn BigInt(resp);\n\t}\n\n\t/**\n\t * Return the delegated stakes for an address\n\t */\n\tasync getStakes(input: { owner: SuiAddress }): Promise<DelegatedStake[]> {\n\t\tif (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n\t\t\tthrow new Error('Invalid Sui address');\n\t\t}\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getStakes',\n\t\t\t[input.owner],\n\t\t\tarray(DelegatedStake),\n\t\t);\n\t}\n\n\t/**\n\t * Return the delegated stakes queried by id.\n\t */\n\tasync getStakesByIds(input: { stakedSuiIds: ObjectId[] }): Promise<DelegatedStake[]> {\n\t\tinput.stakedSuiIds.forEach((id) => {\n\t\t\tif (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n\t\t\t\tthrow new Error(`Invalid Sui Stake id ${id}`);\n\t\t\t}\n\t\t});\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getStakesByIds',\n\t\t\t[input.stakedSuiIds],\n\t\t\tarray(DelegatedStake),\n\t\t);\n\t}\n\n\t/**\n\t * Return the latest system state content.\n\t */\n\tasync getLatestSuiSystemState(): Promise<SuiSystemStateSummary> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getLatestSuiSystemState',\n\t\t\t[],\n\t\t\tSuiSystemStateSummary,\n\t\t);\n\t}\n\n\t/**\n\t * Get events for a given query criteria\n\t */\n\tasync queryEvents(\n\t\tinput: {\n\t\t\t/** the event query criteria. */\n\t\t\tquery: SuiEventFilter;\n\t\t} & PaginationArguments<PaginatedEvents['nextCursor']> &\n\t\t\tOrderArguments,\n\t): Promise<PaginatedEvents> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_queryEvents',\n\t\t\t[input.query, input.cursor, input.limit, (input.order || 'descending') === 'descending'],\n\t\t\tPaginatedEvents,\n\t\t);\n\t}\n\n\t/**\n\t * Subscribe to get notifications whenever an event matching the filter occurs\n\t */\n\tasync subscribeEvent(input: {\n\t\t/** filter describing the subset of events to follow */\n\t\tfilter: SuiEventFilter;\n\t\t/** function to run when we receive a notification of a new event matching the filter */\n\t\tonMessage: (event: SuiEvent) => void;\n\t}): Promise<Unsubscribe> {\n\t\treturn this.wsClient.request({\n\t\t\tmethod: 'suix_subscribeEvent',\n\t\t\tunsubscribe: 'suix_unsubscribeEvent',\n\t\t\tparams: [input.filter],\n\t\t\tonMessage: input.onMessage,\n\t\t});\n\t}\n\n\tasync subscribeTransaction(input: {\n\t\t/** filter describing the subset of events to follow */\n\t\tfilter: TransactionFilter;\n\t\t/** function to run when we receive a notification of a new event matching the filter */\n\t\tonMessage: (event: TransactionEffects) => void;\n\t}): Promise<Unsubscribe> {\n\t\treturn this.wsClient.request({\n\t\t\tmethod: 'suix_subscribeTransaction',\n\t\t\tunsubscribe: 'suix_unsubscribeTransaction',\n\t\t\tparams: [input.filter],\n\t\t\tonMessage: input.onMessage,\n\t\t});\n\t}\n\n\t/**\n\t * Runs the transaction block in dev-inspect mode. Which allows for nearly any\n\t * transaction (or Move call) with any arguments. Detailed results are\n\t * provided, including both the transaction effects and any return values.\n\t */\n\tasync devInspectTransactionBlock(input: {\n\t\ttransactionBlock: TransactionBlock | string | Uint8Array;\n\t\tsender: SuiAddress;\n\t\t/** Default to use the network reference gas price stored in the Sui System State object */\n\t\tgasPrice?: bigint | number | null;\n\t\t/** optional. Default to use the current epoch number stored in the Sui System State object */\n\t\tepoch?: string | null;\n\t}): Promise<DevInspectResults> {\n\t\tlet devInspectTxBytes;\n\t\tif (TransactionBlock.is(input.transactionBlock)) {\n\t\t\tinput.transactionBlock.setSenderIfNotSet(input.sender);\n\t\t\tdevInspectTxBytes = toB64(\n\t\t\t\tawait input.transactionBlock.build({\n\t\t\t\t\tprovider: this,\n\t\t\t\t\tonlyTransactionKind: true,\n\t\t\t\t}),\n\t\t\t);\n\t\t} else if (typeof input.transactionBlock === 'string') {\n\t\t\tdevInspectTxBytes = input.transactionBlock;\n\t\t} else if (input.transactionBlock instanceof Uint8Array) {\n\t\t\tdevInspectTxBytes = toB64(input.transactionBlock);\n\t\t} else {\n\t\t\tthrow new Error('Unknown transaction block format.');\n\t\t}\n\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_devInspectTransactionBlock',\n\t\t\t[input.sender, devInspectTxBytes, input.gasPrice, input.epoch],\n\t\t\tDevInspectResults,\n\t\t);\n\t}\n\n\t/**\n\t * Dry run a transaction block and return the result.\n\t */\n\tasync dryRunTransactionBlock(input: {\n\t\ttransactionBlock: Uint8Array | string;\n\t}): Promise<DryRunTransactionBlockResponse> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_dryRunTransactionBlock',\n\t\t\t[\n\t\t\t\ttypeof input.transactionBlock === 'string'\n\t\t\t\t\t? input.transactionBlock\n\t\t\t\t\t: toB64(input.transactionBlock),\n\t\t\t],\n\t\t\tDryRunTransactionBlockResponse,\n\t\t);\n\t}\n\n\t/**\n\t * Return the list of dynamic field objects owned by an object\n\t */\n\tasync getDynamicFields(\n\t\tinput: {\n\t\t\t/** The id of the parent object */\n\t\t\tparentId: ObjectId;\n\t\t} & PaginationArguments<DynamicFieldPage['nextCursor']>,\n\t): Promise<DynamicFieldPage> {\n\t\tif (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {\n\t\t\tthrow new Error('Invalid Sui Object id');\n\t\t}\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getDynamicFields',\n\t\t\t[input.parentId, input.cursor, input.limit],\n\t\t\tDynamicFieldPage,\n\t\t);\n\t}\n\n\t/**\n\t * Return the dynamic field object information for a specified object\n\t */\n\tasync getDynamicFieldObject(input: {\n\t\t/** The ID of the quered parent object */\n\t\tparentId: ObjectId;\n\t\t/** The name of the dynamic field */\n\t\tname: string | DynamicFieldName;\n\t}): Promise<SuiObjectResponse> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getDynamicFieldObject',\n\t\t\t[input.parentId, input.name],\n\t\t\tSuiObjectResponse,\n\t\t);\n\t}\n\n\t/**\n\t * Get the sequence number of the latest checkpoint that has been executed\n\t */\n\tasync getLatestCheckpointSequenceNumber(): Promise<string> {\n\t\tconst resp = await this.client.requestWithType(\n\t\t\t'sui_getLatestCheckpointSequenceNumber',\n\t\t\t[],\n\t\t\tstring(),\n\t\t);\n\t\treturn String(resp);\n\t}\n\n\t/**\n\t * Returns information about a given checkpoint\n\t */\n\tasync getCheckpoint(input: {\n\t\t/** The checkpoint digest or sequence number */\n\t\tid: CheckpointDigest | string;\n\t}): Promise<Checkpoint> {\n\t\treturn await this.client.requestWithType('sui_getCheckpoint', [input.id], Checkpoint);\n\t}\n\n\t/**\n\t * Returns historical checkpoints paginated\n\t */\n\tasync getCheckpoints(\n\t\tinput: {\n\t\t\t/** query result ordering, default to false (ascending order), oldest record first */\n\t\t\tdescendingOrder: boolean;\n\t\t} & PaginationArguments<CheckpointPage['nextCursor']>,\n\t): Promise<CheckpointPage> {\n\t\tconst resp = await this.client.requestWithType(\n\t\t\t'sui_getCheckpoints',\n\t\t\t[input.cursor, input?.limit, input.descendingOrder],\n\t\t\tCheckpointPage,\n\t\t);\n\t\treturn resp;\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getCommitteeInfo(input?: {\n\t\t/** The epoch of interest. If null, default to the latest epoch */\n\t\tepoch?: string | null;\n\t}): Promise<CommitteeInfo> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getCommitteeInfo',\n\t\t\t[input?.epoch],\n\t\t\tCommitteeInfo,\n\t\t);\n\t}\n\n\tasync getNetworkMetrics() {\n\t\treturn await this.client.requestWithType('suix_getNetworkMetrics', [], NetworkMetrics);\n\t}\n\n\tasync getAddressMetrics() {\n\t\treturn await this.client.requestWithType('suix_getLatestAddressMetrics', [], AddressMetrics);\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getEpochs(\n\t\tinput?: {\n\t\t\tdescendingOrder?: boolean;\n\t\t} & PaginationArguments<EpochPage['nextCursor']>,\n\t): Promise<EpochPage> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_getEpochs',\n\t\t\t[input?.cursor, input?.limit, input?.descendingOrder],\n\t\t\tEpochPage,\n\t\t);\n\t}\n\n\t/**\n\t * Returns list of top move calls by usage\n\t */\n\tasync getMoveCallMetrics(): Promise<MoveCallMetrics> {\n\t\treturn await this.client.requestWithType('suix_getMoveCallMetrics', [], MoveCallMetrics);\n\t}\n\n\t/**\n\t * Return the committee information for the asked epoch\n\t */\n\tasync getCurrentEpoch(): Promise<EpochInfo> {\n\t\treturn await this.client.requestWithType('suix_getCurrentEpoch', [], EpochInfo);\n\t}\n\n\t/**\n\t * Return the Validators APYs\n\t */\n\tasync getValidatorsApy(): Promise<ValidatorsApy> {\n\t\treturn await this.client.requestWithType('suix_getValidatorsApy', [], ValidatorsApy);\n\t}\n\n\t// TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.\n\tasync getChainIdentifier(): Promise<string> {\n\t\tconst checkpoint = await this.getCheckpoint({ id: '0' });\n\t\tconst bytes = fromB58(checkpoint.digest);\n\t\treturn toHEX(bytes.slice(0, 4));\n\t}\n\n\tasync resolveNameServiceAddress(input: { name: string }): Promise<SuiAddress | null> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_resolveNameServiceAddress',\n\t\t\t[input.name],\n\t\t\tnullable(SuiAddress),\n\t\t);\n\t}\n\n\tasync resolveNameServiceNames(\n\t\tinput: {\n\t\t\taddress: string;\n\t\t} & PaginationArguments<ResolvedNameServiceNames['nextCursor']>,\n\t): Promise<ResolvedNameServiceNames> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'suix_resolveNameServiceNames',\n\t\t\t[input.address],\n\t\t\tResolvedNameServiceNames,\n\t\t);\n\t}\n\n\tasync getProtocolConfig(input?: { version?: string }): Promise<ProtocolConfig> {\n\t\treturn await this.client.requestWithType(\n\t\t\t'sui_getProtocolConfig',\n\t\t\t[input?.version],\n\t\t\tProtocolConfig,\n\t\t);\n\t}\n\n\t/**\n\t * Wait for a transaction block result to be available over the API.\n\t * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to\n\t * be available via the API.\n\t * This currently polls the `getTransactionBlock` API to check for the transaction.\n\t */\n\tasync waitForTransactionBlock({\n\t\tsignal,\n\t\ttimeout = 60 * 1000,\n\t\tpollInterval = 2 * 1000,\n\t\t...input\n\t}: {\n\t\t/** An optional abort signal that can be used to cancel */\n\t\tsignal?: AbortSignal;\n\t\t/** The amount of time to wait for a transaction block. Defaults to one minute. */\n\t\ttimeout?: number;\n\t\t/** The amount of time to wait between checks for the transaction block. Defaults to 2 seconds. */\n\t\tpollInterval?: number;\n\t} & Parameters<JsonRpcProvider['getTransactionBlock']>[0]): Promise<SuiTransactionBlockResponse> {\n\t\tconst timeoutSignal = AbortSignal.timeout(timeout);\n\t\tconst timeoutPromise = new Promise((_, reject) => {\n\t\t\ttimeoutSignal.addEventListener('abort', () => reject(timeoutSignal.reason));\n\t\t});\n\n\t\ttimeoutPromise.catch(() => {\n\t\t\t// Swallow unhandled rejections that might be thrown after early return\n\t\t});\n\n\t\twhile (!timeoutSignal.aborted) {\n\t\t\tsignal?.throwIfAborted();\n\t\t\ttry {\n\t\t\t\treturn await this.getTransactionBlock(input);\n\t\t\t} catch (e) {\n\t\t\t\t// Wait for either the next poll interval, or the timeout.\n\t\t\t\tawait Promise.race([\n\t\t\t\t\tnew Promise((resolve) => setTimeout(resolve, pollInterval)),\n\t\t\t\t\ttimeoutPromise,\n\t\t\t\t]);\n\t\t\t}\n\t\t}\n\n\t\ttimeoutSignal.throwIfAborted();\n\n\t\t// This should never happen, because the above case should always throw, but just adding it in the event that something goes horribly wrong.\n\t\tthrow new Error('Unexpected error while waiting for transaction block.');\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}