{"ast":null,"code":"import { fromB64, toB64 } from \"@mysten/bcs\";\nimport { SIGNATURE_SCHEME_TO_FLAG } from \"./signature.js\";\nimport { toSingleSignaturePubkeyPair } from \"./utils.js\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport { normalizeSuiAddress } from \"../types/index.js\";\nimport { Ed25519PublicKey } from \"../keypairs/ed25519/publickey.js\";\nimport { Secp256k1PublicKey } from \"../keypairs/secp256k1/publickey.js\";\nimport { Secp256r1PublicKey } from \"../keypairs/secp256r1/publickey.js\";\nimport { builder } from \"../builder/bcs.js\";\nconst MAX_SIGNER_IN_MULTISIG = 10;\nfunction toMultiSigAddress(pks, threshold) {\n  if (pks.length > MAX_SIGNER_IN_MULTISIG) {\n    throw new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n  }\n  let maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;\n  let tmp = new Uint8Array(maxLength);\n  tmp.set([SIGNATURE_SCHEME_TO_FLAG[\"MultiSig\"]]);\n  let arr = to_uint8array(threshold);\n  tmp.set(arr, 1);\n  let i = 3;\n  for (const pk of pks) {\n    tmp.set([pk.pubKey.flag()], i);\n    tmp.set(pk.pubKey.toBytes(), i + 1);\n    tmp.set([pk.weight], i + 1 + pk.pubKey.toBytes().length);\n    i += pk.pubKey.toBytes().length + 2;\n  }\n  return normalizeSuiAddress(bytesToHex(blake2b(tmp.slice(0, i), {\n    dkLen: 32\n  })));\n}\nfunction combinePartialSigs(sigs, pks, threshold) {\n  let multisig_pk = {\n    pk_map: pks.map(x => toPkWeightPair(x)),\n    threshold\n  };\n  let bitmap = 0;\n  let compressed_sigs = new Array(sigs.length);\n  for (let i = 0; i < sigs.length; i++) {\n    let parsed = toSingleSignaturePubkeyPair(sigs[i]);\n    let bytes2 = Array.from(parsed.signature.map(x => Number(x)));\n    if (parsed.signatureScheme === \"ED25519\") {\n      compressed_sigs[i] = {\n        ED25519: bytes2\n      };\n    } else if (parsed.signatureScheme === \"Secp256k1\") {\n      compressed_sigs[i] = {\n        Secp256k1: bytes2\n      };\n    } else if (parsed.signatureScheme === \"Secp256r1\") {\n      compressed_sigs[i] = {\n        Secp256r1: bytes2\n      };\n    }\n    for (let j = 0; j < pks.length; j++) {\n      if (parsed.pubKey.equals(pks[j].pubKey)) {\n        bitmap |= 1 << j;\n        break;\n      }\n    }\n  }\n  let multisig = {\n    sigs: compressed_sigs,\n    bitmap,\n    multisig_pk\n  };\n  const bytes = builder.ser(\"MultiSig\", multisig).toBytes();\n  let tmp = new Uint8Array(bytes.length + 1);\n  tmp.set([SIGNATURE_SCHEME_TO_FLAG[\"MultiSig\"]]);\n  tmp.set(bytes, 1);\n  return toB64(tmp);\n}\nfunction decodeMultiSig(signature) {\n  const parsed = fromB64(signature);\n  if (parsed.length < 1 || parsed[0] !== SIGNATURE_SCHEME_TO_FLAG[\"MultiSig\"]) {\n    throw new Error(\"Invalid MultiSig flag\");\n  }\n  const multisig = builder.de(\"MultiSig\", parsed.slice(1));\n  let res = new Array(multisig.sigs.length);\n  for (let i = 0; i < multisig.sigs.length; i++) {\n    let s = multisig.sigs[i];\n    let pk_index = as_indices(multisig.bitmap).at(i);\n    let pk_bytes = Object.values(multisig.multisig_pk.pk_map[pk_index].pubKey)[0];\n    const scheme = Object.keys(s)[0];\n    if (scheme === \"MultiSig\") {\n      throw new Error(\"MultiSig is not supported inside MultiSig\");\n    }\n    const SIGNATURE_SCHEME_TO_PUBLIC_KEY = {\n      ED25519: Ed25519PublicKey,\n      Secp256k1: Secp256k1PublicKey,\n      Secp256r1: Secp256r1PublicKey\n    };\n    const PublicKey = SIGNATURE_SCHEME_TO_PUBLIC_KEY[scheme];\n    res[i] = {\n      signatureScheme: scheme,\n      signature: Uint8Array.from(Object.values(s)[0]),\n      pubKey: new PublicKey(pk_bytes)\n    };\n  }\n  return res;\n}\nfunction toPkWeightPair(pair) {\n  let pk_bytes = Array.from(pair.pubKey.toBytes().map(x => Number(x)));\n  switch (pair.pubKey.flag()) {\n    case SIGNATURE_SCHEME_TO_FLAG[\"Secp256k1\"]:\n      return {\n        pubKey: {\n          Secp256k1: pk_bytes\n        },\n        weight: pair.weight\n      };\n    case SIGNATURE_SCHEME_TO_FLAG[\"Secp256r1\"]:\n      return {\n        pubKey: {\n          Secp256r1: pk_bytes\n        },\n        weight: pair.weight\n      };\n    case SIGNATURE_SCHEME_TO_FLAG[\"ED25519\"]:\n      return {\n        pubKey: {\n          ED25519: pk_bytes\n        },\n        weight: pair.weight\n      };\n    default:\n      throw new Error(\"Unsupported signature scheme\");\n  }\n}\nfunction to_uint8array(threshold) {\n  if (threshold < 0 || threshold > 65535) {\n    throw new Error(\"Invalid threshold\");\n  }\n  let arr = new Uint8Array(2);\n  arr[0] = threshold & 255;\n  arr[1] = threshold >> 8;\n  return arr;\n}\nfunction as_indices(bitmap) {\n  if (bitmap < 0 || bitmap > 1024) {\n    throw new Error(\"Invalid bitmap\");\n  }\n  let res = [];\n  for (let i = 0; i < 10; i++) {\n    if ((bitmap & 1 << i) !== 0) {\n      res.push(i);\n    }\n  }\n  return Uint8Array.from(res);\n}\nexport { MAX_SIGNER_IN_MULTISIG, combinePartialSigs, decodeMultiSig, toMultiSigAddress };","map":{"version":3,"names":["fromB64","toB64","SIGNATURE_SCHEME_TO_FLAG","toSingleSignaturePubkeyPair","blake2b","bytesToHex","normalizeSuiAddress","Ed25519PublicKey","Secp256k1PublicKey","Secp256r1PublicKey","builder","MAX_SIGNER_IN_MULTISIG","toMultiSigAddress","pks","threshold","length","Error","maxLength","tmp","Uint8Array","set","arr","to_uint8array","i","pk","pubKey","flag","toBytes","weight","slice","dkLen","combinePartialSigs","sigs","multisig_pk","pk_map","map","x","toPkWeightPair","bitmap","compressed_sigs","Array","parsed","bytes2","from","signature","Number","signatureScheme","ED25519","Secp256k1","Secp256r1","j","equals","multisig","bytes","ser","decodeMultiSig","de","res","s","pk_index","as_indices","at","pk_bytes","Object","values","scheme","keys","SIGNATURE_SCHEME_TO_PUBLIC_KEY","PublicKey","pair","push"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/multisig.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@mysten/bcs';\nimport type { SerializedSignature, SignaturePubkeyPair, SignatureScheme } from './signature.js';\nimport { SIGNATURE_SCHEME_TO_FLAG } from './signature.js';\n// eslint-disable-next-line import/no-cycle\nimport { toSingleSignaturePubkeyPair } from './utils.js';\nimport type { PublicKey } from './publickey.js';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { normalizeSuiAddress } from '../types/index.js';\nimport { Ed25519PublicKey } from '../keypairs/ed25519/publickey.js';\nimport { Secp256k1PublicKey } from '../keypairs/secp256k1/publickey.js';\nimport { Secp256r1PublicKey } from '../keypairs/secp256r1/publickey.js';\nimport { builder } from '../builder/bcs.js';\n\nexport type PubkeyWeightPair = {\n\tpubKey: PublicKey;\n\tweight: number;\n};\n\nexport type CompressedSignature =\n\t| { ED25519: number[] }\n\t| { Secp256k1: number[] }\n\t| { Secp256r1: number[] };\n\nexport type PublicKeyEnum =\n\t| { ED25519: number[] }\n\t| { Secp256k1: number[] }\n\t| { Secp256r1: number[] };\n\nexport type PubkeyEnumWeightPair = {\n\tpubKey: PublicKeyEnum;\n\tweight: number;\n};\n\nexport type MultiSigPublicKey = {\n\tpk_map: PubkeyEnumWeightPair[];\n\tthreshold: number;\n};\n\nexport type MultiSig = {\n\tsigs: CompressedSignature[];\n\tbitmap: number;\n\tmultisig_pk: MultiSigPublicKey;\n};\n\nexport const MAX_SIGNER_IN_MULTISIG = 10;\n\n/// Derives a multisig address from a list of pk and weights and threshold.\n// It is the 32-byte Blake2b hash of the serializd bytes of `flag_MultiSig || threshold || flag_1 || pk_1 || weight_1\n/// || ... || flag_n || pk_n || weight_n`\nexport function toMultiSigAddress(pks: PubkeyWeightPair[], threshold: number): string {\n\tif (pks.length > MAX_SIGNER_IN_MULTISIG) {\n\t\tthrow new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n\t}\n\t// max length = 1 flag byte + (max pk size + max weight size (u8)) * max signer size + 2 threshold bytes (u16)\n\tlet maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;\n\tlet tmp = new Uint8Array(maxLength);\n\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\n\tlet arr = to_uint8array(threshold);\n\ttmp.set(arr, 1);\n\tlet i = 3;\n\tfor (const pk of pks) {\n\t\ttmp.set([pk.pubKey.flag()], i);\n\t\ttmp.set(pk.pubKey.toBytes(), i + 1);\n\t\ttmp.set([pk.weight], i + 1 + pk.pubKey.toBytes().length);\n\t\ti += pk.pubKey.toBytes().length + 2;\n\t}\n\treturn normalizeSuiAddress(bytesToHex(blake2b(tmp.slice(0, i), { dkLen: 32 })));\n}\n\n/// Combine a list of serialized sigs, a list of pk weight pairs\n/// and threshold into a single multisig. `sigs` are required to\n/// be in the same order as `pks`. e.g. for [pk1, pk2, pk3, pk4, pk5],\n/// [sig1, sig2, sig5] is valid, but [sig2, sig1, sig5] is invalid.\nexport function combinePartialSigs(\n\tsigs: SerializedSignature[],\n\tpks: PubkeyWeightPair[],\n\tthreshold: number,\n): SerializedSignature {\n\tlet multisig_pk: MultiSigPublicKey = {\n\t\tpk_map: pks.map((x) => toPkWeightPair(x)),\n\t\tthreshold: threshold,\n\t};\n\n\tlet bitmap = 0;\n\tlet compressed_sigs: CompressedSignature[] = new Array(sigs.length);\n\tfor (let i = 0; i < sigs.length; i++) {\n\t\tlet parsed = toSingleSignaturePubkeyPair(sigs[i]);\n\t\tlet bytes = Array.from(parsed.signature.map((x) => Number(x)));\n\t\tif (parsed.signatureScheme === 'ED25519') {\n\t\t\tcompressed_sigs[i] = { ED25519: bytes };\n\t\t} else if (parsed.signatureScheme === 'Secp256k1') {\n\t\t\tcompressed_sigs[i] = { Secp256k1: bytes };\n\t\t} else if (parsed.signatureScheme === 'Secp256r1') {\n\t\t\tcompressed_sigs[i] = { Secp256r1: bytes };\n\t\t}\n\t\tfor (let j = 0; j < pks.length; j++) {\n\t\t\tif (parsed.pubKey.equals(pks[j].pubKey)) {\n\t\t\t\tbitmap |= 1 << j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tlet multisig: MultiSig = {\n\t\tsigs: compressed_sigs,\n\t\tbitmap,\n\t\tmultisig_pk,\n\t};\n\n\tconst bytes = builder.ser('MultiSig', multisig).toBytes();\n\tlet tmp = new Uint8Array(bytes.length + 1);\n\ttmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\ttmp.set(bytes, 1);\n\treturn toB64(tmp);\n}\n\n/// Decode a multisig signature into a list of signatures, public keys and flags.\nexport function decodeMultiSig(signature: string): SignaturePubkeyPair[] {\n\tconst parsed = fromB64(signature);\n\tif (parsed.length < 1 || parsed[0] !== SIGNATURE_SCHEME_TO_FLAG['MultiSig']) {\n\t\tthrow new Error('Invalid MultiSig flag');\n\t}\n\tconst multisig: MultiSig = builder.de('MultiSig', parsed.slice(1));\n\tlet res: SignaturePubkeyPair[] = new Array(multisig.sigs.length);\n\tfor (let i = 0; i < multisig.sigs.length; i++) {\n\t\tlet s: CompressedSignature = multisig.sigs[i];\n\t\tlet pk_index = as_indices(multisig.bitmap).at(i);\n\t\tlet pk_bytes = Object.values(multisig.multisig_pk.pk_map[pk_index as number].pubKey)[0];\n\t\tconst scheme = Object.keys(s)[0] as SignatureScheme;\n\n\t\tif (scheme === 'MultiSig') {\n\t\t\tthrow new Error('MultiSig is not supported inside MultiSig');\n\t\t}\n\n\t\tconst SIGNATURE_SCHEME_TO_PUBLIC_KEY = {\n\t\t\tED25519: Ed25519PublicKey,\n\t\t\tSecp256k1: Secp256k1PublicKey,\n\t\t\tSecp256r1: Secp256r1PublicKey,\n\t\t};\n\n\t\tconst PublicKey = SIGNATURE_SCHEME_TO_PUBLIC_KEY[scheme];\n\n\t\tres[i] = {\n\t\t\tsignatureScheme: scheme,\n\t\t\tsignature: Uint8Array.from(Object.values(s)[0]),\n\t\t\tpubKey: new PublicKey(pk_bytes),\n\t\t};\n\t}\n\treturn res;\n}\n\nfunction toPkWeightPair(pair: PubkeyWeightPair): PubkeyEnumWeightPair {\n\tlet pk_bytes = Array.from(pair.pubKey.toBytes().map((x) => Number(x)));\n\tswitch (pair.pubKey.flag()) {\n\t\tcase SIGNATURE_SCHEME_TO_FLAG['Secp256k1']:\n\t\t\treturn {\n\t\t\t\tpubKey: {\n\t\t\t\t\tSecp256k1: pk_bytes,\n\t\t\t\t},\n\t\t\t\tweight: pair.weight,\n\t\t\t};\n\t\tcase SIGNATURE_SCHEME_TO_FLAG['Secp256r1']:\n\t\t\treturn {\n\t\t\t\tpubKey: {\n\t\t\t\t\tSecp256r1: pk_bytes,\n\t\t\t\t},\n\t\t\t\tweight: pair.weight,\n\t\t\t};\n\t\tcase SIGNATURE_SCHEME_TO_FLAG['ED25519']:\n\t\t\treturn {\n\t\t\t\tpubKey: {\n\t\t\t\t\tED25519: pk_bytes,\n\t\t\t\t},\n\t\t\t\tweight: pair.weight,\n\t\t\t};\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported signature scheme');\n\t}\n}\n\n/// Convert u16 to Uint8Array of length 2 in little endian.\nfunction to_uint8array(threshold: number): Uint8Array {\n\tif (threshold < 0 || threshold > 65535) {\n\t\tthrow new Error('Invalid threshold');\n\t}\n\tlet arr = new Uint8Array(2);\n\tarr[0] = threshold & 0xff;\n\tarr[1] = threshold >> 8;\n\treturn arr;\n}\n\nfunction as_indices(bitmap: number): Uint8Array {\n\tif (bitmap < 0 || bitmap > 1024) {\n\t\tthrow new Error('Invalid bitmap');\n\t}\n\tlet res: number[] = [];\n\tfor (let i = 0; i < 10; i++) {\n\t\tif ((bitmap & (1 << i)) !== 0) {\n\t\t\tres.push(i);\n\t\t}\n\t}\n\treturn Uint8Array.from(res);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}