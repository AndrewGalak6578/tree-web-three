{"ast":null,"code":"import { splitGenericParameters } from \"@mysten/bcs\";\nimport { normalizeSuiAddress } from \"../../types/index.js\";\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\nclass TypeTagSerializer {\n  static parseFromStr(str) {\n    let normalizeAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (str === \"address\") {\n      return {\n        address: null\n      };\n    } else if (str === \"bool\") {\n      return {\n        bool: null\n      };\n    } else if (str === \"u8\") {\n      return {\n        u8: null\n      };\n    } else if (str === \"u16\") {\n      return {\n        u16: null\n      };\n    } else if (str === \"u32\") {\n      return {\n        u32: null\n      };\n    } else if (str === \"u64\") {\n      return {\n        u64: null\n      };\n    } else if (str === \"u128\") {\n      return {\n        u128: null\n      };\n    } else if (str === \"u256\") {\n      return {\n        u256: null\n      };\n    } else if (str === \"signer\") {\n      return {\n        signer: null\n      };\n    }\n    const vectorMatch = str.match(VECTOR_REGEX);\n    if (vectorMatch) {\n      return {\n        vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)\n      };\n    }\n    const structMatch = str.match(STRUCT_REGEX);\n    if (structMatch) {\n      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n      return {\n        struct: {\n          address,\n          module: structMatch[2],\n          name: structMatch[3],\n          typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)\n        }\n      };\n    }\n    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);\n  }\n  static parseStructTypeArgs(str) {\n    let normalizeAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    return splitGenericParameters(str).map(tok => TypeTagSerializer.parseFromStr(tok, normalizeAddress));\n  }\n  static tagToString(tag) {\n    if (\"bool\" in tag) {\n      return \"bool\";\n    }\n    if (\"u8\" in tag) {\n      return \"u8\";\n    }\n    if (\"u16\" in tag) {\n      return \"u16\";\n    }\n    if (\"u32\" in tag) {\n      return \"u32\";\n    }\n    if (\"u64\" in tag) {\n      return \"u64\";\n    }\n    if (\"u128\" in tag) {\n      return \"u128\";\n    }\n    if (\"u256\" in tag) {\n      return \"u256\";\n    }\n    if (\"address\" in tag) {\n      return \"address\";\n    }\n    if (\"signer\" in tag) {\n      return \"signer\";\n    }\n    if (\"vector\" in tag) {\n      return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n    }\n    if (\"struct\" in tag) {\n      const struct = tag.struct;\n      const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(\", \");\n      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : \"\"}`;\n    }\n    throw new Error(\"Invalid TypeTag\");\n  }\n}\nexport { TypeTagSerializer };","map":{"version":3,"names":["splitGenericParameters","normalizeSuiAddress","VECTOR_REGEX","STRUCT_REGEX","TypeTagSerializer","parseFromStr","str","normalizeAddress","arguments","length","undefined","address","bool","u8","u16","u32","u64","u128","u256","signer","vectorMatch","match","vector","structMatch","struct","module","name","typeParams","parseStructTypeArgs","Error","map","tok","tagToString","tag","join"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/signers/txn-data-serializers/type-tag-serializer.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { splitGenericParameters } from '@mysten/bcs';\nimport type { TypeTag } from '../../types/index.js';\nimport { normalizeSuiAddress } from '../../types/index.js';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n\tstatic parseFromStr(str: string, normalizeAddress = false): TypeTag {\n\t\tif (str === 'address') {\n\t\t\treturn { address: null };\n\t\t} else if (str === 'bool') {\n\t\t\treturn { bool: null };\n\t\t} else if (str === 'u8') {\n\t\t\treturn { u8: null };\n\t\t} else if (str === 'u16') {\n\t\t\treturn { u16: null };\n\t\t} else if (str === 'u32') {\n\t\t\treturn { u32: null };\n\t\t} else if (str === 'u64') {\n\t\t\treturn { u64: null };\n\t\t} else if (str === 'u128') {\n\t\t\treturn { u128: null };\n\t\t} else if (str === 'u256') {\n\t\t\treturn { u256: null };\n\t\t} else if (str === 'signer') {\n\t\t\treturn { signer: null };\n\t\t}\n\t\tconst vectorMatch = str.match(VECTOR_REGEX);\n\t\tif (vectorMatch) {\n\t\t\treturn {\n\t\t\t\tvector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress),\n\t\t\t};\n\t\t}\n\n\t\tconst structMatch = str.match(STRUCT_REGEX);\n\t\tif (structMatch) {\n\t\t\tconst address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n\t\t\treturn {\n\t\t\t\tstruct: {\n\t\t\t\t\taddress,\n\t\t\t\t\tmodule: structMatch[2],\n\t\t\t\t\tname: structMatch[3],\n\t\t\t\t\ttypeParams:\n\t\t\t\t\t\tstructMatch[5] === undefined\n\t\t\t\t\t\t\t? []\n\t\t\t\t\t\t\t: TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress),\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tthrow new Error(`Encountered unexpected token when parsing type args for ${str}`);\n\t}\n\n\tstatic parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n\t\treturn splitGenericParameters(str).map((tok) =>\n\t\t\tTypeTagSerializer.parseFromStr(tok, normalizeAddress),\n\t\t);\n\t}\n\n\tstatic tagToString(tag: TypeTag): string {\n\t\tif ('bool' in tag) {\n\t\t\treturn 'bool';\n\t\t}\n\t\tif ('u8' in tag) {\n\t\t\treturn 'u8';\n\t\t}\n\t\tif ('u16' in tag) {\n\t\t\treturn 'u16';\n\t\t}\n\t\tif ('u32' in tag) {\n\t\t\treturn 'u32';\n\t\t}\n\t\tif ('u64' in tag) {\n\t\t\treturn 'u64';\n\t\t}\n\t\tif ('u128' in tag) {\n\t\t\treturn 'u128';\n\t\t}\n\t\tif ('u256' in tag) {\n\t\t\treturn 'u256';\n\t\t}\n\t\tif ('address' in tag) {\n\t\t\treturn 'address';\n\t\t}\n\t\tif ('signer' in tag) {\n\t\t\treturn 'signer';\n\t\t}\n\t\tif ('vector' in tag) {\n\t\t\treturn `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n\t\t}\n\t\tif ('struct' in tag) {\n\t\t\tconst struct = tag.struct;\n\t\t\tconst typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(', ');\n\t\t\treturn `${struct.address}::${struct.module}::${struct.name}${\n\t\t\t\ttypeParams ? `<${typeParams}>` : ''\n\t\t\t}`;\n\t\t}\n\t\tthrow new Error('Invalid TypeTag');\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}