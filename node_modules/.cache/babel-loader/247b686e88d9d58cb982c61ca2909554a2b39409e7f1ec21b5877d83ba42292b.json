{"ast":null,"code":"// src/b64.ts\nfunction b64ToUint6(nChr) {\n  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;\n}\nfunction fromB64(sBase64, nBlocksSize) {\n  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, \"\"),\n    nInLen = sB64Enc.length,\n    nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2,\n    taBytes = new Uint8Array(nOutLen);\n  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n    nMod4 = nInIdx & 3;\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n      }\n      nUint24 = 0;\n    }\n  }\n  return taBytes;\n}\nfunction uint6ToB64(nUint6) {\n  return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;\n}\nfunction toB64(aBytes) {\n  var nMod3 = 2,\n    sB64Enc = \"\";\n  for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n    nMod3 = nIdx % 3;\n    if (nIdx > 0 && nIdx * 4 / 3 % 76 === 0) {\n      sB64Enc += \"\";\n    }\n    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);\n    if (nMod3 === 2 || aBytes.length - nIdx === 1) {\n      sB64Enc += String.fromCodePoint(uint6ToB64(nUint24 >>> 18 & 63), uint6ToB64(nUint24 >>> 12 & 63), uint6ToB64(nUint24 >>> 6 & 63), uint6ToB64(nUint24 & 63));\n      nUint24 = 0;\n    }\n  }\n  return sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? \"\" : nMod3 === 1 ? \"=\" : \"==\");\n}\n\n// src/hex.ts\nfunction fromHEX(hexStr) {\n  let intArr = hexStr.replace(\"0x\", \"\").match(/.{1,2}/g).map(byte => parseInt(byte, 16));\n  if (intArr === null) {\n    throw new Error(`Unable to parse HEX: ${hexStr}`);\n  }\n  return Uint8Array.from(intArr);\n}\nfunction toHEX(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\n\n// src/index.ts\nimport bs58 from \"bs58\";\nvar SUI_ADDRESS_LENGTH = 32;\nfunction toLittleEndian(bigint, size) {\n  let result = new Uint8Array(size);\n  let i = 0;\n  while (bigint > 0) {\n    result[i] = Number(bigint % BigInt(256));\n    bigint = bigint / BigInt(256);\n    i += 1;\n  }\n  return result;\n}\nvar toB58 = buffer => bs58.encode(buffer);\nvar fromB58 = str => bs58.decode(str);\nvar BcsReader = class {\n  /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */\n  constructor(data) {\n    this.bytePosition = 0;\n    this.dataView = new DataView(data.buffer);\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */\n  read8() {\n    let value = this.dataView.getUint8(this.bytePosition);\n    this.shift(1);\n    return value;\n  }\n  /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */\n  read16() {\n    let value = this.dataView.getUint16(this.bytePosition, true);\n    this.shift(2);\n    return value;\n  }\n  /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */\n  read32() {\n    let value = this.dataView.getUint32(this.bytePosition, true);\n    this.shift(4);\n    return value;\n  }\n  /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */\n  read64() {\n    let value1 = this.read32();\n    let value2 = this.read32();\n    let result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */\n  read128() {\n    let value1 = BigInt(this.read64());\n    let value2 = BigInt(this.read64());\n    let result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */\n  read256() {\n    let value1 = BigInt(this.read128());\n    let value2 = BigInt(this.read128());\n    let result = value2.toString(16) + value1.toString(16).padStart(32, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */\n  readBytes(num) {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let value = new Uint8Array(this.dataView.buffer, start, num);\n    this.shift(num);\n    return value;\n  }\n  /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */\n  readULEB() {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let buffer = new Uint8Array(this.dataView.buffer, start);\n    let {\n      value,\n      length\n    } = ulebDecode(buffer);\n    this.shift(length);\n    return value;\n  }\n  /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */\n  readVec(cb) {\n    let length = this.readULEB();\n    let result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(cb(this, i, length));\n    }\n    return result;\n  }\n};\nvar BcsWriter = class {\n  constructor() {\n    let {\n      size = 1024,\n      maxSize,\n      allocateSize = 1024\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.bytePosition = 0;\n    this.size = size;\n    this.maxSize = maxSize || size;\n    this.allocateSize = allocateSize;\n    this.dataView = new DataView(new ArrayBuffer(size));\n  }\n  ensureSizeOrGrow(bytes) {\n    const requiredSize = this.bytePosition + bytes;\n    if (requiredSize > this.size) {\n      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n      if (requiredSize > nextSize) {\n        throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`);\n      }\n      this.size = nextSize;\n      const nextBuffer = new ArrayBuffer(this.size);\n      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n      this.dataView = new DataView(nextBuffer);\n    }\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write8(value) {\n    this.ensureSizeOrGrow(1);\n    this.dataView.setUint8(this.bytePosition, Number(value));\n    return this.shift(1);\n  }\n  /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write16(value) {\n    this.ensureSizeOrGrow(2);\n    this.dataView.setUint16(this.bytePosition, Number(value), true);\n    return this.shift(2);\n  }\n  /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write32(value) {\n    this.ensureSizeOrGrow(4);\n    this.dataView.setUint32(this.bytePosition, Number(value), true);\n    return this.shift(4);\n  }\n  /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write64(value) {\n    toLittleEndian(BigInt(value), 8).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write128(value) {\n    toLittleEndian(BigInt(value), 16).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write256(value) {\n    toLittleEndian(BigInt(value), 32).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeULEB(value) {\n    ulebEncode(value).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */\n  writeVec(vector, cb) {\n    this.writeULEB(vector.length);\n    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n    return this;\n  }\n  /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.bytePosition; i++) {\n      yield this.dataView.getUint8(i);\n    }\n    return this.toBytes();\n  }\n  /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */\n  toBytes() {\n    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n  }\n  /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */\n  toString(encoding) {\n    return encodeStr(this.toBytes(), encoding);\n  }\n};\nfunction ulebEncode(num) {\n  let arr = [];\n  let len = 0;\n  if (num === 0) {\n    return [0];\n  }\n  while (num > 0) {\n    arr[len] = num & 127;\n    if (num >>= 7) {\n      arr[len] |= 128;\n    }\n    len += 1;\n  }\n  return arr;\n}\nfunction ulebDecode(arr) {\n  let total = 0;\n  let shift = 0;\n  let len = 0;\n  while (true) {\n    let byte = arr[len];\n    len += 1;\n    total |= (byte & 127) << shift;\n    if ((byte & 128) === 0) {\n      break;\n    }\n    shift += 7;\n  }\n  return {\n    value: total,\n    length: len\n  };\n}\nvar _BCS = class {\n  /**\n   * Construct a BCS instance with a prepared schema.\n   *\n   * @param schema A prepared schema with type definitions\n   * @param withPrimitives Whether to register primitive types by default\n   */\n  constructor(schema) {\n    /**\n     * Map of kind `TypeName => TypeInterface`. Holds all\n     * callbacks for (de)serialization of every registered type.\n     *\n     * If the value stored is a string, it is treated as an alias.\n     */\n    this.types = /* @__PURE__ */new Map();\n    /**\n     * Count temp keys to generate a new one when requested.\n     */\n    this.counter = 0;\n    if (schema instanceof _BCS) {\n      this.schema = schema.schema;\n      this.types = new Map(schema.types);\n      return;\n    }\n    this.schema = schema;\n    this.registerAddressType(_BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n    this.registerVectorType(schema.vectorType);\n    if (schema.types && schema.types.structs) {\n      for (let name of Object.keys(schema.types.structs)) {\n        this.registerStructType(name, schema.types.structs[name]);\n      }\n    }\n    if (schema.types && schema.types.enums) {\n      for (let name of Object.keys(schema.types.enums)) {\n        this.registerEnumType(name, schema.types.enums[name]);\n      }\n    }\n    if (schema.types && schema.types.aliases) {\n      for (let name of Object.keys(schema.types.aliases)) {\n        this.registerAlias(name, schema.types.aliases[name]);\n      }\n    }\n    if (schema.withPrimitives !== false) {\n      registerPrimitives(this);\n    }\n  }\n  /**\n   * Name of the key to use for temporary struct definitions.\n   * Returns a temp key + index (for a case when multiple temp\n   * structs are processed).\n   */\n  tempKey() {\n    return `bcs-struct-${++this.counter}`;\n  }\n  /**\n   * Serialize data into bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<u8>', 'u8');\n   *\n   * let serialized = BCS\n   *   .set('vector<u8>', [1,2,3,4,5,6])\n   *   .toBytes();\n   *\n   * console.assert(toHex(serialized) === '06010203040506');\n   *\n   * @param type Name of the type to serialize (must be registered) or a struct type.\n   * @param data Data to serialize.\n   * @param size Serialization buffer size. Default 1024 = 1KB.\n   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n   */\n  ser(type, data, options) {\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const {\n        name,\n        params\n      } = this.parseTypeName(type);\n      return this.getTypeInterface(name).encode(this, data, options, params);\n    }\n    if (typeof type === \"object\") {\n      const key = this.tempKey();\n      const temp = new _BCS(this);\n      return temp.registerStructType(key, type).ser(key, data, options);\n    }\n    throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Deserialize BCS into a JS type.\n   *\n   * @example\n   * let num = bcs.ser('u64', '4294967295').toString('hex');\n   * let deNum = bcs.de('u64', num, 'hex');\n   * console.assert(deNum.toString(10) === '4294967295');\n   *\n   * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n   * @param data Data to deserialize.\n   * @param encoding Optional - encoding to use if data is of type String\n   * @return Deserialized data.\n   */\n  de(type, data, encoding) {\n    if (typeof data === \"string\") {\n      if (encoding) {\n        data = decodeStr(data, encoding);\n      } else {\n        throw new Error(\"To pass a string to `bcs.de`, specify encoding\");\n      }\n    }\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const {\n        name,\n        params\n      } = this.parseTypeName(type);\n      return this.getTypeInterface(name).decode(this, data, params);\n    }\n    if (typeof type === \"object\") {\n      const temp = new _BCS(this);\n      const key = this.tempKey();\n      return temp.registerStructType(key, type).de(key, data, encoding);\n    }\n    throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Check whether a `TypeInterface` has been loaded for a `type`.\n   * @param type Name of the type to check.\n   * @returns\n   */\n  hasType(type) {\n    return this.types.has(type);\n  }\n  /**\n   * Create an alias for a type.\n   * WARNING: this can potentially lead to recursion\n   * @param name Alias to use\n   * @param forType Type to reference\n   * @returns\n   *\n   * @example\n   * ```\n   * let bcs = new BCS(getSuiMoveConfig());\n   * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n   * ```\n   */\n  registerAlias(name, forType) {\n    this.types.set(name, forType);\n    return this;\n  }\n  /**\n   * Method to register new types for BCS internal representation.\n   * For each registered type 2 callbacks must be specified and one is optional:\n   *\n   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n   * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n   * - validateCb(data) - validate data - either return bool or throw an error\n   *\n   * @example\n   * // our type would be a string that consists only of numbers\n   * bcs.registerType('number_string',\n   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n   * );\n   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n   *\n   * @param name\n   * @param encodeCb Callback to encode a value.\n   * @param decodeCb Callback to decode a value.\n   * @param validateCb Optional validator Callback to check type before serialization.\n   */\n  registerType(typeName, encodeCb, decodeCb) {\n    let validateCb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => true;\n    const {\n      name,\n      params: generics\n    } = this.parseTypeName(typeName);\n    this.types.set(name, {\n      encode(self, data, options, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, {\n            [value]: typeParams[index]\n          });\n        }, {});\n        return this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n      },\n      decode(self, data, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, {\n            [value]: typeParams[index]\n          });\n        }, {});\n        return this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n      },\n      // these methods should always be used with caution as they require pre-defined\n      // reader and writer and mainly exist to allow multi-field (de)serialization;\n      _encodeRaw(writer, data, typeParams, typeMap) {\n        if (validateCb(data)) {\n          return encodeCb.call(this, writer, data, typeParams, typeMap);\n        } else {\n          throw new Error(`Validation failed for type ${name}, data: ${data}`);\n        }\n      },\n      _decodeRaw(reader, typeParams, typeMap) {\n        return decodeCb.call(this, reader, typeParams, typeMap);\n      }\n    });\n    return this;\n  }\n  /**\n   * Register an address type which is a sequence of U8s of specified length.\n   * @example\n   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n   *\n   * @param name Name of the address type.\n   * @param length Byte length of the address.\n   * @param encoding Encoding to use for the address type\n   * @returns\n   */\n  registerAddressType(name, length) {\n    let encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"hex\";\n    switch (encoding) {\n      case \"base64\":\n        return this.registerType(name, function encodeAddress(writer, data) {\n          return fromB64(data).reduce((writer2, el) => writer2.write8(el), writer);\n        }, function decodeAddress(reader) {\n          return toB64(reader.readBytes(length));\n        });\n      case \"hex\":\n        return this.registerType(name, function encodeAddress(writer, data) {\n          return fromHEX(data).reduce((writer2, el) => writer2.write8(el), writer);\n        }, function decodeAddress(reader) {\n          return toHEX(reader.readBytes(length));\n        });\n      default:\n        throw new Error(\"Unsupported encoding! Use either hex or base64\");\n    }\n  }\n  /**\n   * Register custom vector type inside the bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<T>'); // generic registration\n   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n   *\n   * @param name Name of the type to register\n   * @param elementType Optional name of the inner type of the vector\n   * @return Returns self for chaining.\n   */\n  registerVectorType(typeName) {\n    let {\n      name,\n      params\n    } = this.parseTypeName(typeName);\n    if (params.length > 1) {\n      throw new Error(\"Vector can have only one type parameter; got \" + name);\n    }\n    return this.registerType(typeName, function encodeVector(writer, data, typeParams, typeMap) {\n      return writer.writeVec(data, (writer2, el) => {\n        let elementType = typeParams[0];\n        if (!elementType) {\n          throw new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n        }\n        let {\n          name: name2,\n          params: params2\n        } = this.parseTypeName(elementType);\n        if (this.hasType(name2)) {\n          return this.getTypeInterface(name2)._encodeRaw.call(this, writer2, el, params2, typeMap);\n        }\n        if (!(name2 in typeMap)) {\n          throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);\n        }\n        let {\n          name: innerName,\n          params: innerParams\n        } = this.parseTypeName(typeMap[name2]);\n        return this.getTypeInterface(innerName)._encodeRaw.call(this, writer2, el, innerParams, typeMap);\n      });\n    }, function decodeVector(reader, typeParams, typeMap) {\n      return reader.readVec(reader2 => {\n        let elementType = typeParams[0];\n        if (!elementType) {\n          throw new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n        }\n        let {\n          name: name2,\n          params: params2\n        } = this.parseTypeName(elementType);\n        if (this.hasType(name2)) {\n          return this.getTypeInterface(name2)._decodeRaw.call(this, reader2, params2, typeMap);\n        }\n        if (!(name2 in typeMap)) {\n          throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);\n        }\n        let {\n          name: innerName,\n          params: innerParams\n        } = this.parseTypeName(typeMap[name2]);\n        return this.getTypeInterface(innerName)._decodeRaw.call(this, reader2, innerParams, typeMap);\n      });\n    });\n  }\n  /**\n   * Safe method to register a custom Move struct. The first argument is a name of the\n   * struct which is only used on the FrontEnd and has no affect on serialization results,\n   * and the second is a struct description passed as an Object.\n   *\n   * The description object MUST have the same order on all of the platforms (ie in Move\n   * or in Rust).\n   *\n   * @example\n   * // Move / Rust struct\n   * // struct Coin {\n   * //   value: u64,\n   * //   owner: vector<u8>, // name // Vec<u8> in Rust\n   * //   is_locked: bool,\n   * // }\n   *\n   * bcs.registerStructType('Coin', {\n   *   value: bcs.U64,\n   *   owner: bcs.STRING,\n   *   is_locked: bcs.BOOL\n   * });\n   *\n   * // Created in Rust with diem/bcs\n   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n   *  128, 209, 177,   5,  96,  0,  0,\n   *    0,  14,  66, 105, 103, 32, 87,\n   *   97, 108, 108, 101, 116, 32, 71,\n   *  117, 121,   0\n   * ];\n   *\n   * // Let's encode the value as well\n   * let test_set = bcs.ser('Coin', {\n   *   owner: 'Big Wallet Guy',\n   *   value: '412412400000',\n   *   is_locked: false,\n   * });\n   *\n   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n   *\n   * @param name Name of the type to register.\n   * @param fields Fields of the struct. Must be in the correct order.\n   * @return Returns BCS for chaining.\n   */\n  registerStructType(typeName, fields) {\n    for (let key in fields) {\n      let internalName = this.tempKey();\n      let value = fields[key];\n      if (!Array.isArray(value) && typeof value !== \"string\") {\n        fields[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(fields);\n    let canonicalOrder = Object.keys(struct);\n    let {\n      name: structName,\n      params: generics\n    } = this.parseTypeName(typeName);\n    return this.registerType(typeName, function encodeStruct(writer, data, typeParams, typeMap) {\n      if (!data || data.constructor !== Object) {\n        throw new Error(`Expected ${structName} to be an Object, got: ${data}`);\n      }\n      if (typeParams.length !== generics.length) {\n        throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);\n      }\n      for (let key of canonicalOrder) {\n        if (!(key in data)) {\n          throw new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n        }\n        const {\n          name: fieldType,\n          params: fieldParams\n        } = this.parseTypeName(struct[key]);\n        if (!generics.includes(fieldType)) {\n          this.getTypeInterface(fieldType)._encodeRaw.call(this, writer, data[key], fieldParams, typeMap);\n        } else {\n          const paramIdx = generics.indexOf(fieldType);\n          let {\n            name,\n            params\n          } = this.parseTypeName(typeParams[paramIdx]);\n          if (this.hasType(name)) {\n            this.getTypeInterface(name)._encodeRaw.call(this, writer, data[key], params, typeMap);\n            continue;\n          }\n          if (!(name in typeMap)) {\n            throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);\n          }\n          let {\n            name: innerName,\n            params: innerParams\n          } = this.parseTypeName(typeMap[name]);\n          this.getTypeInterface(innerName)._encodeRaw.call(this, writer, data[key], innerParams, typeMap);\n        }\n      }\n      return writer;\n    }, function decodeStruct(reader, typeParams, typeMap) {\n      if (typeParams.length !== generics.length) {\n        throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);\n      }\n      let result = {};\n      for (let key of canonicalOrder) {\n        const {\n          name: fieldName,\n          params: fieldParams\n        } = this.parseTypeName(struct[key]);\n        if (!generics.includes(fieldName)) {\n          result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(this, reader, fieldParams, typeMap);\n        } else {\n          const paramIdx = generics.indexOf(fieldName);\n          let {\n            name,\n            params\n          } = this.parseTypeName(typeParams[paramIdx]);\n          if (this.hasType(name)) {\n            result[key] = this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\n            continue;\n          }\n          if (!(name in typeMap)) {\n            throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);\n          }\n          let {\n            name: innerName,\n            params: innerParams\n          } = this.parseTypeName(typeMap[name]);\n          result[key] = this.getTypeInterface(innerName)._decodeRaw.call(this, reader, innerParams, typeMap);\n        }\n      }\n      return result;\n    });\n  }\n  /**\n   * Safe method to register custom enum type where each invariant holds the value of another type.\n   * @example\n   * bcs.registerStructType('Coin', { value: 'u64' });\n   * bcs.registerEnumType('MyEnum', {\n   *  single: 'Coin',\n   *  multi: 'vector<Coin>',\n   *  empty: null\n   * });\n   *\n   * console.log(\n   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n   * )\n   *\n   * // and serialization\n   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n   *\n   * @param name\n   * @param variants\n   */\n  registerEnumType(typeName, variants) {\n    for (let key in variants) {\n      let internalName = this.tempKey();\n      let value = variants[key];\n      if (value !== null && !Array.isArray(value) && typeof value !== \"string\") {\n        variants[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(variants);\n    let canonicalOrder = Object.keys(struct);\n    let {\n      name,\n      params: canonicalTypeParams\n    } = this.parseTypeName(typeName);\n    return this.registerType(typeName, function encodeEnum(writer, data, typeParams, typeMap) {\n      if (!data) {\n        throw new Error(`Unable to write enum \"${name}\", missing data.\nReceived: \"${data}\"`);\n      }\n      if (typeof data !== \"object\") {\n        throw new Error(`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\" | \")}\".\nReceived: \"${JSON.stringify(data)}\"`);\n      }\n      let key = Object.keys(data)[0];\n      if (key === void 0) {\n        throw new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n      }\n      let orderByte = canonicalOrder.indexOf(key);\n      if (orderByte === -1) {\n        throw new Error(`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\" | \")}\"; received \"${key}\"`);\n      }\n      let invariant = canonicalOrder[orderByte];\n      let invariantType = struct[invariant];\n      writer.write8(orderByte);\n      if (invariantType === null) {\n        return writer;\n      }\n      let paramIndex = canonicalTypeParams.indexOf(invariantType);\n      let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n      {\n        let {\n          name: name2,\n          params\n        } = this.parseTypeName(typeOrParam);\n        return this.getTypeInterface(name2)._encodeRaw.call(this, writer, data[key], params, typeMap);\n      }\n    }, function decodeEnum(reader, typeParams, typeMap) {\n      let orderByte = reader.readULEB();\n      let invariant = canonicalOrder[orderByte];\n      let invariantType = struct[invariant];\n      if (orderByte === -1) {\n        throw new Error(`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`);\n      }\n      if (invariantType === null) {\n        return {\n          [invariant]: true\n        };\n      }\n      let paramIndex = canonicalTypeParams.indexOf(invariantType);\n      let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n      {\n        let {\n          name: name2,\n          params\n        } = this.parseTypeName(typeOrParam);\n        return {\n          [invariant]: this.getTypeInterface(name2)._decodeRaw.call(this, reader, params, typeMap)\n        };\n      }\n    });\n  }\n  /**\n   * Get a set of encoders/decoders for specific type.\n   * Mainly used to define custom type de/serialization logic.\n   *\n   * @param type\n   * @returns {TypeInterface}\n   */\n  getTypeInterface(type) {\n    let typeInterface = this.types.get(type);\n    if (typeof typeInterface === \"string\") {\n      let chain = [];\n      while (typeof typeInterface === \"string\") {\n        if (chain.includes(typeInterface)) {\n          throw new Error(`Recursive definition found: ${chain.join(\" -> \")} -> ${typeInterface}`);\n        }\n        chain.push(typeInterface);\n        typeInterface = this.types.get(typeInterface);\n      }\n    }\n    if (typeInterface === void 0) {\n      throw new Error(`Type ${type} is not registered`);\n    }\n    return typeInterface;\n  }\n  /**\n   * Parse a type name and get the type's generics.\n   * @example\n   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n   * // typeName: Option\n   * // typeParams: [ 'Coin<SUI>' ]\n   *\n   * @param name Name of the type to process\n   * @returns Object with typeName and typeParams listed as Array\n   */\n  parseTypeName(name) {\n    if (Array.isArray(name)) {\n      let [typeName2, ...params2] = name;\n      return {\n        name: typeName2,\n        params: params2\n      };\n    }\n    if (typeof name !== \"string\") {\n      throw new Error(`Illegal type passed as a name of the type: ${name}`);\n    }\n    let [left, right] = this.schema.genericSeparators || [\"<\", \">\"];\n    let l_bound = name.indexOf(left);\n    let r_bound = Array.from(name).reverse().indexOf(right);\n    if (l_bound === -1 && r_bound === -1) {\n      return {\n        name,\n        params: []\n      };\n    }\n    if (l_bound === -1 || r_bound === -1) {\n      throw new Error(`Unclosed generic in name '${name}'`);\n    }\n    let typeName = name.slice(0, l_bound);\n    let params = name.slice(l_bound + 1, name.length - r_bound - 1).split(\",\").map(e => e.trim());\n    return {\n      name: typeName,\n      params\n    };\n  }\n};\nvar BCS = _BCS;\n// Prefefined types constants\nBCS.U8 = \"u8\";\nBCS.U16 = \"u16\";\nBCS.U32 = \"u32\";\nBCS.U64 = \"u64\";\nBCS.U128 = \"u128\";\nBCS.U256 = \"u256\";\nBCS.BOOL = \"bool\";\nBCS.VECTOR = \"vector\";\nBCS.ADDRESS = \"address\";\nBCS.STRING = \"string\";\nBCS.HEX = \"hex-string\";\nBCS.BASE58 = \"base58-string\";\nBCS.BASE64 = \"base64-string\";\nfunction encodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return toB58(data);\n    case \"base64\":\n      return toB64(data);\n    case \"hex\":\n      return toHEX(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction decodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return fromB58(data);\n    case \"base64\":\n      return fromB64(data);\n    case \"hex\":\n      return fromHEX(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction registerPrimitives(bcs) {\n  bcs.registerType(BCS.U8, function (writer, data) {\n    return writer.write8(data);\n  }, function (reader) {\n    return reader.read8();\n  }, u8 => u8 < 256);\n  bcs.registerType(BCS.U16, function (writer, data) {\n    return writer.write16(data);\n  }, function (reader) {\n    return reader.read16();\n  }, u16 => u16 < 65536);\n  bcs.registerType(BCS.U32, function (writer, data) {\n    return writer.write32(data);\n  }, function (reader) {\n    return reader.read32();\n  }, u32 => u32 <= 4294967296n);\n  bcs.registerType(BCS.U64, function (writer, data) {\n    return writer.write64(data);\n  }, function (reader) {\n    return reader.read64();\n  });\n  bcs.registerType(BCS.U128, function (writer, data) {\n    return writer.write128(data);\n  }, function (reader) {\n    return reader.read128();\n  });\n  bcs.registerType(BCS.U256, function (writer, data) {\n    return writer.write256(data);\n  }, function (reader) {\n    return reader.read256();\n  });\n  bcs.registerType(BCS.BOOL, function (writer, data) {\n    return writer.write8(data);\n  }, function (reader) {\n    return reader.read8().toString(10) === \"1\";\n  });\n  bcs.registerType(BCS.STRING, function (writer, data) {\n    return writer.writeVec(Array.from(data), (writer2, el) => writer2.write8(el.charCodeAt(0)));\n  }, function (reader) {\n    return reader.readVec(reader2 => reader2.read8()).map(el => String.fromCharCode(Number(el))).join(\"\");\n  }, _str => true);\n  bcs.registerType(BCS.HEX, function (writer, data) {\n    return writer.writeVec(Array.from(fromHEX(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toHEX(new Uint8Array(bytes));\n  });\n  bcs.registerType(BCS.BASE58, function (writer, data) {\n    return writer.writeVec(Array.from(fromB58(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toB58(new Uint8Array(bytes));\n  });\n  bcs.registerType(BCS.BASE64, function (writer, data) {\n    return writer.writeVec(Array.from(fromB64(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toB64(new Uint8Array(bytes));\n  });\n}\nfunction getRustConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"Vec\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\nfunction getSuiMoveConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"vector\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\nexport { BCS, BcsReader, BcsWriter, decodeStr, encodeStr, fromB58, fromB64, fromHEX, getRustConfig, getSuiMoveConfig, registerPrimitives, toB58, toB64, toHEX };","map":{"version":3,"names":["b64ToUint6","nChr","fromB64","sBase64","nBlocksSize","sB64Enc","replace","nInLen","length","nOutLen","Math","ceil","taBytes","Uint8Array","nMod3","nMod4","nUint24","nOutIdx","nInIdx","charCodeAt","uint6ToB64","nUint6","toB64","aBytes","nLen","nIdx","String","fromCodePoint","slice","fromHEX","hexStr","intArr","match","map","byte","parseInt","Error","from","toHEX","bytes","reduce","str","toString","padStart","bs58","SUI_ADDRESS_LENGTH","toLittleEndian","bigint","size","result","i","Number","BigInt","toB58","buffer","encode","fromB58","decode","BcsReader","constructor","data","bytePosition","dataView","DataView","shift","read8","value","getUint8","read16","getUint16","read32","getUint32","read64","value1","value2","read128","read256","readBytes","num","start","byteOffset","readULEB","ulebDecode","readVec","cb","push","BcsWriter","maxSize","allocateSize","arguments","undefined","ArrayBuffer","ensureSizeOrGrow","requiredSize","nextSize","min","nextBuffer","set","write8","setUint8","write16","setUint16","write32","setUint32","write64","forEach","el","write128","write256","writeULEB","ulebEncode","writeVec","vector","Array","Symbol","iterator","toBytes","encoding","encodeStr","arr","len","total","_BCS","schema","types","Map","counter","registerAddressType","ADDRESS","addressLength","addressEncoding","registerVectorType","vectorType","structs","name","Object","keys","registerStructType","enums","registerEnumType","aliases","registerAlias","withPrimitives","registerPrimitives","tempKey","ser","type","options","isArray","params","parseTypeName","getTypeInterface","key","temp","JSON","stringify","de","decodeStr","hasType","has","forType","registerType","typeName","encodeCb","decodeCb","validateCb","generics","self","typeParams","typeMap","acc","index","assign","_encodeRaw","call","_decodeRaw","writer","reader","encodeAddress","writer2","decodeAddress","encodeVector","elementType","name2","params2","innerName","innerParams","decodeVector","reader2","fields","internalName","struct","freeze","canonicalOrder","structName","encodeStruct","fieldType","fieldParams","includes","paramIdx","indexOf","decodeStruct","fieldName","variants","canonicalTypeParams","encodeEnum","join","orderByte","invariant","invariantType","paramIndex","typeOrParam","decodeEnum","typeInterface","get","chain","typeName2","left","right","genericSeparators","l_bound","r_bound","reverse","split","e","trim","BCS","U8","U16","U32","U64","U128","U256","BOOL","VECTOR","STRING","HEX","BASE58","BASE64","bcs","u8","u16","u32","fromCharCode","_str","getRustConfig","getSuiMoveConfig"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/src/b64.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/src/hex.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@suiet/wallet-kit/node_modules/@mysten/bcs/src/index.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/*\\\n|*|  Base64 / binary data / UTF-8 strings utilities\n|*|  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding\n\\*/\n\n/* Array of bytes to Base64 string decoding */\n\nfunction b64ToUint6(nChr: number) {\n  return nChr > 64 && nChr < 91\n    ? nChr - 65\n    : nChr > 96 && nChr < 123\n    ? nChr - 71\n    : nChr > 47 && nChr < 58\n    ? nChr + 4\n    : nChr === 43\n    ? 62\n    : nChr === 47\n    ? 63\n    : 0;\n}\n\nexport function fromB64(sBase64: string, nBlocksSize?: number): Uint8Array {\n  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ''),\n    nInLen = sB64Enc.length,\n    nOutLen = nBlocksSize\n      ? Math.ceil(((nInLen * 3 + 1) >> 2) / nBlocksSize) * nBlocksSize\n      : (nInLen * 3 + 1) >> 2,\n    taBytes = new Uint8Array(nOutLen);\n\n  for (\n    var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0;\n    nInIdx < nInLen;\n    nInIdx++\n  ) {\n    nMod4 = nInIdx & 3;\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << (6 * (3 - nMod4));\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n        taBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;\n      }\n      nUint24 = 0;\n    }\n  }\n\n  return taBytes;\n}\n\n/* Base64 string to array encoding */\n\nfunction uint6ToB64(nUint6: number) {\n  return nUint6 < 26\n    ? nUint6 + 65\n    : nUint6 < 52\n    ? nUint6 + 71\n    : nUint6 < 62\n    ? nUint6 - 4\n    : nUint6 === 62\n    ? 43\n    : nUint6 === 63\n    ? 47\n    : 65;\n}\n\nexport function toB64(aBytes: Uint8Array): string {\n  var nMod3 = 2,\n    sB64Enc = '';\n\n  for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n    nMod3 = nIdx % 3;\n    if (nIdx > 0 && ((nIdx * 4) / 3) % 76 === 0) {\n      sB64Enc += '';\n    }\n    nUint24 |= aBytes[nIdx] << ((16 >>> nMod3) & 24);\n    if (nMod3 === 2 || aBytes.length - nIdx === 1) {\n      sB64Enc += String.fromCodePoint(\n        uint6ToB64((nUint24 >>> 18) & 63),\n        uint6ToB64((nUint24 >>> 12) & 63),\n        uint6ToB64((nUint24 >>> 6) & 63),\n        uint6ToB64(nUint24 & 63)\n      );\n      nUint24 = 0;\n    }\n  }\n\n  return (\n    sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) +\n    (nMod3 === 2 ? '' : nMod3 === 1 ? '=' : '==')\n  );\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHEX(hexStr: string): Uint8Array {\n  // @ts-ignore\n  let intArr = hexStr\n    .replace('0x', '')\n    .match(/.{1,2}/g)\n    .map(byte => parseInt(byte, 16));\n\n  if (intArr === null) {\n    throw new Error(`Unable to parse HEX: ${hexStr}`);\n  }\n\n  return Uint8Array.from(intArr);\n}\n\nexport function toHEX(bytes: Uint8Array): string {\n  return bytes.reduce(\n    (str, byte) => str + byte.toString(16).padStart(2, '0'),\n    ''\n  );\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n * BCS implementation {@see https://github.com/diem/bcs } for JavaScript.\n * Intended to be used for Move applications; supports both NodeJS and browser.\n *\n * For more details and examples {@see README.md }.\n *\n * @module bcs\n * @property {BcsReader}\n */\n\nimport { toB64, fromB64 } from \"./b64\";\nimport { toHEX, fromHEX } from \"./hex\";\nimport bs58 from \"bs58\";\n\nconst SUI_ADDRESS_LENGTH = 32;\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n  let result = new Uint8Array(size);\n  let i = 0;\n  while (bigint > 0) {\n    result[i] = Number(bigint % BigInt(256));\n    bigint = bigint / BigInt(256);\n    i += 1;\n  }\n  return result;\n}\n\nconst toB58 = (buffer: Uint8Array) => bs58.encode(buffer);\nconst fromB58 = (str: string) => bs58.decode(str);\n\n// Re-export all encoding dependencies.\nexport { toB58, fromB58, toB64, fromB64, fromHEX, toHEX };\n\n/**\n * Supported encodings.\n * Used in `Reader.toString()` as well as in `decodeStr` and `encodeStr` functions.\n */\nexport type Encoding = \"base58\" | \"base64\" | \"hex\";\n\n/**\n * Allows for array definitions for names.\n * @example\n * ```\n * bcs.registerStructType(['vector', BCS.STRING], ...);\n * // equals\n * bcs.registerStructType('vector<string>', ...);\n * ```\n */\nexport type TypeName = string | [string, ...(TypeName | string)[]];\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n  private dataView: DataView;\n  private bytePosition: number = 0;\n\n  /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */\n  constructor(data: Uint8Array) {\n    this.dataView = new DataView(data.buffer);\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes: number) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */\n  read8(): number {\n    let value = this.dataView.getUint8(this.bytePosition);\n    this.shift(1);\n    return value;\n  }\n  /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */\n  read16(): number {\n    let value = this.dataView.getUint16(this.bytePosition, true);\n    this.shift(2);\n    return value;\n  }\n  /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */\n  read32(): number {\n    let value = this.dataView.getUint32(this.bytePosition, true);\n    this.shift(4);\n    return value;\n  }\n  /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */\n  read64(): string {\n    let value1 = this.read32();\n    let value2 = this.read32();\n\n    let result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */\n  read128(): string {\n    let value1 = BigInt(this.read64());\n    let value2 = BigInt(this.read64());\n    let result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */\n  read256(): string {\n    let value1 = BigInt(this.read128());\n    let value2 = BigInt(this.read128());\n    let result = value2.toString(16) + value1.toString(16).padStart(32, \"0\");\n\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */\n  readBytes(num: number): Uint8Array {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let value = new Uint8Array(this.dataView.buffer, start, num);\n\n    this.shift(num);\n\n    return value;\n  }\n  /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */\n  readULEB(): number {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let buffer = new Uint8Array(this.dataView.buffer, start);\n    let { value, length } = ulebDecode(buffer);\n\n    this.shift(length);\n\n    return value;\n  }\n  /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */\n  readVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n    let length = this.readULEB();\n    let result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(cb(this, i, length));\n    }\n    return result;\n  }\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\ninterface BcsWriterOptions {\n  /** The initial size (in bytes) of the buffer tht will be allocated */\n  size?: number;\n  /** The maximum size (in bytes) that the buffer is allowed to grow to */\n  maxSize?: number;\n  /** The amount of bytes that will be allocated whenever additional memory is required */\n  allocateSize?: number;\n}\n\nexport class BcsWriter {\n  private dataView: DataView;\n  private bytePosition: number = 0;\n  private size: number;\n  private maxSize: number;\n  private allocateSize: number;\n\n  constructor({\n    size = 1024,\n    maxSize,\n    allocateSize = 1024,\n  }: BcsWriterOptions = {}) {\n    this.size = size;\n    this.maxSize = maxSize || size;\n    this.allocateSize = allocateSize;\n    this.dataView = new DataView(new ArrayBuffer(size));\n  }\n\n  private ensureSizeOrGrow(bytes: number) {\n    const requiredSize = this.bytePosition + bytes;\n    if (requiredSize > this.size) {\n      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n      if (requiredSize > nextSize) {\n        throw new Error(\n          `Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`\n        );\n      }\n\n      this.size = nextSize;\n      const nextBuffer = new ArrayBuffer(this.size);\n      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n      this.dataView = new DataView(nextBuffer);\n    }\n  }\n\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes: number): this {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write8(value: number | bigint): this {\n    this.ensureSizeOrGrow(1);\n    this.dataView.setUint8(this.bytePosition, Number(value));\n    return this.shift(1);\n  }\n  /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write16(value: number | bigint): this {\n    this.ensureSizeOrGrow(2);\n    this.dataView.setUint16(this.bytePosition, Number(value), true);\n    return this.shift(2);\n  }\n  /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write32(value: number | bigint): this {\n    this.ensureSizeOrGrow(4);\n    this.dataView.setUint32(this.bytePosition, Number(value), true);\n    return this.shift(4);\n  }\n  /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write64(value: number | bigint): this {\n    toLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n    return this;\n  }\n  /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write128(value: number | bigint): this {\n    toLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n    return this;\n  }\n  /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write256(value: number | bigint): this {\n    toLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n    return this;\n  }\n  /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeULEB(value: number): this {\n    ulebEncode(value).forEach((el) => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */\n  writeVec(\n    vector: any[],\n    cb: (writer: BcsWriter, el: any, i: number, len: number) => {}\n  ): this {\n    this.writeULEB(vector.length);\n    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n    return this;\n  }\n\n  /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */\n  *[Symbol.iterator](): Iterator<number, Iterable<number>> {\n    for (let i = 0; i < this.bytePosition; i++) {\n      yield this.dataView.getUint8(i);\n    }\n    return this.toBytes();\n  }\n\n  /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */\n  toBytes(): Uint8Array {\n    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n  }\n\n  /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */\n  toString(encoding: Encoding): string {\n    return encodeStr(this.toBytes(), encoding);\n  }\n}\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nfunction ulebEncode(num: number): number[] {\n  let arr = [];\n  let len = 0;\n\n  if (num === 0) {\n    return [0];\n  }\n\n  while (num > 0) {\n    arr[len] = num & 0x7f;\n    if ((num >>= 7)) {\n      arr[len] |= 0x80;\n    }\n    len += 1;\n  }\n\n  return arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nfunction ulebDecode(arr: number[] | Uint8Array): {\n  value: number;\n  length: number;\n} {\n  let total = 0;\n  let shift = 0;\n  let len = 0;\n\n  while (true) {\n    let byte = arr[len];\n    len += 1;\n    total |= (byte & 0x7f) << shift;\n    if ((byte & 0x80) === 0) {\n      break;\n    }\n    shift += 7;\n  }\n\n  return {\n    value: total,\n    length: len,\n  };\n}\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport interface TypeInterface {\n  encode: (\n    self: BCS,\n    data: any,\n    options: BcsWriterOptions | undefined,\n    typeParams: TypeName[]\n  ) => BcsWriter;\n  decode: (self: BCS, data: Uint8Array, typeParams: TypeName[]) => any;\n\n  _encodeRaw: (\n    writer: BcsWriter,\n    data: any,\n    typeParams: TypeName[],\n    typeMap: { [key: string]: TypeName }\n  ) => BcsWriter;\n  _decodeRaw: (\n    reader: BcsReader,\n    typeParams: TypeName[],\n    typeMap: { [key: string]: TypeName }\n  ) => any;\n}\n\n/**\n * Struct type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerStructType`.\n */\nexport type StructTypeDefinition = {\n  [key: string]: TypeName | StructTypeDefinition;\n};\n\n/**\n * Enum type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerEnumType`.\n *\n * Value can be either `string` when invariant has a type or `null`\n * when invariant is empty.\n *\n * @example\n * bcs.registerEnumType('Option<T>', {\n *   some: 'T',\n *   none: null\n * });\n */\nexport type EnumTypeDefinition = {\n  [key: string]: TypeName | StructTypeDefinition | null;\n};\n\n/**\n * Configuration that is passed into BCS constructor.\n */\nexport type BcsConfig = {\n  /**\n   * Defines type name for the vector / array type.\n   * In Move: `vector<T>` or `vector`.\n   */\n  vectorType: string;\n  /**\n   * Address length. Varies depending on a platform and\n   * has to be specified for the `address` type.\n   */\n  addressLength: number;\n\n  /**\n   * Custom encoding for address. Supported values are\n   * either 'hex' or 'base64'.\n   */\n  addressEncoding?: \"hex\" | \"base64\";\n  /**\n   * Opening and closing symbol for type parameters. Can be\n   * any pair of symbols (eg `['(', ')']`); default value follows\n   * Rust and Move: `<` and `>`.\n   */\n  genericSeparators?: [string, string];\n  /**\n   * Type definitions for the BCS. This field allows spawning\n   * BCS instance from JSON or another prepared configuration.\n   * Optional.\n   */\n  types?: {\n    structs?: { [key: string]: StructTypeDefinition };\n    enums?: { [key: string]: EnumTypeDefinition };\n    aliases?: { [key: string]: string };\n  };\n  /**\n   * Whether to auto-register primitive types on launch.\n   */\n  withPrimitives?: boolean;\n};\n\n/**\n * BCS implementation for Move types and few additional built-ins.\n */\nexport class BCS {\n  // Prefefined types constants\n  static readonly U8: string = \"u8\";\n  static readonly U16: string = \"u16\";\n  static readonly U32: string = \"u32\";\n  static readonly U64: string = \"u64\";\n  static readonly U128: string = \"u128\";\n  static readonly U256: string = \"u256\";\n  static readonly BOOL: string = \"bool\";\n  static readonly VECTOR: string = \"vector\";\n  static readonly ADDRESS: string = \"address\";\n  static readonly STRING: string = \"string\";\n  static readonly HEX: string = \"hex-string\";\n  static readonly BASE58: string = \"base58-string\";\n  static readonly BASE64: string = \"base64-string\";\n\n  /**\n   * Map of kind `TypeName => TypeInterface`. Holds all\n   * callbacks for (de)serialization of every registered type.\n   *\n   * If the value stored is a string, it is treated as an alias.\n   */\n  public types: Map<string, TypeInterface | string> = new Map();\n\n  /**\n   * Stored BcsConfig for the current instance of BCS.\n   */\n  protected schema: BcsConfig;\n\n  /**\n   * Count temp keys to generate a new one when requested.\n   */\n  protected counter: number = 0;\n\n  /**\n   * Name of the key to use for temporary struct definitions.\n   * Returns a temp key + index (for a case when multiple temp\n   * structs are processed).\n   */\n  private tempKey() {\n    return `bcs-struct-${++this.counter}`;\n  }\n\n  /**\n   * Construct a BCS instance with a prepared schema.\n   *\n   * @param schema A prepared schema with type definitions\n   * @param withPrimitives Whether to register primitive types by default\n   */\n  constructor(schema: BcsConfig | BCS) {\n    // if BCS instance is passed -> clone its schema\n    if (schema instanceof BCS) {\n      this.schema = schema.schema;\n      this.types = new Map(schema.types);\n      return;\n    }\n\n    this.schema = schema;\n\n    // Register address type under key 'address'.\n    this.registerAddressType(\n      BCS.ADDRESS,\n      schema.addressLength,\n      schema.addressEncoding\n    );\n    this.registerVectorType(schema.vectorType);\n\n    // Register struct types if they were passed.\n    if (schema.types && schema.types.structs) {\n      for (let name of Object.keys(schema.types.structs)) {\n        this.registerStructType(name, schema.types.structs[name]);\n      }\n    }\n\n    // Register enum types if they were passed.\n    if (schema.types && schema.types.enums) {\n      for (let name of Object.keys(schema.types.enums)) {\n        this.registerEnumType(name, schema.types.enums[name]);\n      }\n    }\n\n    // Register aliases if they were passed.\n    if (schema.types && schema.types.aliases) {\n      for (let name of Object.keys(schema.types.aliases)) {\n        this.registerAlias(name, schema.types.aliases[name]);\n      }\n    }\n\n    if (schema.withPrimitives !== false) {\n      registerPrimitives(this);\n    }\n  }\n\n  /**\n   * Serialize data into bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<u8>', 'u8');\n   *\n   * let serialized = BCS\n   *   .set('vector<u8>', [1,2,3,4,5,6])\n   *   .toBytes();\n   *\n   * console.assert(toHex(serialized) === '06010203040506');\n   *\n   * @param type Name of the type to serialize (must be registered) or a struct type.\n   * @param data Data to serialize.\n   * @param size Serialization buffer size. Default 1024 = 1KB.\n   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n   */\n  public ser(\n    type: TypeName | StructTypeDefinition,\n    data: any,\n    options?: BcsWriterOptions\n  ): BcsWriter {\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const { name, params } = this.parseTypeName(type);\n      return this.getTypeInterface(name).encode(\n        this,\n        data,\n        options,\n        params as string[]\n      );\n    }\n\n    // Quick serialization without registering the type in the main struct.\n    if (typeof type === \"object\") {\n      const key = this.tempKey();\n      const temp = new BCS(this);\n      return temp.registerStructType(key, type).ser(key, data, options);\n    }\n\n    throw new Error(\n      `Incorrect type passed into the '.ser()' function. \\n${JSON.stringify(\n        type\n      )}`\n    );\n  }\n\n  /**\n   * Deserialize BCS into a JS type.\n   *\n   * @example\n   * let num = bcs.ser('u64', '4294967295').toString('hex');\n   * let deNum = bcs.de('u64', num, 'hex');\n   * console.assert(deNum.toString(10) === '4294967295');\n   *\n   * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n   * @param data Data to deserialize.\n   * @param encoding Optional - encoding to use if data is of type String\n   * @return Deserialized data.\n   */\n  public de(\n    type: TypeName | StructTypeDefinition,\n    data: Uint8Array | string,\n    encoding?: Encoding\n  ): any {\n    if (typeof data === \"string\") {\n      if (encoding) {\n        data = decodeStr(data, encoding);\n      } else {\n        throw new Error(\"To pass a string to `bcs.de`, specify encoding\");\n      }\n    }\n\n    // In case the type specified is already registered.\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const { name, params } = this.parseTypeName(type);\n      return this.getTypeInterface(name).decode(this, data, params as string[]);\n    }\n\n    // Deserialize without registering a type using a temporary clone.\n    if (typeof type === \"object\") {\n      const temp = new BCS(this);\n      const key = this.tempKey();\n      return temp.registerStructType(key, type).de(key, data, encoding);\n    }\n\n    throw new Error(\n      `Incorrect type passed into the '.de()' function. \\n${JSON.stringify(\n        type\n      )}`\n    );\n  }\n\n  /**\n   * Check whether a `TypeInterface` has been loaded for a `type`.\n   * @param type Name of the type to check.\n   * @returns\n   */\n  public hasType(type: string): boolean {\n    return this.types.has(type);\n  }\n\n  /**\n   * Create an alias for a type.\n   * WARNING: this can potentially lead to recursion\n   * @param name Alias to use\n   * @param forType Type to reference\n   * @returns\n   *\n   * @example\n   * ```\n   * let bcs = new BCS(getSuiMoveConfig());\n   * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n   * ```\n   */\n  public registerAlias(name: string, forType: string): BCS {\n    this.types.set(name, forType);\n    return this;\n  }\n\n  /**\n   * Method to register new types for BCS internal representation.\n   * For each registered type 2 callbacks must be specified and one is optional:\n   *\n   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n   * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n   * - validateCb(data) - validate data - either return bool or throw an error\n   *\n   * @example\n   * // our type would be a string that consists only of numbers\n   * bcs.registerType('number_string',\n   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n   * );\n   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n   *\n   * @param name\n   * @param encodeCb Callback to encode a value.\n   * @param decodeCb Callback to decode a value.\n   * @param validateCb Optional validator Callback to check type before serialization.\n   */\n  public registerType(\n    typeName: TypeName,\n    encodeCb: (\n      writer: BcsWriter,\n      data: any,\n      typeParams: TypeName[],\n      typeMap: { [key: string]: TypeName }\n    ) => BcsWriter,\n    decodeCb: (\n      reader: BcsReader,\n      typeParams: TypeName[],\n      typeMap: { [key: string]: TypeName }\n    ) => any,\n    validateCb: (data: any) => boolean = () => true\n  ): BCS {\n    const { name, params: generics } = this.parseTypeName(typeName);\n\n    this.types.set(name, {\n      encode(self: BCS, data, options: BcsWriterOptions, typeParams) {\n        const typeMap = (generics as string[]).reduce(\n          (acc: any, value: string, index) => {\n            return Object.assign(acc, { [value]: typeParams[index] });\n          },\n          {}\n        );\n\n        return this._encodeRaw.call(\n          self,\n          new BcsWriter(options),\n          data,\n          typeParams,\n          typeMap\n        );\n      },\n      decode(self: BCS, data, typeParams) {\n        const typeMap = (generics as string[]).reduce(\n          (acc: any, value: string, index) => {\n            return Object.assign(acc, { [value]: typeParams[index] });\n          },\n          {}\n        );\n\n        return this._decodeRaw.call(\n          self,\n          new BcsReader(data),\n          typeParams,\n          typeMap\n        );\n      },\n\n      // these methods should always be used with caution as they require pre-defined\n      // reader and writer and mainly exist to allow multi-field (de)serialization;\n      _encodeRaw(writer, data, typeParams, typeMap) {\n        if (validateCb(data)) {\n          return encodeCb.call(this, writer, data, typeParams, typeMap);\n        } else {\n          throw new Error(`Validation failed for type ${name}, data: ${data}`);\n        }\n      },\n      _decodeRaw(reader, typeParams, typeMap) {\n        return decodeCb.call(this, reader, typeParams, typeMap);\n      },\n    } as TypeInterface);\n\n    return this;\n  }\n\n  /**\n   * Register an address type which is a sequence of U8s of specified length.\n   * @example\n   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n   *\n   * @param name Name of the address type.\n   * @param length Byte length of the address.\n   * @param encoding Encoding to use for the address type\n   * @returns\n   */\n  public registerAddressType(\n    name: string,\n    length: number,\n    encoding: Encoding | void = \"hex\"\n  ): BCS {\n    switch (encoding) {\n      case \"base64\":\n        return this.registerType(\n          name,\n          function encodeAddress(writer, data: string) {\n            return fromB64(data).reduce(\n              (writer, el) => writer.write8(el),\n              writer\n            );\n          },\n          function decodeAddress(reader) {\n            return toB64(reader.readBytes(length));\n          }\n        );\n      case \"hex\":\n        return this.registerType(\n          name,\n          function encodeAddress(writer, data: string) {\n            return fromHEX(data).reduce(\n              (writer, el) => writer.write8(el),\n              writer\n            );\n          },\n          function decodeAddress(reader) {\n            return toHEX(reader.readBytes(length));\n          }\n        );\n      default:\n        throw new Error(\"Unsupported encoding! Use either hex or base64\");\n    }\n  }\n\n  /**\n   * Register custom vector type inside the bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<T>'); // generic registration\n   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n   *\n   * @param name Name of the type to register\n   * @param elementType Optional name of the inner type of the vector\n   * @return Returns self for chaining.\n   */\n  private registerVectorType(typeName: string): BCS {\n    let { name, params } = this.parseTypeName(typeName);\n    if (params.length > 1) {\n      throw new Error(\"Vector can have only one type parameter; got \" + name);\n    }\n\n    return this.registerType(\n      typeName,\n      function encodeVector(\n        this: BCS,\n        writer: BcsWriter,\n        data: any[],\n        typeParams: TypeName[],\n        typeMap\n      ) {\n        return writer.writeVec(data, (writer, el) => {\n          let elementType: TypeName = typeParams[0];\n          if (!elementType) {\n            throw new Error(\n              `Incorrect number of type parameters passed a to vector '${typeName}'`\n            );\n          }\n\n          let { name, params } = this.parseTypeName(elementType);\n          if (this.hasType(name)) {\n            return this.getTypeInterface(name)._encodeRaw.call(\n              this,\n              writer,\n              el,\n              params,\n              typeMap\n            );\n          }\n\n          if (!(name in typeMap)) {\n            throw new Error(\n              `Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`\n            );\n          }\n\n          let { name: innerName, params: innerParams } = this.parseTypeName(\n            typeMap[name]\n          );\n\n          return this.getTypeInterface(innerName)._encodeRaw.call(\n            this,\n            writer,\n            el,\n            innerParams,\n            typeMap\n          );\n        });\n      },\n      function decodeVector(this: BCS, reader: BcsReader, typeParams, typeMap) {\n        return reader.readVec((reader) => {\n          let elementType: TypeName = typeParams[0];\n          if (!elementType) {\n            throw new Error(\n              `Incorrect number of type parameters passed to a vector '${typeName}'`\n            );\n          }\n\n          let { name, params } = this.parseTypeName(elementType);\n          if (this.hasType(name)) {\n            return this.getTypeInterface(name)._decodeRaw.call(\n              this,\n              reader,\n              params,\n              typeMap\n            );\n          }\n\n          if (!(name in typeMap)) {\n            throw new Error(\n              `Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`\n            );\n          }\n\n          let { name: innerName, params: innerParams } = this.parseTypeName(\n            typeMap[name]\n          );\n\n          return this.getTypeInterface(innerName)._decodeRaw.call(\n            this,\n            reader,\n            innerParams,\n            typeMap\n          );\n        });\n      }\n    );\n  }\n\n  /**\n   * Safe method to register a custom Move struct. The first argument is a name of the\n   * struct which is only used on the FrontEnd and has no affect on serialization results,\n   * and the second is a struct description passed as an Object.\n   *\n   * The description object MUST have the same order on all of the platforms (ie in Move\n   * or in Rust).\n   *\n   * @example\n   * // Move / Rust struct\n   * // struct Coin {\n   * //   value: u64,\n   * //   owner: vector<u8>, // name // Vec<u8> in Rust\n   * //   is_locked: bool,\n   * // }\n   *\n   * bcs.registerStructType('Coin', {\n   *   value: bcs.U64,\n   *   owner: bcs.STRING,\n   *   is_locked: bcs.BOOL\n   * });\n   *\n   * // Created in Rust with diem/bcs\n   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n   *  128, 209, 177,   5,  96,  0,  0,\n   *    0,  14,  66, 105, 103, 32, 87,\n   *   97, 108, 108, 101, 116, 32, 71,\n   *  117, 121,   0\n   * ];\n   *\n   * // Let's encode the value as well\n   * let test_set = bcs.ser('Coin', {\n   *   owner: 'Big Wallet Guy',\n   *   value: '412412400000',\n   *   is_locked: false,\n   * });\n   *\n   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n   *\n   * @param name Name of the type to register.\n   * @param fields Fields of the struct. Must be in the correct order.\n   * @return Returns BCS for chaining.\n   */\n  public registerStructType(\n    typeName: TypeName,\n    fields: StructTypeDefinition\n  ): BCS {\n    // When an Object is passed, we register it under a new key and store it\n    // in the registered type system. This way we allow nested inline definitions.\n    for (let key in fields) {\n      let internalName = this.tempKey();\n      let value = fields[key];\n\n      // TODO: add a type guard here?\n      if (!Array.isArray(value) && typeof value !== \"string\") {\n        fields[key] = internalName;\n        this.registerStructType(internalName, value as StructTypeDefinition);\n      }\n    }\n\n    let struct = Object.freeze(fields); // Make sure the order doesn't get changed\n\n    // IMPORTANT: we need to store canonical order of fields for each registered\n    // struct so we maintain it and allow developers to use any field ordering in\n    // their code (and not cause mismatches based on field order).\n    let canonicalOrder = Object.keys(struct);\n\n    // Holds generics for the struct definition. At this stage we can check that\n    // generic parameter matches the one defined in the struct.\n    let { name: structName, params: generics } = this.parseTypeName(typeName);\n\n    // Make sure all the types in the fields description are already known\n    // and that all the field types are strings.\n    return this.registerType(\n      typeName,\n      function encodeStruct(\n        this: BCS,\n        writer: BcsWriter,\n        data: { [key: string]: any },\n        typeParams,\n        typeMap\n      ) {\n        if (!data || data.constructor !== Object) {\n          throw new Error(\n            `Expected ${structName} to be an Object, got: ${data}`\n          );\n        }\n\n        if (typeParams.length !== generics.length) {\n          throw new Error(\n            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`\n          );\n        }\n\n        // follow the canonical order when serializing\n        for (let key of canonicalOrder) {\n          if (!(key in data)) {\n            throw new Error(\n              `Struct ${structName} requires field ${key}:${struct[key]}`\n            );\n          }\n\n          // Before deserializing, read the canonical field type.\n          const { name: fieldType, params: fieldParams } = this.parseTypeName(\n            struct[key] as TypeName\n          );\n\n          // Check whether this type is a generic defined in this struct.\n          // If it is -> read the type parameter matching its index.\n          // If not - tread as a regular field.\n          if (!generics.includes(fieldType)) {\n            this.getTypeInterface(fieldType)._encodeRaw.call(\n              this,\n              writer,\n              data[key],\n              fieldParams,\n              typeMap\n            );\n          } else {\n            const paramIdx = generics.indexOf(fieldType);\n            let { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n            // If the type from the type parameters already exists\n            // and known -> proceed with type decoding.\n            if (this.hasType(name)) {\n              this.getTypeInterface(name)._encodeRaw.call(\n                this,\n                writer,\n                data[key],\n                params as string[],\n                typeMap\n              );\n              continue;\n            }\n\n            // Alternatively, if it's a global generic parameter...\n            if (!(name in typeMap)) {\n              throw new Error(\n                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`\n              );\n            }\n\n            let { name: innerName, params: innerParams } = this.parseTypeName(\n              typeMap[name]\n            );\n            this.getTypeInterface(innerName)._encodeRaw.call(\n              this,\n              writer,\n              data[key],\n              innerParams,\n              typeMap\n            );\n          }\n        }\n        return writer;\n      },\n      function decodeStruct(this: BCS, reader: BcsReader, typeParams, typeMap) {\n        if (typeParams.length !== generics.length) {\n          throw new Error(\n            `Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`\n          );\n        }\n\n        let result: { [key: string]: any } = {};\n        for (let key of canonicalOrder) {\n          const { name: fieldName, params: fieldParams } = this.parseTypeName(\n            struct[key] as TypeName\n          );\n\n          // if it's not a generic\n          if (!generics.includes(fieldName)) {\n            result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(\n              this,\n              reader,\n              fieldParams as string[],\n              typeMap\n            );\n          } else {\n            const paramIdx = generics.indexOf(fieldName);\n            let { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n            // If the type from the type parameters already exists\n            // and known -> proceed with type decoding.\n            if (this.hasType(name)) {\n              result[key] = this.getTypeInterface(name)._decodeRaw.call(\n                this,\n                reader,\n                params,\n                typeMap\n              );\n              continue;\n            }\n\n            if (!(name in typeMap)) {\n              throw new Error(\n                `Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`\n              );\n            }\n\n            let { name: innerName, params: innerParams } = this.parseTypeName(\n              typeMap[name]\n            );\n            result[key] = this.getTypeInterface(innerName)._decodeRaw.call(\n              this,\n              reader,\n              innerParams,\n              typeMap\n            );\n          }\n        }\n        return result;\n      }\n    );\n  }\n\n  /**\n   * Safe method to register custom enum type where each invariant holds the value of another type.\n   * @example\n   * bcs.registerStructType('Coin', { value: 'u64' });\n   * bcs.registerEnumType('MyEnum', {\n   *  single: 'Coin',\n   *  multi: 'vector<Coin>',\n   *  empty: null\n   * });\n   *\n   * console.log(\n   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n   * )\n   *\n   * // and serialization\n   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n   *\n   * @param name\n   * @param variants\n   */\n  public registerEnumType(\n    typeName: TypeName,\n    variants: EnumTypeDefinition\n  ): BCS {\n    // When an Object is passed, we register it under a new key and store it\n    // in the registered type system. This way we allow nested inline definitions.\n    for (let key in variants) {\n      let internalName = this.tempKey();\n      let value = variants[key];\n\n      if (\n        value !== null &&\n        !Array.isArray(value) &&\n        typeof value !== \"string\"\n      ) {\n        variants[key] = internalName;\n        this.registerStructType(internalName, value as StructTypeDefinition);\n      }\n    }\n\n    let struct = Object.freeze(variants); // Make sure the order doesn't get changed\n\n    // IMPORTANT: enum is an ordered type and we have to preserve ordering in BCS\n    let canonicalOrder = Object.keys(struct);\n\n    // Parse type parameters in advance to know the index of each generic parameter.\n    let { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\n\n    return this.registerType(\n      typeName,\n      function encodeEnum(\n        this: BCS,\n        writer: BcsWriter,\n        data: { [key: string]: any | null },\n        typeParams,\n        typeMap\n      ) {\n        if (!data) {\n          throw new Error(\n            `Unable to write enum \"${name}\", missing data.\\nReceived: \"${data}\"`\n          );\n        }\n        if (typeof data !== \"object\") {\n          throw new Error(\n            `Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\n              \" | \"\n            )}\".\\nReceived: \"${JSON.stringify(data)}\"`\n          );\n        }\n\n        let key = Object.keys(data)[0];\n        if (key === undefined) {\n          throw new Error(\n            `Empty object passed as invariant of the enum \"${name}\"`\n          );\n        }\n\n        let orderByte = canonicalOrder.indexOf(key);\n        if (orderByte === -1) {\n          throw new Error(\n            `Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\n              \" | \"\n            )}\"; received \"${key}\"`\n          );\n        }\n        let invariant = canonicalOrder[orderByte];\n        let invariantType = struct[invariant] as TypeName | null;\n\n        // write order byte\n        writer.write8(orderByte);\n\n        // When { \"key\": null } - empty value for the invariant.\n        if (invariantType === null) {\n          return writer;\n        }\n\n        let paramIndex = canonicalTypeParams.indexOf(invariantType);\n        let typeOrParam =\n          paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n        {\n          let { name, params } = this.parseTypeName(typeOrParam);\n          return this.getTypeInterface(name)._encodeRaw.call(\n            this,\n            writer,\n            data[key],\n            params,\n            typeMap\n          );\n        }\n      },\n      function decodeEnum(this: BCS, reader: BcsReader, typeParams, typeMap) {\n        let orderByte = reader.readULEB();\n        let invariant = canonicalOrder[orderByte];\n        let invariantType = struct[invariant] as TypeName | null;\n\n        if (orderByte === -1) {\n          throw new Error(\n            `Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`\n          );\n        }\n\n        // Encode an empty value for the enum.\n        if (invariantType === null) {\n          return { [invariant]: true };\n        }\n\n        let paramIndex = canonicalTypeParams.indexOf(invariantType);\n        let typeOrParam =\n          paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n        {\n          let { name, params } = this.parseTypeName(typeOrParam);\n          return {\n            [invariant]: this.getTypeInterface(name)._decodeRaw.call(\n              this,\n              reader,\n              params,\n              typeMap\n            ),\n          };\n        }\n      }\n    );\n  }\n  /**\n   * Get a set of encoders/decoders for specific type.\n   * Mainly used to define custom type de/serialization logic.\n   *\n   * @param type\n   * @returns {TypeInterface}\n   */\n  public getTypeInterface(type: string): TypeInterface {\n    let typeInterface = this.types.get(type);\n\n    // Special case - string means an alias.\n    // Goes through the alias chain and tracks recursion.\n    if (typeof typeInterface === \"string\") {\n      let chain: string[] = [];\n      while (typeof typeInterface === \"string\") {\n        if (chain.includes(typeInterface)) {\n          throw new Error(\n            `Recursive definition found: ${chain.join(\n              \" -> \"\n            )} -> ${typeInterface}`\n          );\n        }\n        chain.push(typeInterface);\n        typeInterface = this.types.get(typeInterface);\n      }\n    }\n\n    if (typeInterface === undefined) {\n      throw new Error(`Type ${type} is not registered`);\n    }\n\n    return typeInterface;\n  }\n\n  /**\n   * Parse a type name and get the type's generics.\n   * @example\n   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n   * // typeName: Option\n   * // typeParams: [ 'Coin<SUI>' ]\n   *\n   * @param name Name of the type to process\n   * @returns Object with typeName and typeParams listed as Array\n   */\n  public parseTypeName(name: TypeName): {\n    name: string;\n    params: TypeName[];\n  } {\n    if (Array.isArray(name)) {\n      let [typeName, ...params] = name;\n      return { name: typeName, params };\n    }\n\n    if (typeof name !== \"string\") {\n      throw new Error(`Illegal type passed as a name of the type: ${name}`);\n    }\n\n    let [left, right] = this.schema.genericSeparators || [\"<\", \">\"];\n\n    let l_bound = name.indexOf(left);\n    let r_bound = Array.from(name).reverse().indexOf(right);\n\n    // if there are no generics - exit gracefully.\n    if (l_bound === -1 && r_bound === -1) {\n      return { name: name, params: [] };\n    }\n\n    // if one of the bounds is not defined - throw an Error.\n    if (l_bound === -1 || r_bound === -1) {\n      throw new Error(`Unclosed generic in name '${name}'`);\n    }\n\n    let typeName = name.slice(0, l_bound);\n    let params = name\n      .slice(l_bound + 1, name.length - r_bound - 1)\n      .split(\",\")\n      .map((e) => e.trim());\n\n    return { name: typeName, params };\n  }\n}\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n  switch (encoding) {\n    case \"base58\":\n      return toB58(data);\n    case \"base64\":\n      return toB64(data);\n    case \"hex\":\n      return toHEX(data);\n    default:\n      throw new Error(\n        \"Unsupported encoding, supported values are: base64, hex\"\n      );\n  }\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n  switch (encoding) {\n    case \"base58\":\n      return fromB58(data);\n    case \"base64\":\n      return fromB64(data);\n    case \"hex\":\n      return fromHEX(data);\n    default:\n      throw new Error(\n        \"Unsupported encoding, supported values are: base64, hex\"\n      );\n  }\n}\n\n/**\n * Register the base set of primitive and common types.\n * Is called in the `BCS` constructor automatically but can\n * be ignored if the `withPrimitives` argument is not set.\n */\nexport function registerPrimitives(bcs: BCS): void {\n  bcs.registerType(\n    BCS.U8,\n    function (writer: BcsWriter, data) {\n      return writer.write8(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read8();\n    },\n    (u8) => u8 < 256\n  );\n\n  bcs.registerType(\n    BCS.U16,\n    function (writer: BcsWriter, data) {\n      return writer.write16(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read16();\n    },\n    (u16) => u16 < 65536\n  );\n\n  bcs.registerType(\n    BCS.U32,\n    function (writer: BcsWriter, data) {\n      return writer.write32(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read32();\n    },\n    (u32) => u32 <= 4294967296n\n  );\n\n  bcs.registerType(\n    BCS.U64,\n    function (writer: BcsWriter, data) {\n      return writer.write64(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read64();\n    }\n  );\n\n  bcs.registerType(\n    BCS.U128,\n    function (writer: BcsWriter, data: bigint) {\n      return writer.write128(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read128();\n    }\n  );\n\n  bcs.registerType(\n    BCS.U256,\n    function (writer: BcsWriter, data) {\n      return writer.write256(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read256();\n    }\n  );\n\n  bcs.registerType(\n    BCS.BOOL,\n    function (writer: BcsWriter, data) {\n      return writer.write8(data);\n    },\n    function (reader: BcsReader) {\n      return reader.read8().toString(10) === \"1\";\n    }\n  );\n\n  bcs.registerType(\n    BCS.STRING,\n    function (writer: BcsWriter, data: string) {\n      return writer.writeVec(Array.from(data), (writer, el) =>\n        writer.write8(el.charCodeAt(0))\n      );\n    },\n    function (reader: BcsReader) {\n      return reader\n        .readVec((reader) => reader.read8())\n        .map((el: bigint) => String.fromCharCode(Number(el)))\n        .join(\"\");\n    },\n    (_str: string) => true\n  );\n\n  bcs.registerType(\n    BCS.HEX,\n    function (writer: BcsWriter, data: string) {\n      return writer.writeVec(Array.from(fromHEX(data)), (writer, el) =>\n        writer.write8(el)\n      );\n    },\n    function (reader: BcsReader) {\n      let bytes = reader.readVec((reader) => reader.read8());\n      return toHEX(new Uint8Array(bytes));\n    }\n  );\n\n  bcs.registerType(\n    BCS.BASE58,\n    function (writer: BcsWriter, data: string) {\n      return writer.writeVec(Array.from(fromB58(data)), (writer, el) =>\n        writer.write8(el)\n      );\n    },\n    function (reader: BcsReader) {\n      let bytes = reader.readVec((reader) => reader.read8());\n      return toB58(new Uint8Array(bytes));\n    }\n  );\n\n  bcs.registerType(\n    BCS.BASE64,\n    function (writer: BcsWriter, data: string) {\n      return writer.writeVec(Array.from(fromB64(data)), (writer, el) =>\n        writer.write8(el)\n      );\n    },\n    function (reader: BcsReader) {\n      let bytes = reader.readVec((reader) => reader.read8());\n      return toB64(new Uint8Array(bytes));\n    }\n  );\n}\n\nexport function getRustConfig(): BcsConfig {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"Vec\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\",\n  };\n}\n\nexport function getSuiMoveConfig(): BcsConfig {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"vector\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\",\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}