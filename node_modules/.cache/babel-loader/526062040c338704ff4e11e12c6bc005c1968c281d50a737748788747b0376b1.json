{"ast":null,"code":"var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _blockData, _input, input_fn, _getConfig, getConfig_fn, _validate, validate_fn, _prepareGasPayment, prepareGasPayment_fn, _prepareGasPrice, prepareGasPrice_fn, _prepareTransactions, prepareTransactions_fn, _prepare, prepare_fn;\nimport { fromB64 } from \"@mysten/bcs\";\nimport { is, mask } from \"superstruct\";\nimport { extractMutableReference, extractStructTag, getObjectReference, getSharedObjectInitialVersion, normalizeSuiObjectId, SuiObjectRef, SUI_TYPE_ARG } from \"../types/index.js\";\nimport { Transactions, TransactionBlockInput, getTransactionType } from \"./Transactions.js\";\nimport { BuilderCallArg, getIdFromCallArg, Inputs, isMutableSharedObjectInput, PureCallArg } from \"./Inputs.js\";\nimport { getPureSerializationType, isTxContext } from \"./serializer.js\";\nimport { TransactionBlockDataBuilder } from \"./TransactionBlockData.js\";\nimport { TRANSACTION_TYPE, create } from \"./utils.js\";\nconst DefaultOfflineLimits = {\n  maxPureArgumentSize: 16 * 1024,\n  maxTxGas: 5e10,\n  maxGasObjects: 256,\n  maxTxSizeBytes: 128 * 1024\n};\nfunction createTransactionResult(index) {\n  const baseResult = {\n    kind: \"Result\",\n    index\n  };\n  const nestedResults = [];\n  const nestedResultFor = resultIndex => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {\n    kind: \"NestedResult\",\n    index,\n    resultIndex\n  });\n  return new Proxy(baseResult, {\n    set() {\n      throw new Error(\"The transaction result is a proxy, and does not support setting properties directly\");\n    },\n    // TODO: Instead of making this return a concrete argument, we should ideally\n    // make it reference-based (so that this gets resolved at build-time), which\n    // allows re-ordering transactions.\n    get(target, property) {\n      if (property in target) {\n        return Reflect.get(target, property);\n      }\n      if (property === Symbol.iterator) {\n        return function* () {\n          let i = 0;\n          while (true) {\n            yield nestedResultFor(i);\n            i++;\n          }\n        };\n      }\n      if (typeof property === \"symbol\") return;\n      const resultIndex = parseInt(property, 10);\n      if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n      return nestedResultFor(resultIndex);\n    }\n  });\n}\nfunction expectProvider(options) {\n  if (!options.provider) {\n    throw new Error(`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`);\n  }\n  return options.provider;\n}\nconst TRANSACTION_BRAND = Symbol.for(\"@mysten/transaction\");\nconst LIMITS = {\n  // The maximum gas that is allowed.\n  maxTxGas: \"max_tx_gas\",\n  // The maximum number of gas objects that can be selected for one transaction.\n  maxGasObjects: \"max_gas_payment_objects\",\n  // The maximum size (in bytes) that the transaction can be:\n  maxTxSizeBytes: \"max_tx_size_bytes\",\n  // The maximum size (in bytes) that pure arguments can be:\n  maxPureArgumentSize: \"max_pure_argument_size\"\n};\nconst GAS_SAFE_OVERHEAD = 1000n;\nconst MAX_OBJECTS_PER_FETCH = 50;\nconst chunk = (arr, size) => Array.from({\n  length: Math.ceil(arr.length / size)\n}, (_, i) => arr.slice(i * size, i * size + size));\nconst _TransactionBlock = class _TransactionBlock {\n  constructor(transaction) {\n    /**\n     * Dynamically create a new input, which is separate from the `input`. This is important\n     * for generated clients to be able to define unique inputs that are non-overlapping with the\n     * defined inputs.\n     *\n     * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n     * is the format required for custom serialization.\n     *\n     */\n    __privateAdd(this, _input);\n    __privateAdd(this, _getConfig);\n    __privateAdd(this, _validate);\n    // The current default is just picking _all_ coins we can which may not be ideal.\n    __privateAdd(this, _prepareGasPayment);\n    __privateAdd(this, _prepareGasPrice);\n    __privateAdd(this, _prepareTransactions);\n    /**\n     * Prepare the transaction by valdiating the transaction data and resolving all inputs\n     * so that it can be built into bytes.\n     */\n    __privateAdd(this, _prepare);\n    __privateAdd(this, _blockData, void 0);\n    __privateSet(this, _blockData, new TransactionBlockDataBuilder(transaction ? transaction.blockData : void 0));\n  }\n  /** Returns `true` if the object is an instance of the Transaction builder class. */\n  static is(obj) {\n    return !!obj && typeof obj === \"object\" && obj[TRANSACTION_BRAND] === true;\n  }\n  /**\n   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n   * Supports either a byte array, or base64-encoded bytes.\n   */\n  static fromKind(serialized) {\n    const tx = new _TransactionBlock();\n    __privateSet(tx, _blockData, TransactionBlockDataBuilder.fromKindBytes(typeof serialized === \"string\" ? fromB64(serialized) : serialized));\n    return tx;\n  }\n  /**\n   * Converts from a serialized transaction format to a `Transaction` class.\n   * There are two supported serialized formats:\n   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n   * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n   */\n  static from(serialized) {\n    const tx = new _TransactionBlock();\n    if (typeof serialized !== \"string\" || !serialized.startsWith(\"{\")) {\n      __privateSet(tx, _blockData, TransactionBlockDataBuilder.fromBytes(typeof serialized === \"string\" ? fromB64(serialized) : serialized));\n    } else {\n      __privateSet(tx, _blockData, TransactionBlockDataBuilder.restore(JSON.parse(serialized)));\n    }\n    return tx;\n  }\n  /** A helper to retrieve the Transaction builder `Transactions` */\n  static get Transactions() {\n    return Transactions;\n  }\n  /** A helper to retrieve the Transaction builder `Inputs` */\n  static get Inputs() {\n    return Inputs;\n  }\n  setSender(sender) {\n    __privateGet(this, _blockData).sender = sender;\n  }\n  /**\n   * Sets the sender only if it has not already been set.\n   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n   */\n  setSenderIfNotSet(sender) {\n    if (!__privateGet(this, _blockData).sender) {\n      __privateGet(this, _blockData).sender = sender;\n    }\n  }\n  setExpiration(expiration) {\n    __privateGet(this, _blockData).expiration = expiration;\n  }\n  setGasPrice(price) {\n    __privateGet(this, _blockData).gasConfig.price = String(price);\n  }\n  setGasBudget(budget) {\n    __privateGet(this, _blockData).gasConfig.budget = String(budget);\n  }\n  setGasOwner(owner) {\n    __privateGet(this, _blockData).gasConfig.owner = owner;\n  }\n  setGasPayment(payments) {\n    __privateGet(this, _blockData).gasConfig.payment = payments.map(payment => mask(payment, SuiObjectRef));\n  }\n  /** Get a snapshot of the transaction data, in JSON form: */\n  get blockData() {\n    return __privateGet(this, _blockData).snapshot();\n  }\n  // Used to brand transaction classes so that they can be identified, even between multiple copies\n  // of the builder.\n  get [TRANSACTION_BRAND]() {\n    return true;\n  }\n  /** Returns an argument for the gas coin, to be used in a transaction. */\n  get gas() {\n    return {\n      kind: \"GasCoin\"\n    };\n  }\n  /**\n   * Add a new object input to the transaction.\n   */\n  object(value) {\n    const id = getIdFromCallArg(value);\n    const inserted = __privateGet(this, _blockData).inputs.find(i => i.type === \"object\" && id === getIdFromCallArg(i.value));\n    return inserted ?? __privateMethod(this, _input, input_fn).call(this, \"object\", value);\n  }\n  /**\n   * Add a new object input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  objectRef() {\n    return this.object(Inputs.ObjectRef(...arguments));\n  }\n  /**\n   * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  sharedObjectRef() {\n    return this.object(Inputs.SharedObjectRef(...arguments));\n  }\n  /**\n   * Add a new non-object input to the transaction.\n   */\n  pure(value, type) {\n    return __privateMethod(this, _input, input_fn).call(this, \"pure\", value instanceof Uint8Array ? Inputs.Pure(value) : type ? Inputs.Pure(value, type) : value);\n  }\n  /** Add a transaction to the transaction block. */\n  add(transaction) {\n    const index = __privateGet(this, _blockData).transactions.push(transaction);\n    return createTransactionResult(index - 1);\n  }\n  // Method shorthands:\n  splitCoins() {\n    return this.add(Transactions.SplitCoins(...arguments));\n  }\n  mergeCoins() {\n    return this.add(Transactions.MergeCoins(...arguments));\n  }\n  publish() {\n    return this.add(Transactions.Publish(...arguments));\n  }\n  upgrade() {\n    return this.add(Transactions.Upgrade(...arguments));\n  }\n  moveCall() {\n    return this.add(Transactions.MoveCall(...arguments));\n  }\n  transferObjects() {\n    return this.add(Transactions.TransferObjects(...arguments));\n  }\n  makeMoveVec() {\n    return this.add(Transactions.MakeMoveVec(...arguments));\n  }\n  /**\n   * Serialize the transaction to a string so that it can be sent to a separate context.\n   * This is different from `build` in that it does not serialize to BCS bytes, and instead\n   * uses a separate format that is unique to the transaction builder. This allows\n   * us to serialize partially-complete transactions, that can then be completed and\n   * built in a separate context.\n   *\n   * For example, a dapp can construct a transaction, but not provide gas objects\n   * or a gas budget. The transaction then can be sent to the wallet, where this\n   * information is automatically filled in (e.g. by querying for coin objects\n   * and performing a dry run).\n   */\n  serialize() {\n    return JSON.stringify(__privateGet(this, _blockData).snapshot());\n  }\n  /** Build the transaction to BCS bytes. */\n  async build() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await __privateMethod(this, _prepare, prepare_fn).call(this, options);\n    return __privateGet(this, _blockData).build({\n      maxSizeBytes: __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxSizeBytes\", options),\n      onlyTransactionKind: options.onlyTransactionKind\n    });\n  }\n  /** Derive transaction digest */\n  async getDigest() {\n    let {\n      provider\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await __privateMethod(this, _prepare, prepare_fn).call(this, {\n      provider\n    });\n    return __privateGet(this, _blockData).getDigest();\n  }\n};\n_blockData = new WeakMap();\n_input = new WeakSet();\ninput_fn = function (type, value) {\n  const index = __privateGet(this, _blockData).inputs.length;\n  const input = create({\n    kind: \"Input\",\n    // bigints can't be serialized to JSON, so just string-convert them here:\n    value: typeof value === \"bigint\" ? String(value) : value,\n    index,\n    type\n  }, TransactionBlockInput);\n  __privateGet(this, _blockData).inputs.push(input);\n  return input;\n};\n_getConfig = new WeakSet();\ngetConfig_fn = function (key, _ref) {\n  let {\n    protocolConfig,\n    limits\n  } = _ref;\n  if (limits && typeof limits[key] === \"number\") {\n    return limits[key];\n  }\n  if (!protocolConfig) {\n    return DefaultOfflineLimits[key];\n  }\n  const attribute = protocolConfig?.attributes[LIMITS[key]];\n  if (!attribute) {\n    throw new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n  }\n  const value = \"u64\" in attribute ? attribute.u64 : \"u32\" in attribute ? attribute.u32 : attribute.f64;\n  if (!value) {\n    throw new Error(`Unexpected protocol config value found for: \"${LIMITS[key]}\"`);\n  }\n  return Number(value);\n};\n_validate = new WeakSet();\nvalidate_fn = function (options) {\n  const maxPureArgumentSize = __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxPureArgumentSize\", options);\n  __privateGet(this, _blockData).inputs.forEach((input, index) => {\n    if (is(input.value, PureCallArg)) {\n      if (input.value.Pure.length > maxPureArgumentSize) {\n        throw new Error(`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`);\n      }\n    }\n  });\n};\n_prepareGasPayment = new WeakSet();\nprepareGasPayment_fn = async function (options) {\n  if (__privateGet(this, _blockData).gasConfig.payment) {\n    const maxGasObjects = __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxGasObjects\", options);\n    if (__privateGet(this, _blockData).gasConfig.payment.length > maxGasObjects) {\n      throw new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);\n    }\n  }\n  if (options.onlyTransactionKind || __privateGet(this, _blockData).gasConfig.payment) {\n    return;\n  }\n  const gasOwner = __privateGet(this, _blockData).gasConfig.owner ?? __privateGet(this, _blockData).sender;\n  const coins = await expectProvider(options).getCoins({\n    owner: gasOwner,\n    coinType: SUI_TYPE_ARG\n  });\n  const paymentCoins = coins.data.filter(coin => {\n    const matchingInput = __privateGet(this, _blockData).inputs.find(input => {\n      if (is(input.value, BuilderCallArg) && \"Object\" in input.value && \"ImmOrOwned\" in input.value.Object) {\n        return coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n      }\n      return false;\n    });\n    return !matchingInput;\n  }).slice(0, __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxGasObjects\", options) - 1).map(coin => ({\n    objectId: coin.coinObjectId,\n    digest: coin.digest,\n    version: coin.version\n  }));\n  if (!paymentCoins.length) {\n    throw new Error(\"No valid gas coins found for the transaction.\");\n  }\n  this.setGasPayment(paymentCoins);\n};\n_prepareGasPrice = new WeakSet();\nprepareGasPrice_fn = async function (options) {\n  if (options.onlyTransactionKind || __privateGet(this, _blockData).gasConfig.price) {\n    return;\n  }\n  this.setGasPrice(await expectProvider(options).getReferenceGasPrice());\n};\n_prepareTransactions = new WeakSet();\nprepareTransactions_fn = async function (options) {\n  const {\n    inputs,\n    transactions\n  } = __privateGet(this, _blockData);\n  const moveModulesToResolve = [];\n  const objectsToResolve = [];\n  transactions.forEach(transaction => {\n    if (transaction.kind === \"MoveCall\") {\n      const needsResolution = transaction.arguments.some(arg => arg.kind === \"Input\" && !is(inputs[arg.index].value, BuilderCallArg));\n      if (needsResolution) {\n        moveModulesToResolve.push(transaction);\n      }\n      return;\n    }\n    const transactionType = getTransactionType(transaction);\n    if (!transactionType.schema) return;\n    Object.entries(transaction).forEach(_ref2 => {\n      let [key, value] = _ref2;\n      if (key === \"kind\") return;\n      const keySchema = transactionType.schema[key];\n      const isArray = keySchema.type === \"array\";\n      const wellKnownEncoding = isArray ? keySchema.schema[TRANSACTION_TYPE] : keySchema[TRANSACTION_TYPE];\n      if (!wellKnownEncoding) return;\n      const encodeInput = index => {\n        const input = inputs[index];\n        if (!input) {\n          throw new Error(`Missing input ${value.index}`);\n        }\n        if (is(input.value, BuilderCallArg)) return;\n        if (wellKnownEncoding.kind === \"object\" && typeof input.value === \"string\") {\n          objectsToResolve.push({\n            id: input.value,\n            input\n          });\n        } else if (wellKnownEncoding.kind === \"pure\") {\n          input.value = Inputs.Pure(input.value, wellKnownEncoding.type);\n        } else {\n          throw new Error(\"Unexpected input format.\");\n        }\n      };\n      if (isArray) {\n        value.forEach(arrayItem => {\n          if (arrayItem.kind !== \"Input\") return;\n          encodeInput(arrayItem.index);\n        });\n      } else {\n        if (value.kind !== \"Input\") return;\n        encodeInput(value.index);\n      }\n    });\n  });\n  if (moveModulesToResolve.length) {\n    await Promise.all(moveModulesToResolve.map(async moveCall => {\n      const [packageId, moduleName, functionName] = moveCall.target.split(\"::\");\n      const normalized = await expectProvider(options).getNormalizedMoveFunction({\n        package: normalizeSuiObjectId(packageId),\n        module: moduleName,\n        function: functionName\n      });\n      const hasTxContext = normalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1));\n      const params = hasTxContext ? normalized.parameters.slice(0, normalized.parameters.length - 1) : normalized.parameters;\n      if (params.length !== moveCall.arguments.length) {\n        throw new Error(\"Incorrect number of arguments.\");\n      }\n      params.forEach((param, i) => {\n        const arg = moveCall.arguments[i];\n        if (arg.kind !== \"Input\") return;\n        const input = inputs[arg.index];\n        if (is(input.value, BuilderCallArg)) return;\n        const inputValue = input.value;\n        const serType = getPureSerializationType(param, inputValue);\n        if (serType) {\n          input.value = Inputs.Pure(inputValue, serType);\n          return;\n        }\n        const structVal = extractStructTag(param);\n        if (structVal != null || typeof param === \"object\" && \"TypeParameter\" in param) {\n          if (typeof inputValue !== \"string\") {\n            throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(inputValue, null, 2)}`);\n          }\n          objectsToResolve.push({\n            id: inputValue,\n            input,\n            normalizedType: param\n          });\n          return;\n        }\n        throw new Error(`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(inputValue, null, 2)}`);\n      });\n    }));\n  }\n  if (objectsToResolve.length) {\n    const dedupedIds = [...new Set(objectsToResolve.map(_ref3 => {\n      let {\n        id\n      } = _ref3;\n      return id;\n    }))];\n    const objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n    const objects = (await Promise.all(objectChunks.map(chunk2 => expectProvider(options).multiGetObjects({\n      ids: chunk2,\n      options: {\n        showOwner: true\n      }\n    })))).flat();\n    let objectsById = new Map(dedupedIds.map((id, index) => {\n      return [id, objects[index]];\n    }));\n    const invalidObjects = Array.from(objectsById).filter(_ref4 => {\n      let [_, obj] = _ref4;\n      return obj.error;\n    }).map(_ref5 => {\n      let [id, _] = _ref5;\n      return id;\n    });\n    if (invalidObjects.length) {\n      throw new Error(`The following input objects are not invalid: ${invalidObjects.join(\", \")}`);\n    }\n    objectsToResolve.forEach(_ref6 => {\n      let {\n        id,\n        input,\n        normalizedType\n      } = _ref6;\n      const object = objectsById.get(id);\n      const initialSharedVersion = getSharedObjectInitialVersion(object);\n      if (initialSharedVersion) {\n        const mutable = isMutableSharedObjectInput(input.value) || normalizedType != null && extractMutableReference(normalizedType) != null;\n        input.value = Inputs.SharedObjectRef({\n          objectId: id,\n          initialSharedVersion,\n          mutable\n        });\n      } else {\n        input.value = Inputs.ObjectRef(getObjectReference(object));\n      }\n    });\n  }\n};\n_prepare = new WeakSet();\nprepare_fn = async function (options) {\n  if (!options.onlyTransactionKind && !__privateGet(this, _blockData).sender) {\n    throw new Error(\"Missing transaction sender\");\n  }\n  if (!options.protocolConfig && !options.limits && options.provider) {\n    options.protocolConfig = await options.provider.getProtocolConfig();\n  }\n  await Promise.all([__privateMethod(this, _prepareGasPrice, prepareGasPrice_fn).call(this, options), __privateMethod(this, _prepareTransactions, prepareTransactions_fn).call(this, options)]);\n  if (!options.onlyTransactionKind) {\n    await __privateMethod(this, _prepareGasPayment, prepareGasPayment_fn).call(this, options);\n    if (!__privateGet(this, _blockData).gasConfig.budget) {\n      const dryRunResult = await expectProvider(options).dryRunTransactionBlock({\n        transactionBlock: __privateGet(this, _blockData).build({\n          maxSizeBytes: __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxSizeBytes\", options),\n          overrides: {\n            gasConfig: {\n              budget: String(__privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxGas\", options)),\n              payment: []\n            }\n          }\n        })\n      });\n      if (dryRunResult.effects.status.status !== \"success\") {\n        throw new Error(`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`, {\n          cause: dryRunResult\n        });\n      }\n      const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n      const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n      const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);\n      this.setGasBudget(gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead);\n    }\n  }\n  __privateMethod(this, _validate, validate_fn).call(this, options);\n};\nlet TransactionBlock = _TransactionBlock;\nexport { TransactionBlock };","map":{"version":3,"names":["_blockData","_input","input_fn","_getConfig","getConfig_fn","_validate","validate_fn","_prepareGasPayment","prepareGasPayment_fn","_prepareGasPrice","prepareGasPrice_fn","_prepareTransactions","prepareTransactions_fn","_prepare","prepare_fn","fromB64","is","mask","extractMutableReference","extractStructTag","getObjectReference","getSharedObjectInitialVersion","normalizeSuiObjectId","SuiObjectRef","SUI_TYPE_ARG","Transactions","TransactionBlockInput","getTransactionType","BuilderCallArg","getIdFromCallArg","Inputs","isMutableSharedObjectInput","PureCallArg","getPureSerializationType","isTxContext","TransactionBlockDataBuilder","TRANSACTION_TYPE","create","DefaultOfflineLimits","maxPureArgumentSize","maxTxGas","maxGasObjects","maxTxSizeBytes","createTransactionResult","index","baseResult","kind","nestedResults","nestedResultFor","resultIndex","Proxy","set","Error","get","target","property","Reflect","Symbol","iterator","i","parseInt","Number","isNaN","expectProvider","options","provider","TRANSACTION_BRAND","for","LIMITS","GAS_SAFE_OVERHEAD","MAX_OBJECTS_PER_FETCH","chunk","arr","size","Array","from","length","Math","ceil","_","slice","_TransactionBlock","constructor","transaction","__privateAdd","__privateSet","blockData","obj","fromKind","serialized","tx","fromKindBytes","startsWith","fromBytes","restore","JSON","parse","setSender","sender","__privateGet","setSenderIfNotSet","setExpiration","expiration","setGasPrice","price","gasConfig","String","setGasBudget","budget","setGasOwner","owner","setGasPayment","payments","payment","map","snapshot","gas","object","value","id","inserted","inputs","find","type","__privateMethod","call","objectRef","ObjectRef","arguments","sharedObjectRef","SharedObjectRef","pure","Uint8Array","Pure","add","transactions","push","splitCoins","SplitCoins","mergeCoins","MergeCoins","publish","Publish","upgrade","Upgrade","moveCall","MoveCall","transferObjects","TransferObjects","makeMoveVec","MakeMoveVec","serialize","stringify","build","undefined","maxSizeBytes","onlyTransactionKind","getDigest","WeakMap","WeakSet","input","key","_ref","protocolConfig","limits","attribute","attributes","u64","u32","f64","forEach","gasOwner","coins","getCoins","coinType","paymentCoins","data","filter","coin","matchingInput","Object","coinObjectId","ImmOrOwned","objectId","digest","version","getReferenceGasPrice","moveModulesToResolve","objectsToResolve","needsResolution","some","arg","transactionType","schema","entries","_ref2","keySchema","isArray","wellKnownEncoding","encodeInput","arrayItem","Promise","all","packageId","moduleName","functionName","split","normalized","getNormalizedMoveFunction","package","module","function","hasTxContext","parameters","at","params","param","inputValue","serType","structVal","normalizedType","dedupedIds","Set","_ref3","objectChunks","objects","chunk2","multiGetObjects","ids","showOwner","flat","objectsById","Map","invalidObjects","_ref4","error","_ref5","join","_ref6","initialSharedVersion","mutable","getProtocolConfig","dryRunResult","dryRunTransactionBlock","transactionBlock","overrides","effects","status","cause","safeOverhead","BigInt","baseComputationCostWithOverhead","gasUsed","computationCost","gasBudget","storageCost","storageRebate","TransactionBlock"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/builder/TransactionBlock.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64 } from '@mysten/bcs';\nimport { is, mask } from 'superstruct';\nimport type { JsonRpcProvider } from '../providers/json-rpc-provider.js';\nimport type { ObjectId, SuiMoveNormalizedType, ProtocolConfig } from '../types/index.js';\nimport {\n\textractMutableReference,\n\textractStructTag,\n\tgetObjectReference,\n\tgetSharedObjectInitialVersion,\n\tnormalizeSuiObjectId,\n\tSuiObjectRef,\n\tSUI_TYPE_ARG,\n} from '../types/index.js';\nimport type { TransactionArgument, TransactionType, MoveCallTransaction } from './Transactions.js';\nimport { Transactions, TransactionBlockInput, getTransactionType } from './Transactions.js';\nimport type { ObjectCallArg } from './Inputs.js';\nimport {\n\tBuilderCallArg,\n\tgetIdFromCallArg,\n\tInputs,\n\tisMutableSharedObjectInput,\n\tPureCallArg,\n} from './Inputs.js';\nimport { getPureSerializationType, isTxContext } from './serializer.js';\nimport type { TransactionExpiration } from './TransactionBlockData.js';\nimport { TransactionBlockDataBuilder } from './TransactionBlockData.js';\nimport type { WellKnownEncoding } from './utils.js';\nimport { TRANSACTION_TYPE, create } from './utils.js';\n\ntype TransactionResult = TransactionArgument & TransactionArgument[];\n\nconst DefaultOfflineLimits = {\n\tmaxPureArgumentSize: 16 * 1024,\n\tmaxTxGas: 50_000_000_000,\n\tmaxGasObjects: 256,\n\tmaxTxSizeBytes: 128 * 1024,\n} satisfies Limits;\n\nfunction createTransactionResult(index: number): TransactionResult {\n\tconst baseResult: TransactionArgument = { kind: 'Result', index };\n\n\tconst nestedResults: TransactionArgument[] = [];\n\tconst nestedResultFor = (resultIndex: number): TransactionArgument =>\n\t\t(nestedResults[resultIndex] ??= {\n\t\t\tkind: 'NestedResult',\n\t\t\tindex,\n\t\t\tresultIndex,\n\t\t});\n\n\treturn new Proxy(baseResult, {\n\t\tset() {\n\t\t\tthrow new Error(\n\t\t\t\t'The transaction result is a proxy, and does not support setting properties directly',\n\t\t\t);\n\t\t},\n\t\t// TODO: Instead of making this return a concrete argument, we should ideally\n\t\t// make it reference-based (so that this gets resolved at build-time), which\n\t\t// allows re-ordering transactions.\n\t\tget(target, property) {\n\t\t\t// This allows this transaction argument to be used in the singular form:\n\t\t\tif (property in target) {\n\t\t\t\treturn Reflect.get(target, property);\n\t\t\t}\n\n\t\t\t// Support destructuring:\n\t\t\tif (property === Symbol.iterator) {\n\t\t\t\treturn function* () {\n\t\t\t\t\tlet i = 0;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tyield nestedResultFor(i);\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (typeof property === 'symbol') return;\n\n\t\t\tconst resultIndex = parseInt(property, 10);\n\t\t\tif (Number.isNaN(resultIndex) || resultIndex < 0) return;\n\t\t\treturn nestedResultFor(resultIndex);\n\t\t},\n\t}) as TransactionResult;\n}\n\nfunction expectProvider(options: BuildOptions): JsonRpcProvider {\n\tif (!options.provider) {\n\t\tthrow new Error(\n\t\t\t`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n\t\t);\n\t}\n\n\treturn options.provider;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction');\n\nconst LIMITS = {\n\t// The maximum gas that is allowed.\n\tmaxTxGas: 'max_tx_gas',\n\t// The maximum number of gas objects that can be selected for one transaction.\n\tmaxGasObjects: 'max_gas_payment_objects',\n\t// The maximum size (in bytes) that the transaction can be:\n\tmaxTxSizeBytes: 'max_tx_size_bytes',\n\t// The maximum size (in bytes) that pure arguments can be:\n\tmaxPureArgumentSize: 'max_pure_argument_size',\n} as const;\n\ntype Limits = Partial<Record<keyof typeof LIMITS, number>>;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\nconst chunk = <T>(arr: T[], size: number): T[][] =>\n\tArray.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n\t\tarr.slice(i * size, i * size + size),\n\t);\n\ninterface BuildOptions {\n\tprovider?: JsonRpcProvider;\n\tonlyTransactionKind?: boolean;\n\t/** Define a protocol config to build against, instead of having it fetched from the provider at build time. */\n\tprotocolConfig?: ProtocolConfig;\n\t/** Define limits that are used when building the transaction. In general, we recommend using the protocol configuration instead of defining limits. */\n\tlimits?: Limits;\n}\n\n/**\n * Transaction Builder\n */\nexport class TransactionBlock {\n\t/** Returns `true` if the object is an instance of the Transaction builder class. */\n\tstatic is(obj: unknown): obj is TransactionBlock {\n\t\treturn !!obj && typeof obj === 'object' && (obj as any)[TRANSACTION_BRAND] === true;\n\t}\n\n\t/**\n\t * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n\t * Supports either a byte array, or base64-encoded bytes.\n\t */\n\tstatic fromKind(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\ttx.#blockData = TransactionBlockDataBuilder.fromKindBytes(\n\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t);\n\n\t\treturn tx;\n\t}\n\n\t/**\n\t * Converts from a serialized transaction format to a `Transaction` class.\n\t * There are two supported serialized formats:\n\t * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n\t * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n\t */\n\tstatic from(serialized: string | Uint8Array) {\n\t\tconst tx = new TransactionBlock();\n\n\t\t// Check for bytes:\n\t\tif (typeof serialized !== 'string' || !serialized.startsWith('{')) {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.fromBytes(\n\t\t\t\ttypeof serialized === 'string' ? fromB64(serialized) : serialized,\n\t\t\t);\n\t\t} else {\n\t\t\ttx.#blockData = TransactionBlockDataBuilder.restore(JSON.parse(serialized));\n\t\t}\n\n\t\treturn tx;\n\t}\n\n\t/** A helper to retrieve the Transaction builder `Transactions` */\n\tstatic get Transactions() {\n\t\treturn Transactions;\n\t}\n\n\t/** A helper to retrieve the Transaction builder `Inputs` */\n\tstatic get Inputs() {\n\t\treturn Inputs;\n\t}\n\n\tsetSender(sender: string) {\n\t\tthis.#blockData.sender = sender;\n\t}\n\t/**\n\t * Sets the sender only if it has not already been set.\n\t * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n\t */\n\tsetSenderIfNotSet(sender: string) {\n\t\tif (!this.#blockData.sender) {\n\t\t\tthis.#blockData.sender = sender;\n\t\t}\n\t}\n\tsetExpiration(expiration?: TransactionExpiration) {\n\t\tthis.#blockData.expiration = expiration;\n\t}\n\tsetGasPrice(price: number | bigint) {\n\t\tthis.#blockData.gasConfig.price = String(price);\n\t}\n\tsetGasBudget(budget: number | bigint) {\n\t\tthis.#blockData.gasConfig.budget = String(budget);\n\t}\n\tsetGasOwner(owner: string) {\n\t\tthis.#blockData.gasConfig.owner = owner;\n\t}\n\tsetGasPayment(payments: SuiObjectRef[]) {\n\t\tthis.#blockData.gasConfig.payment = payments.map((payment) => mask(payment, SuiObjectRef));\n\t}\n\n\t#blockData: TransactionBlockDataBuilder;\n\t/** Get a snapshot of the transaction data, in JSON form: */\n\tget blockData() {\n\t\treturn this.#blockData.snapshot();\n\t}\n\n\t// Used to brand transaction classes so that they can be identified, even between multiple copies\n\t// of the builder.\n\tget [TRANSACTION_BRAND]() {\n\t\treturn true;\n\t}\n\n\tconstructor(transaction?: TransactionBlock) {\n\t\tthis.#blockData = new TransactionBlockDataBuilder(\n\t\t\ttransaction ? transaction.blockData : undefined,\n\t\t);\n\t}\n\n\t/** Returns an argument for the gas coin, to be used in a transaction. */\n\tget gas(): TransactionArgument {\n\t\treturn { kind: 'GasCoin' };\n\t}\n\n\t/**\n\t * Dynamically create a new input, which is separate from the `input`. This is important\n\t * for generated clients to be able to define unique inputs that are non-overlapping with the\n\t * defined inputs.\n\t *\n\t * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n\t * is the format required for custom serialization.\n\t *\n\t */\n\t#input(type: 'object' | 'pure', value?: unknown) {\n\t\tconst index = this.#blockData.inputs.length;\n\t\tconst input = create(\n\t\t\t{\n\t\t\t\tkind: 'Input',\n\t\t\t\t// bigints can't be serialized to JSON, so just string-convert them here:\n\t\t\t\tvalue: typeof value === 'bigint' ? String(value) : value,\n\t\t\t\tindex,\n\t\t\t\ttype,\n\t\t\t},\n\t\t\tTransactionBlockInput,\n\t\t);\n\t\tthis.#blockData.inputs.push(input);\n\t\treturn input;\n\t}\n\n\t/**\n\t * Add a new object input to the transaction.\n\t */\n\tobject(value: ObjectId | ObjectCallArg) {\n\t\tconst id = getIdFromCallArg(value);\n\t\t// deduplicate\n\t\tconst inserted = this.#blockData.inputs.find(\n\t\t\t(i) => i.type === 'object' && id === getIdFromCallArg(i.value),\n\t\t);\n\t\treturn inserted ?? this.#input('object', value);\n\t}\n\n\t/**\n\t * Add a new object input to the transaction using the fully-resolved object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tobjectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n\t\treturn this.object(Inputs.ObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n\t * If you only have an object ID, use `builder.object(id)` instead.\n\t */\n\tsharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n\t\treturn this.object(Inputs.SharedObjectRef(...args));\n\t}\n\n\t/**\n\t * Add a new non-object input to the transaction.\n\t */\n\tpure(\n\t\t/**\n\t\t * The pure value that will be used as the input value. If this is a Uint8Array, then the value\n\t\t * is assumed to be raw bytes, and will be used directly.\n\t\t */\n\t\tvalue: unknown,\n\t\t/**\n\t\t * The BCS type to serialize the value into. If not provided, the type will automatically be determined\n\t\t * based on how the input is used.\n\t\t */\n\t\ttype?: string,\n\t) {\n\t\t// TODO: we can also do some deduplication here\n\t\treturn this.#input(\n\t\t\t'pure',\n\t\t\tvalue instanceof Uint8Array ? Inputs.Pure(value) : type ? Inputs.Pure(value, type) : value,\n\t\t);\n\t}\n\n\t/** Add a transaction to the transaction block. */\n\tadd(transaction: TransactionType) {\n\t\tconst index = this.#blockData.transactions.push(transaction);\n\t\treturn createTransactionResult(index - 1);\n\t}\n\n\t// Method shorthands:\n\n\tsplitCoins(...args: Parameters<(typeof Transactions)['SplitCoins']>) {\n\t\treturn this.add(Transactions.SplitCoins(...args));\n\t}\n\tmergeCoins(...args: Parameters<(typeof Transactions)['MergeCoins']>) {\n\t\treturn this.add(Transactions.MergeCoins(...args));\n\t}\n\tpublish(...args: Parameters<(typeof Transactions)['Publish']>) {\n\t\treturn this.add(Transactions.Publish(...args));\n\t}\n\tupgrade(...args: Parameters<(typeof Transactions)['Upgrade']>) {\n\t\treturn this.add(Transactions.Upgrade(...args));\n\t}\n\tmoveCall(...args: Parameters<(typeof Transactions)['MoveCall']>) {\n\t\treturn this.add(Transactions.MoveCall(...args));\n\t}\n\ttransferObjects(...args: Parameters<(typeof Transactions)['TransferObjects']>) {\n\t\treturn this.add(Transactions.TransferObjects(...args));\n\t}\n\tmakeMoveVec(...args: Parameters<(typeof Transactions)['MakeMoveVec']>) {\n\t\treturn this.add(Transactions.MakeMoveVec(...args));\n\t}\n\n\t/**\n\t * Serialize the transaction to a string so that it can be sent to a separate context.\n\t * This is different from `build` in that it does not serialize to BCS bytes, and instead\n\t * uses a separate format that is unique to the transaction builder. This allows\n\t * us to serialize partially-complete transactions, that can then be completed and\n\t * built in a separate context.\n\t *\n\t * For example, a dapp can construct a transaction, but not provide gas objects\n\t * or a gas budget. The transaction then can be sent to the wallet, where this\n\t * information is automatically filled in (e.g. by querying for coin objects\n\t * and performing a dry run).\n\t */\n\tserialize() {\n\t\treturn JSON.stringify(this.#blockData.snapshot());\n\t}\n\n\t#getConfig(key: keyof typeof LIMITS, { protocolConfig, limits }: BuildOptions) {\n\t\t// Use the limits definition if that exists:\n\t\tif (limits && typeof limits[key] === 'number') {\n\t\t\treturn limits[key]!;\n\t\t}\n\n\t\tif (!protocolConfig) {\n\t\t\treturn DefaultOfflineLimits[key];\n\t\t}\n\n\t\t// Fallback to protocol config:\n\t\tconst attribute = protocolConfig?.attributes[LIMITS[key]];\n\t\tif (!attribute) {\n\t\t\tthrow new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\tconst value =\n\t\t\t'u64' in attribute ? attribute.u64 : 'u32' in attribute ? attribute.u32 : attribute.f64;\n\n\t\tif (!value) {\n\t\t\tthrow new Error(`Unexpected protocol config value found for: \"${LIMITS[key]}\"`);\n\t\t}\n\n\t\t// NOTE: Technically this is not a safe conversion, but we know all of the values in protocol config are safe\n\t\treturn Number(value);\n\t}\n\n\t/** Build the transaction to BCS bytes. */\n\tasync build(options: BuildOptions = {}): Promise<Uint8Array> {\n\t\tawait this.#prepare(options);\n\t\treturn this.#blockData.build({\n\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\tonlyTransactionKind: options.onlyTransactionKind,\n\t\t});\n\t}\n\n\t/** Derive transaction digest */\n\tasync getDigest({\n\t\tprovider,\n\t}: {\n\t\tprovider?: JsonRpcProvider;\n\t} = {}): Promise<string> {\n\t\tawait this.#prepare({ provider });\n\t\treturn this.#blockData.getDigest();\n\t}\n\n\t#validate(options: BuildOptions) {\n\t\tconst maxPureArgumentSize = this.#getConfig('maxPureArgumentSize', options);\n\t\t// Validate all inputs are the correct size:\n\t\tthis.#blockData.inputs.forEach((input, index) => {\n\t\t\tif (is(input.value, PureCallArg)) {\n\t\t\t\tif (input.value.Pure.length > maxPureArgumentSize) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t// The current default is just picking _all_ coins we can which may not be ideal.\n\tasync #prepareGasPayment(options: BuildOptions) {\n\t\tif (this.#blockData.gasConfig.payment) {\n\t\t\tconst maxGasObjects = this.#getConfig('maxGasObjects', options);\n\t\t\tif (this.#blockData.gasConfig.payment.length > maxGasObjects) {\n\t\t\t\tthrow new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);\n\t\t\t}\n\t\t}\n\n\t\t// Early return if the payment is already set:\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.payment) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst gasOwner = this.#blockData.gasConfig.owner ?? this.#blockData.sender;\n\n\t\tconst coins = await expectProvider(options).getCoins({\n\t\t\towner: gasOwner!,\n\t\t\tcoinType: SUI_TYPE_ARG,\n\t\t});\n\n\t\tconst paymentCoins = coins.data\n\t\t\t// Filter out coins that are also used as input:\n\t\t\t.filter((coin) => {\n\t\t\t\tconst matchingInput = this.#blockData.inputs.find((input) => {\n\t\t\t\t\tif (\n\t\t\t\t\t\tis(input.value, BuilderCallArg) &&\n\t\t\t\t\t\t'Object' in input.value &&\n\t\t\t\t\t\t'ImmOrOwned' in input.value.Object\n\t\t\t\t\t) {\n\t\t\t\t\t\treturn coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\n\t\t\t\treturn !matchingInput;\n\t\t\t})\n\t\t\t.slice(0, this.#getConfig('maxGasObjects', options) - 1)\n\t\t\t.map((coin) => ({\n\t\t\t\tobjectId: coin.coinObjectId,\n\t\t\t\tdigest: coin.digest,\n\t\t\t\tversion: coin.version,\n\t\t\t}));\n\n\t\tif (!paymentCoins.length) {\n\t\t\tthrow new Error('No valid gas coins found for the transaction.');\n\t\t}\n\n\t\tthis.setGasPayment(paymentCoins);\n\t}\n\n\tasync #prepareGasPrice(options: BuildOptions) {\n\t\tif (options.onlyTransactionKind || this.#blockData.gasConfig.price) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.setGasPrice(await expectProvider(options).getReferenceGasPrice());\n\t}\n\n\tasync #prepareTransactions(options: BuildOptions) {\n\t\tconst { inputs, transactions } = this.#blockData;\n\n\t\tconst moveModulesToResolve: MoveCallTransaction[] = [];\n\n\t\t// Keep track of the object references that will need to be resolved at the end of the transaction.\n\t\t// We keep the input by-reference to avoid needing to re-resolve it:\n\t\tconst objectsToResolve: {\n\t\t\tid: string;\n\t\t\tinput: TransactionBlockInput;\n\t\t\tnormalizedType?: SuiMoveNormalizedType;\n\t\t}[] = [];\n\n\t\ttransactions.forEach((transaction) => {\n\t\t\t// Special case move call:\n\t\t\tif (transaction.kind === 'MoveCall') {\n\t\t\t\t// Determine if any of the arguments require encoding.\n\t\t\t\t// - If they don't, then this is good to go.\n\t\t\t\t// - If they do, then we need to fetch the normalized move module.\n\t\t\t\tconst needsResolution = transaction.arguments.some(\n\t\t\t\t\t(arg) => arg.kind === 'Input' && !is(inputs[arg.index].value, BuilderCallArg),\n\t\t\t\t);\n\n\t\t\t\tif (needsResolution) {\n\t\t\t\t\tmoveModulesToResolve.push(transaction);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Get the matching struct definition for the transaction, and use it to attempt to automatically\n\t\t\t// encode the matching inputs.\n\t\t\tconst transactionType = getTransactionType(transaction);\n\t\t\tif (!transactionType.schema) return;\n\n\t\t\tObject.entries(transaction).forEach(([key, value]) => {\n\t\t\t\tif (key === 'kind') return;\n\t\t\t\tconst keySchema = (transactionType.schema as any)[key];\n\t\t\t\tconst isArray = keySchema.type === 'array';\n\t\t\t\tconst wellKnownEncoding: WellKnownEncoding = isArray\n\t\t\t\t\t? keySchema.schema[TRANSACTION_TYPE]\n\t\t\t\t\t: keySchema[TRANSACTION_TYPE];\n\n\t\t\t\t// This argument has unknown encoding, assume it must be fully-encoded:\n\t\t\t\tif (!wellKnownEncoding) return;\n\n\t\t\t\tconst encodeInput = (index: number) => {\n\t\t\t\t\tconst input = inputs[index];\n\t\t\t\t\tif (!input) {\n\t\t\t\t\t\tthrow new Error(`Missing input ${value.index}`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Input is fully resolved:\n\t\t\t\t\tif (is(input.value, BuilderCallArg)) return;\n\t\t\t\t\tif (wellKnownEncoding.kind === 'object' && typeof input.value === 'string') {\n\t\t\t\t\t\t// The input is a string that we need to resolve to an object reference:\n\t\t\t\t\t\tobjectsToResolve.push({ id: input.value, input });\n\t\t\t\t\t} else if (wellKnownEncoding.kind === 'pure') {\n\t\t\t\t\t\t// Pure encoding, so construct BCS bytes:\n\t\t\t\t\t\tinput.value = Inputs.Pure(input.value, wellKnownEncoding.type);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error('Unexpected input format.');\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tif (isArray) {\n\t\t\t\t\tvalue.forEach((arrayItem: TransactionArgument) => {\n\t\t\t\t\t\tif (arrayItem.kind !== 'Input') return;\n\t\t\t\t\t\tencodeInput(arrayItem.index);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tif (value.kind !== 'Input') return;\n\t\t\t\t\tencodeInput(value.index);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\tif (moveModulesToResolve.length) {\n\t\t\tawait Promise.all(\n\t\t\t\tmoveModulesToResolve.map(async (moveCall) => {\n\t\t\t\t\tconst [packageId, moduleName, functionName] = moveCall.target.split('::');\n\n\t\t\t\t\tconst normalized = await expectProvider(options).getNormalizedMoveFunction({\n\t\t\t\t\t\tpackage: normalizeSuiObjectId(packageId),\n\t\t\t\t\t\tmodule: moduleName,\n\t\t\t\t\t\tfunction: functionName,\n\t\t\t\t\t});\n\n\t\t\t\t\t// Entry functions can have a mutable reference to an instance of the TxContext\n\t\t\t\t\t// struct defined in the TxContext module as the last parameter. The caller of\n\t\t\t\t\t// the function does not need to pass it in as an argument.\n\t\t\t\t\tconst hasTxContext =\n\t\t\t\t\t\tnormalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1)!);\n\n\t\t\t\t\tconst params = hasTxContext\n\t\t\t\t\t\t? normalized.parameters.slice(0, normalized.parameters.length - 1)\n\t\t\t\t\t\t: normalized.parameters;\n\n\t\t\t\t\tif (params.length !== moveCall.arguments.length) {\n\t\t\t\t\t\tthrow new Error('Incorrect number of arguments.');\n\t\t\t\t\t}\n\n\t\t\t\t\tparams.forEach((param, i) => {\n\t\t\t\t\t\tconst arg = moveCall.arguments[i];\n\t\t\t\t\t\tif (arg.kind !== 'Input') return;\n\t\t\t\t\t\tconst input = inputs[arg.index];\n\t\t\t\t\t\t// Skip if the input is already resolved\n\t\t\t\t\t\tif (is(input.value, BuilderCallArg)) return;\n\n\t\t\t\t\t\tconst inputValue = input.value;\n\n\t\t\t\t\t\tconst serType = getPureSerializationType(param, inputValue);\n\n\t\t\t\t\t\tif (serType) {\n\t\t\t\t\t\t\tinput.value = Inputs.Pure(inputValue, serType);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst structVal = extractStructTag(param);\n\t\t\t\t\t\tif (structVal != null || (typeof param === 'object' && 'TypeParameter' in param)) {\n\t\t\t\t\t\t\tif (typeof inputValue !== 'string') {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t`Expect the argument to be an object id string, got ${JSON.stringify(\n\t\t\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tobjectsToResolve.push({\n\t\t\t\t\t\t\t\tid: inputValue,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tnormalizedType: param,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(\n\t\t\t\t\t\t\t\tinputValue,\n\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t2,\n\t\t\t\t\t\t\t)}`,\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t}),\n\t\t\t);\n\t\t}\n\n\t\tif (objectsToResolve.length) {\n\t\t\tconst dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];\n\t\t\tconst objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n\t\t\tconst objects = (\n\t\t\t\tawait Promise.all(\n\t\t\t\t\tobjectChunks.map((chunk) =>\n\t\t\t\t\t\texpectProvider(options).multiGetObjects({\n\t\t\t\t\t\t\tids: chunk,\n\t\t\t\t\t\t\toptions: { showOwner: true },\n\t\t\t\t\t\t}),\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t).flat();\n\n\t\t\tlet objectsById = new Map(\n\t\t\t\tdedupedIds.map((id, index) => {\n\t\t\t\t\treturn [id, objects[index]];\n\t\t\t\t}),\n\t\t\t);\n\n\t\t\tconst invalidObjects = Array.from(objectsById)\n\t\t\t\t.filter(([_, obj]) => obj.error)\n\t\t\t\t.map(([id, _]) => id);\n\t\t\tif (invalidObjects.length) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`The following input objects are not invalid: ${invalidObjects.join(', ')}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tobjectsToResolve.forEach(({ id, input, normalizedType }) => {\n\t\t\t\tconst object = objectsById.get(id)!;\n\t\t\t\tconst initialSharedVersion = getSharedObjectInitialVersion(object);\n\n\t\t\t\tif (initialSharedVersion) {\n\t\t\t\t\t// There could be multiple transactions that reference the same shared object.\n\t\t\t\t\t// If one of them is a mutable reference, then we should mark the input\n\t\t\t\t\t// as mutable.\n\t\t\t\t\tconst mutable =\n\t\t\t\t\t\tisMutableSharedObjectInput(input.value) ||\n\t\t\t\t\t\t(normalizedType != null && extractMutableReference(normalizedType) != null);\n\n\t\t\t\t\tinput.value = Inputs.SharedObjectRef({\n\t\t\t\t\t\tobjectId: id,\n\t\t\t\t\t\tinitialSharedVersion,\n\t\t\t\t\t\tmutable,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tinput.value = Inputs.ObjectRef(getObjectReference(object)!);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Prepare the transaction by valdiating the transaction data and resolving all inputs\n\t * so that it can be built into bytes.\n\t */\n\tasync #prepare(options: BuildOptions) {\n\t\tif (!options.onlyTransactionKind && !this.#blockData.sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!options.protocolConfig && !options.limits && options.provider) {\n\t\t\toptions.protocolConfig = await options.provider.getProtocolConfig();\n\t\t}\n\n\t\tawait Promise.all([this.#prepareGasPrice(options), this.#prepareTransactions(options)]);\n\n\t\tif (!options.onlyTransactionKind) {\n\t\t\tawait this.#prepareGasPayment(options);\n\n\t\t\tif (!this.#blockData.gasConfig.budget) {\n\t\t\t\tconst dryRunResult = await expectProvider(options).dryRunTransactionBlock({\n\t\t\t\t\ttransactionBlock: this.#blockData.build({\n\t\t\t\t\t\tmaxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n\t\t\t\t\t\toverrides: {\n\t\t\t\t\t\t\tgasConfig: {\n\t\t\t\t\t\t\t\tbudget: String(this.#getConfig('maxTxGas', options)),\n\t\t\t\t\t\t\t\tpayment: [],\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t}),\n\t\t\t\t});\n\t\t\t\tif (dryRunResult.effects.status.status !== 'success') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n\t\t\t\t\t\t{ cause: dryRunResult },\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n\n\t\t\t\tconst baseComputationCostWithOverhead =\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n\t\t\t\tconst gasBudget =\n\t\t\t\t\tbaseComputationCostWithOverhead +\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageCost) -\n\t\t\t\t\tBigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n\t\t\t\t// Set the budget to max(computation, computation + storage - rebate)\n\t\t\t\tthis.setGasBudget(\n\t\t\t\t\tgasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// Perform final validation on the transaction:\n\t\tthis.#validate(options);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}