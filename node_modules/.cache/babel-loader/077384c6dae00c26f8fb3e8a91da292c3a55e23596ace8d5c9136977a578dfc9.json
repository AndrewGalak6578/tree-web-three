{"ast":null,"code":"import { fromB64, toB64 } from \"@mysten/bcs\";\nimport { TransactionBlock } from \"../builder/index.js\";\nimport { TransactionBlockDataBuilder } from \"../builder/TransactionBlockData.js\";\nimport { getTotalGasUsedUpperBound } from \"../types/index.js\";\nimport { IntentScope, messageWithIntent } from \"../utils/intent.js\";\nclass SignerWithProvider {\n  ///////////////////\n  // Sub-classes MAY override these\n  /**\n   * Request gas tokens from a faucet server and send to the signer\n   * address\n   * @param httpHeaders optional request headers\n   */\n  async requestSuiFromFaucet(httpHeaders) {\n    return this.provider.requestSuiFromFaucet(await this.getAddress(), httpHeaders);\n  }\n  constructor(provider) {\n    this.provider = provider;\n  }\n  /**\n   * Sign a message using the keypair, with the `PersonalMessage` intent.\n   */\n  async signMessage(input) {\n    const signature = await this.signData(messageWithIntent(IntentScope.PersonalMessage, input.message));\n    return {\n      messageBytes: toB64(input.message),\n      signature\n    };\n  }\n  async prepareTransactionBlock(transactionBlock) {\n    if (TransactionBlock.is(transactionBlock)) {\n      transactionBlock.setSenderIfNotSet(await this.getAddress());\n      return await transactionBlock.build({\n        provider: this.provider\n      });\n    }\n    if (transactionBlock instanceof Uint8Array) {\n      return transactionBlock;\n    }\n    throw new Error(\"Unknown transaction format\");\n  }\n  /**\n   * Sign a transaction.\n   */\n  async signTransactionBlock(input) {\n    const transactionBlockBytes = await this.prepareTransactionBlock(input.transactionBlock);\n    const intentMessage = messageWithIntent(IntentScope.TransactionData, transactionBlockBytes);\n    const signature = await this.signData(intentMessage);\n    return {\n      transactionBlockBytes: toB64(transactionBlockBytes),\n      signature\n    };\n  }\n  /**\n   * Sign a transaction block and submit to the Fullnode for execution.\n   *\n   * @param options specify which fields to return (e.g., transaction, effects, events, etc).\n   * By default, only the transaction digest will be returned.\n   * @param requestType WaitForEffectsCert or WaitForLocalExecution, see details in `ExecuteTransactionRequestType`.\n   * Defaults to `WaitForLocalExecution` if options.show_effects or options.show_events is true\n   */\n  async signAndExecuteTransactionBlock(input) {\n    const {\n      transactionBlockBytes,\n      signature\n    } = await this.signTransactionBlock({\n      transactionBlock: input.transactionBlock\n    });\n    return await this.provider.executeTransactionBlock({\n      transactionBlock: transactionBlockBytes,\n      signature,\n      options: input.options,\n      requestType: input.requestType\n    });\n  }\n  /**\n   * Derive transaction digest from\n   * @param tx BCS serialized transaction data or a `Transaction` object\n   * @returns transaction digest\n   */\n  async getTransactionBlockDigest(tx) {\n    if (TransactionBlock.is(tx)) {\n      tx.setSenderIfNotSet(await this.getAddress());\n      return tx.getDigest({\n        provider: this.provider\n      });\n    } else if (tx instanceof Uint8Array) {\n      return TransactionBlockDataBuilder.getDigestFromBytes(tx);\n    } else {\n      throw new Error(\"Unknown transaction format.\");\n    }\n  }\n  /**\n   * Runs the transaction in dev-inpsect mode. Which allows for nearly any\n   * transaction (or Move call) with any arguments. Detailed results are\n   * provided, including both the transaction effects and any return values.\n   */\n  async devInspectTransactionBlock(input) {\n    const address = await this.getAddress();\n    return this.provider.devInspectTransactionBlock({\n      sender: address,\n      ...input\n    });\n  }\n  /**\n   * Dry run a transaction and return the result.\n   */\n  async dryRunTransactionBlock(input) {\n    let dryRunTxBytes;\n    if (TransactionBlock.is(input.transactionBlock)) {\n      input.transactionBlock.setSenderIfNotSet(await this.getAddress());\n      dryRunTxBytes = await input.transactionBlock.build({\n        provider: this.provider\n      });\n    } else if (typeof input.transactionBlock === \"string\") {\n      dryRunTxBytes = fromB64(input.transactionBlock);\n    } else if (input.transactionBlock instanceof Uint8Array) {\n      dryRunTxBytes = input.transactionBlock;\n    } else {\n      throw new Error(\"Unknown transaction format\");\n    }\n    return this.provider.dryRunTransactionBlock({\n      transactionBlock: dryRunTxBytes\n    });\n  }\n  /**\n   * Returns the estimated gas cost for the transaction\n   * @param tx The transaction to estimate the gas cost. When string it is assumed it's a serialized tx in base64\n   * @returns total gas cost estimation\n   * @throws whens fails to estimate the gas cost\n   */\n  async getGasCostEstimation() {\n    const txEffects = await this.dryRunTransactionBlock(...arguments);\n    const gasEstimation = getTotalGasUsedUpperBound(txEffects.effects);\n    if (typeof gasEstimation === \"undefined\") {\n      throw new Error(\"Failed to estimate the gas cost from transaction\");\n    }\n    return gasEstimation;\n  }\n}\nexport { SignerWithProvider };","map":{"version":3,"names":["fromB64","toB64","TransactionBlock","TransactionBlockDataBuilder","getTotalGasUsedUpperBound","IntentScope","messageWithIntent","SignerWithProvider","requestSuiFromFaucet","httpHeaders","provider","getAddress","constructor","signMessage","input","signature","signData","PersonalMessage","message","messageBytes","prepareTransactionBlock","transactionBlock","is","setSenderIfNotSet","build","Uint8Array","Error","signTransactionBlock","transactionBlockBytes","intentMessage","TransactionData","signAndExecuteTransactionBlock","executeTransactionBlock","options","requestType","getTransactionBlockDigest","tx","getDigest","getDigestFromBytes","devInspectTransactionBlock","address","sender","dryRunTransactionBlock","dryRunTxBytes","getGasCostEstimation","txEffects","arguments","gasEstimation","effects"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/signers/signer-with-provider.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@mysten/bcs';\nimport { TransactionBlock } from '../builder/index.js';\nimport { TransactionBlockDataBuilder } from '../builder/TransactionBlockData.js';\nimport type { SerializedSignature } from '../cryptography/signature.js';\nimport type { JsonRpcProvider } from '../providers/json-rpc-provider.js';\nimport type { HttpHeaders } from '../rpc/client.js';\nimport type {\n\tExecuteTransactionRequestType,\n\tFaucetResponse,\n\tSuiAddress,\n\tDevInspectResults,\n\tDryRunTransactionBlockResponse,\n\tSuiTransactionBlockResponse,\n\tSuiTransactionBlockResponseOptions,\n} from '../types/index.js';\nimport { getTotalGasUsedUpperBound } from '../types/index.js';\nimport { IntentScope, messageWithIntent } from '../utils/intent.js';\nimport type { Signer } from './signer.js';\nimport type { SignedTransaction, SignedMessage } from './types.js';\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class SignerWithProvider implements Signer {\n\treadonly provider: JsonRpcProvider;\n\n\t///////////////////\n\t// Sub-classes MUST implement these\n\n\t// Returns the checksum address\n\tabstract getAddress(): Promise<SuiAddress>;\n\n\t/**\n\t * Returns the signature for the data and the public key of the signer\n\t */\n\tabstract signData(data: Uint8Array): Promise<SerializedSignature>;\n\n\t// Returns a new instance of the Signer, connected to provider.\n\t// This MAY throw if changing providers is not supported.\n\tabstract connect(provider: JsonRpcProvider): SignerWithProvider;\n\n\t///////////////////\n\t// Sub-classes MAY override these\n\n\t/**\n\t * Request gas tokens from a faucet server and send to the signer\n\t * address\n\t * @param httpHeaders optional request headers\n\t */\n\tasync requestSuiFromFaucet(httpHeaders?: HttpHeaders): Promise<FaucetResponse> {\n\t\treturn this.provider.requestSuiFromFaucet(await this.getAddress(), httpHeaders);\n\t}\n\n\tconstructor(provider: JsonRpcProvider) {\n\t\tthis.provider = provider;\n\t}\n\n\t/**\n\t * Sign a message using the keypair, with the `PersonalMessage` intent.\n\t */\n\tasync signMessage(input: { message: Uint8Array }): Promise<SignedMessage> {\n\t\tconst signature = await this.signData(\n\t\t\tmessageWithIntent(IntentScope.PersonalMessage, input.message),\n\t\t);\n\n\t\treturn {\n\t\t\tmessageBytes: toB64(input.message),\n\t\t\tsignature,\n\t\t};\n\t}\n\n\tprotected async prepareTransactionBlock(transactionBlock: Uint8Array | TransactionBlock) {\n\t\tif (TransactionBlock.is(transactionBlock)) {\n\t\t\t// If the sender has not yet been set on the transaction, then set it.\n\t\t\t// NOTE: This allows for signing transactions with mis-matched senders, which is important for sponsored transactions.\n\t\t\ttransactionBlock.setSenderIfNotSet(await this.getAddress());\n\t\t\treturn await transactionBlock.build({\n\t\t\t\tprovider: this.provider,\n\t\t\t});\n\t\t}\n\t\tif (transactionBlock instanceof Uint8Array) {\n\t\t\treturn transactionBlock;\n\t\t}\n\t\tthrow new Error('Unknown transaction format');\n\t}\n\n\t/**\n\t * Sign a transaction.\n\t */\n\tasync signTransactionBlock(input: {\n\t\ttransactionBlock: Uint8Array | TransactionBlock;\n\t}): Promise<SignedTransaction> {\n\t\tconst transactionBlockBytes = await this.prepareTransactionBlock(input.transactionBlock);\n\n\t\tconst intentMessage = messageWithIntent(IntentScope.TransactionData, transactionBlockBytes);\n\t\tconst signature = await this.signData(intentMessage);\n\n\t\treturn {\n\t\t\ttransactionBlockBytes: toB64(transactionBlockBytes),\n\t\t\tsignature,\n\t\t};\n\t}\n\n\t/**\n\t * Sign a transaction block and submit to the Fullnode for execution.\n\t *\n\t * @param options specify which fields to return (e.g., transaction, effects, events, etc).\n\t * By default, only the transaction digest will be returned.\n\t * @param requestType WaitForEffectsCert or WaitForLocalExecution, see details in `ExecuteTransactionRequestType`.\n\t * Defaults to `WaitForLocalExecution` if options.show_effects or options.show_events is true\n\t */\n\tasync signAndExecuteTransactionBlock(input: {\n\t\ttransactionBlock: Uint8Array | TransactionBlock;\n\t\t/** specify which fields to return (e.g., transaction, effects, events, etc). By default, only the transaction digest will be returned. */\n\t\toptions?: SuiTransactionBlockResponseOptions;\n\t\t/** `WaitForEffectsCert` or `WaitForLocalExecution`, see details in `ExecuteTransactionRequestType`.\n\t\t * Defaults to `WaitForLocalExecution` if options.show_effects or options.show_events is true\n\t\t */\n\t\trequestType?: ExecuteTransactionRequestType;\n\t}): Promise<SuiTransactionBlockResponse> {\n\t\tconst { transactionBlockBytes, signature } = await this.signTransactionBlock({\n\t\t\ttransactionBlock: input.transactionBlock,\n\t\t});\n\n\t\treturn await this.provider.executeTransactionBlock({\n\t\t\ttransactionBlock: transactionBlockBytes,\n\t\t\tsignature,\n\t\t\toptions: input.options,\n\t\t\trequestType: input.requestType,\n\t\t});\n\t}\n\n\t/**\n\t * Derive transaction digest from\n\t * @param tx BCS serialized transaction data or a `Transaction` object\n\t * @returns transaction digest\n\t */\n\tasync getTransactionBlockDigest(tx: Uint8Array | TransactionBlock): Promise<string> {\n\t\tif (TransactionBlock.is(tx)) {\n\t\t\ttx.setSenderIfNotSet(await this.getAddress());\n\t\t\treturn tx.getDigest({ provider: this.provider });\n\t\t} else if (tx instanceof Uint8Array) {\n\t\t\treturn TransactionBlockDataBuilder.getDigestFromBytes(tx);\n\t\t} else {\n\t\t\tthrow new Error('Unknown transaction format.');\n\t\t}\n\t}\n\n\t/**\n\t * Runs the transaction in dev-inpsect mode. Which allows for nearly any\n\t * transaction (or Move call) with any arguments. Detailed results are\n\t * provided, including both the transaction effects and any return values.\n\t */\n\tasync devInspectTransactionBlock(\n\t\tinput: Omit<Parameters<JsonRpcProvider['devInspectTransactionBlock']>[0], 'sender'>,\n\t): Promise<DevInspectResults> {\n\t\tconst address = await this.getAddress();\n\t\treturn this.provider.devInspectTransactionBlock({\n\t\t\tsender: address,\n\t\t\t...input,\n\t\t});\n\t}\n\n\t/**\n\t * Dry run a transaction and return the result.\n\t */\n\tasync dryRunTransactionBlock(input: {\n\t\ttransactionBlock: TransactionBlock | string | Uint8Array;\n\t}): Promise<DryRunTransactionBlockResponse> {\n\t\tlet dryRunTxBytes: Uint8Array;\n\t\tif (TransactionBlock.is(input.transactionBlock)) {\n\t\t\tinput.transactionBlock.setSenderIfNotSet(await this.getAddress());\n\t\t\tdryRunTxBytes = await input.transactionBlock.build({\n\t\t\t\tprovider: this.provider,\n\t\t\t});\n\t\t} else if (typeof input.transactionBlock === 'string') {\n\t\t\tdryRunTxBytes = fromB64(input.transactionBlock);\n\t\t} else if (input.transactionBlock instanceof Uint8Array) {\n\t\t\tdryRunTxBytes = input.transactionBlock;\n\t\t} else {\n\t\t\tthrow new Error('Unknown transaction format');\n\t\t}\n\n\t\treturn this.provider.dryRunTransactionBlock({\n\t\t\ttransactionBlock: dryRunTxBytes,\n\t\t});\n\t}\n\n\t/**\n\t * Returns the estimated gas cost for the transaction\n\t * @param tx The transaction to estimate the gas cost. When string it is assumed it's a serialized tx in base64\n\t * @returns total gas cost estimation\n\t * @throws whens fails to estimate the gas cost\n\t */\n\tasync getGasCostEstimation(...args: Parameters<SignerWithProvider['dryRunTransactionBlock']>) {\n\t\tconst txEffects = await this.dryRunTransactionBlock(...args);\n\t\tconst gasEstimation = getTotalGasUsedUpperBound(txEffects.effects);\n\t\tif (typeof gasEstimation === 'undefined') {\n\t\t\tthrow new Error('Failed to estimate the gas cost from transaction');\n\t\t}\n\t\treturn gasEstimation;\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}