{"ast":null,"code":"// src/b64.ts\nfunction b64ToUint6(nChr) {\n  return nChr > 64 && nChr < 91 ? nChr - 65 : nChr > 96 && nChr < 123 ? nChr - 71 : nChr > 47 && nChr < 58 ? nChr + 4 : nChr === 43 ? 62 : nChr === 47 ? 63 : 0;\n}\nfunction fromB64(sBase64, nBlocksSize) {\n  var sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, \"\"),\n    nInLen = sB64Enc.length,\n    nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2,\n    taBytes = new Uint8Array(nOutLen);\n  for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n    nMod4 = nInIdx & 3;\n    nUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 6 * (3 - nMod4);\n    if (nMod4 === 3 || nInLen - nInIdx === 1) {\n      for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n        taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;\n      }\n      nUint24 = 0;\n    }\n  }\n  return taBytes;\n}\nfunction uint6ToB64(nUint6) {\n  return nUint6 < 26 ? nUint6 + 65 : nUint6 < 52 ? nUint6 + 71 : nUint6 < 62 ? nUint6 - 4 : nUint6 === 62 ? 43 : nUint6 === 63 ? 47 : 65;\n}\nfunction toB64(aBytes) {\n  var nMod3 = 2,\n    sB64Enc = \"\";\n  for (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n    nMod3 = nIdx % 3;\n    nUint24 |= aBytes[nIdx] << (16 >>> nMod3 & 24);\n    if (nMod3 === 2 || aBytes.length - nIdx === 1) {\n      sB64Enc += String.fromCodePoint(uint6ToB64(nUint24 >>> 18 & 63), uint6ToB64(nUint24 >>> 12 & 63), uint6ToB64(nUint24 >>> 6 & 63), uint6ToB64(nUint24 & 63));\n      nUint24 = 0;\n    }\n  }\n  return sB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? \"\" : nMod3 === 1 ? \"=\" : \"==\");\n}\n\n// src/hex.ts\nfunction fromHEX(hexStr) {\n  let intArr = hexStr.replace(\"0x\", \"\").match(/.{1,2}/g).map(byte => parseInt(byte, 16));\n  if (intArr === null) {\n    throw new Error(`Unable to parse HEX: ${hexStr}`);\n  }\n  return Uint8Array.from(intArr);\n}\nfunction toHEX(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\n\n// src/index.ts\nimport bs58 from \"bs58\";\nvar SUI_ADDRESS_LENGTH = 32;\nfunction toLittleEndian(bigint, size) {\n  let result = new Uint8Array(size);\n  let i = 0;\n  while (bigint > 0) {\n    result[i] = Number(bigint % BigInt(256));\n    bigint = bigint / BigInt(256);\n    i += 1;\n  }\n  return result;\n}\nvar toB58 = buffer => bs58.encode(buffer);\nvar fromB58 = str => bs58.decode(str);\nvar BcsReader = class {\n  /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */\n  constructor(data) {\n    this.bytePosition = 0;\n    this.dataView = new DataView(data.buffer);\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */\n  read8() {\n    let value = this.dataView.getUint8(this.bytePosition);\n    this.shift(1);\n    return value;\n  }\n  /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */\n  read16() {\n    let value = this.dataView.getUint16(this.bytePosition, true);\n    this.shift(2);\n    return value;\n  }\n  /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */\n  read32() {\n    let value = this.dataView.getUint32(this.bytePosition, true);\n    this.shift(4);\n    return value;\n  }\n  /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */\n  read64() {\n    let value1 = this.read32();\n    let value2 = this.read32();\n    let result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */\n  read128() {\n    let value1 = BigInt(this.read64());\n    let value2 = BigInt(this.read64());\n    let result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */\n  read256() {\n    let value1 = BigInt(this.read128());\n    let value2 = BigInt(this.read128());\n    let result = value2.toString(16) + value1.toString(16).padStart(32, \"0\");\n    return BigInt(\"0x\" + result).toString(10);\n  }\n  /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */\n  readBytes(num) {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let value = new Uint8Array(this.dataView.buffer, start, num);\n    this.shift(num);\n    return value;\n  }\n  /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */\n  readULEB() {\n    let start = this.bytePosition + this.dataView.byteOffset;\n    let buffer = new Uint8Array(this.dataView.buffer, start);\n    let {\n      value,\n      length\n    } = ulebDecode(buffer);\n    this.shift(length);\n    return value;\n  }\n  /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */\n  readVec(cb) {\n    let length = this.readULEB();\n    let result = [];\n    for (let i = 0; i < length; i++) {\n      result.push(cb(this, i, length));\n    }\n    return result;\n  }\n};\nvar BcsWriter = class {\n  constructor() {\n    let {\n      size = 1024,\n      maxSize,\n      allocateSize = 1024\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.bytePosition = 0;\n    this.size = size;\n    this.maxSize = maxSize || size;\n    this.allocateSize = allocateSize;\n    this.dataView = new DataView(new ArrayBuffer(size));\n  }\n  ensureSizeOrGrow(bytes) {\n    const requiredSize = this.bytePosition + bytes;\n    if (requiredSize > this.size) {\n      const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n      if (requiredSize > nextSize) {\n        throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`);\n      }\n      this.size = nextSize;\n      const nextBuffer = new ArrayBuffer(this.size);\n      new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n      this.dataView = new DataView(nextBuffer);\n    }\n  }\n  /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */\n  shift(bytes) {\n    this.bytePosition += bytes;\n    return this;\n  }\n  /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write8(value) {\n    this.ensureSizeOrGrow(1);\n    this.dataView.setUint8(this.bytePosition, Number(value));\n    return this.shift(1);\n  }\n  /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write16(value) {\n    this.ensureSizeOrGrow(2);\n    this.dataView.setUint16(this.bytePosition, Number(value), true);\n    return this.shift(2);\n  }\n  /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  write32(value) {\n    this.ensureSizeOrGrow(4);\n    this.dataView.setUint32(this.bytePosition, Number(value), true);\n    return this.shift(4);\n  }\n  /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write64(value) {\n    toLittleEndian(BigInt(value), 8).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write128(value) {\n    toLittleEndian(BigInt(value), 16).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */\n  write256(value) {\n    toLittleEndian(BigInt(value), 32).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */\n  writeULEB(value) {\n    ulebEncode(value).forEach(el => this.write8(el));\n    return this;\n  }\n  /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */\n  writeVec(vector, cb) {\n    this.writeULEB(vector.length);\n    Array.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n    return this;\n  }\n  /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */\n  *[Symbol.iterator]() {\n    for (let i = 0; i < this.bytePosition; i++) {\n      yield this.dataView.getUint8(i);\n    }\n    return this.toBytes();\n  }\n  /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */\n  toBytes() {\n    return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n  }\n  /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */\n  toString(encoding) {\n    return encodeStr(this.toBytes(), encoding);\n  }\n};\nfunction ulebEncode(num) {\n  let arr = [];\n  let len = 0;\n  if (num === 0) {\n    return [0];\n  }\n  while (num > 0) {\n    arr[len] = num & 127;\n    if (num >>= 7) {\n      arr[len] |= 128;\n    }\n    len += 1;\n  }\n  return arr;\n}\nfunction ulebDecode(arr) {\n  let total = 0;\n  let shift = 0;\n  let len = 0;\n  while (true) {\n    let byte = arr[len];\n    len += 1;\n    total |= (byte & 127) << shift;\n    if ((byte & 128) === 0) {\n      break;\n    }\n    shift += 7;\n  }\n  return {\n    value: total,\n    length: len\n  };\n}\nvar _BCS = class {\n  /**\n   * Construct a BCS instance with a prepared schema.\n   *\n   * @param schema A prepared schema with type definitions\n   * @param withPrimitives Whether to register primitive types by default\n   */\n  constructor(schema) {\n    /**\n     * Map of kind `TypeName => TypeInterface`. Holds all\n     * callbacks for (de)serialization of every registered type.\n     *\n     * If the value stored is a string, it is treated as an alias.\n     */\n    this.types = /* @__PURE__ */new Map();\n    /**\n     * Count temp keys to generate a new one when requested.\n     */\n    this.counter = 0;\n    if (schema instanceof _BCS) {\n      this.schema = schema.schema;\n      this.types = new Map(schema.types);\n      return;\n    }\n    this.schema = schema;\n    this.registerAddressType(_BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n    this.registerVectorType(schema.vectorType);\n    if (schema.types && schema.types.structs) {\n      for (let name of Object.keys(schema.types.structs)) {\n        this.registerStructType(name, schema.types.structs[name]);\n      }\n    }\n    if (schema.types && schema.types.enums) {\n      for (let name of Object.keys(schema.types.enums)) {\n        this.registerEnumType(name, schema.types.enums[name]);\n      }\n    }\n    if (schema.types && schema.types.aliases) {\n      for (let name of Object.keys(schema.types.aliases)) {\n        this.registerAlias(name, schema.types.aliases[name]);\n      }\n    }\n    if (schema.withPrimitives !== false) {\n      registerPrimitives(this);\n    }\n  }\n  /**\n   * Name of the key to use for temporary struct definitions.\n   * Returns a temp key + index (for a case when multiple temp\n   * structs are processed).\n   */\n  tempKey() {\n    return `bcs-struct-${++this.counter}`;\n  }\n  /**\n   * Serialize data into bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<u8>', 'u8');\n   *\n   * let serialized = BCS\n   *   .set('vector<u8>', [1,2,3,4,5,6])\n   *   .toBytes();\n   *\n   * console.assert(toHex(serialized) === '06010203040506');\n   *\n   * @param type Name of the type to serialize (must be registered) or a struct type.\n   * @param data Data to serialize.\n   * @param size Serialization buffer size. Default 1024 = 1KB.\n   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n   */\n  ser(type, data, options) {\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const {\n        name,\n        params\n      } = this.parseTypeName(type);\n      return this.getTypeInterface(name).encode(this, data, options, params);\n    }\n    if (typeof type === \"object\") {\n      const key = this.tempKey();\n      const temp = new _BCS(this);\n      return temp.registerStructType(key, type).ser(key, data, options);\n    }\n    throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Deserialize BCS into a JS type.\n   *\n   * @example\n   * let num = bcs.ser('u64', '4294967295').toString('hex');\n   * let deNum = bcs.de('u64', num, 'hex');\n   * console.assert(deNum.toString(10) === '4294967295');\n   *\n   * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n   * @param data Data to deserialize.\n   * @param encoding Optional - encoding to use if data is of type String\n   * @return Deserialized data.\n   */\n  de(type, data, encoding) {\n    if (typeof data === \"string\") {\n      if (encoding) {\n        data = decodeStr(data, encoding);\n      } else {\n        throw new Error(\"To pass a string to `bcs.de`, specify encoding\");\n      }\n    }\n    if (typeof type === \"string\" || Array.isArray(type)) {\n      const {\n        name,\n        params\n      } = this.parseTypeName(type);\n      return this.getTypeInterface(name).decode(this, data, params);\n    }\n    if (typeof type === \"object\") {\n      const temp = new _BCS(this);\n      const key = this.tempKey();\n      return temp.registerStructType(key, type).de(key, data, encoding);\n    }\n    throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(type)}`);\n  }\n  /**\n   * Check whether a `TypeInterface` has been loaded for a `type`.\n   * @param type Name of the type to check.\n   * @returns\n   */\n  hasType(type) {\n    return this.types.has(type);\n  }\n  /**\n   * Create an alias for a type.\n   * WARNING: this can potentially lead to recursion\n   * @param name Alias to use\n   * @param forType Type to reference\n   * @returns\n   *\n   * @example\n   * ```\n   * let bcs = new BCS(getSuiMoveConfig());\n   * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n   * ```\n   */\n  registerAlias(name, forType) {\n    this.types.set(name, forType);\n    return this;\n  }\n  /**\n   * Method to register new types for BCS internal representation.\n   * For each registered type 2 callbacks must be specified and one is optional:\n   *\n   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n   * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n   * - validateCb(data) - validate data - either return bool or throw an error\n   *\n   * @example\n   * // our type would be a string that consists only of numbers\n   * bcs.registerType('number_string',\n   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n   * );\n   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n   *\n   * @param name\n   * @param encodeCb Callback to encode a value.\n   * @param decodeCb Callback to decode a value.\n   * @param validateCb Optional validator Callback to check type before serialization.\n   */\n  registerType(typeName, encodeCb, decodeCb) {\n    let validateCb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => true;\n    const {\n      name,\n      params: generics\n    } = this.parseTypeName(typeName);\n    this.types.set(name, {\n      encode(self, data, options, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, {\n            [value]: typeParams[index]\n          });\n        }, {});\n        return this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n      },\n      decode(self, data, typeParams) {\n        const typeMap = generics.reduce((acc, value, index) => {\n          return Object.assign(acc, {\n            [value]: typeParams[index]\n          });\n        }, {});\n        return this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n      },\n      // these methods should always be used with caution as they require pre-defined\n      // reader and writer and mainly exist to allow multi-field (de)serialization;\n      _encodeRaw(writer, data, typeParams, typeMap) {\n        if (validateCb(data)) {\n          return encodeCb.call(this, writer, data, typeParams, typeMap);\n        } else {\n          throw new Error(`Validation failed for type ${name}, data: ${data}`);\n        }\n      },\n      _decodeRaw(reader, typeParams, typeMap) {\n        return decodeCb.call(this, reader, typeParams, typeMap);\n      }\n    });\n    return this;\n  }\n  /**\n   * Register an address type which is a sequence of U8s of specified length.\n   * @example\n   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n   *\n   * @param name Name of the address type.\n   * @param length Byte length of the address.\n   * @param encoding Encoding to use for the address type\n   * @returns\n   */\n  registerAddressType(name, length) {\n    let encoding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"hex\";\n    switch (encoding) {\n      case \"base64\":\n        return this.registerType(name, function encodeAddress(writer, data) {\n          return fromB64(data).reduce((writer2, el) => writer2.write8(el), writer);\n        }, function decodeAddress(reader) {\n          return toB64(reader.readBytes(length));\n        });\n      case \"hex\":\n        return this.registerType(name, function encodeAddress(writer, data) {\n          return fromHEX(data).reduce((writer2, el) => writer2.write8(el), writer);\n        }, function decodeAddress(reader) {\n          return toHEX(reader.readBytes(length));\n        });\n      default:\n        throw new Error(\"Unsupported encoding! Use either hex or base64\");\n    }\n  }\n  /**\n   * Register custom vector type inside the bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<T>'); // generic registration\n   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n   *\n   * @param name Name of the type to register\n   * @param elementType Optional name of the inner type of the vector\n   * @return Returns self for chaining.\n   */\n  registerVectorType(typeName) {\n    let {\n      name,\n      params\n    } = this.parseTypeName(typeName);\n    if (params.length > 1) {\n      throw new Error(\"Vector can have only one type parameter; got \" + name);\n    }\n    return this.registerType(typeName, function encodeVector(writer, data, typeParams, typeMap) {\n      return writer.writeVec(data, (writer2, el) => {\n        let elementType = typeParams[0];\n        if (!elementType) {\n          throw new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n        }\n        let {\n          name: name2,\n          params: params2\n        } = this.parseTypeName(elementType);\n        if (this.hasType(name2)) {\n          return this.getTypeInterface(name2)._encodeRaw.call(this, writer2, el, params2, typeMap);\n        }\n        if (!(name2 in typeMap)) {\n          throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);\n        }\n        let {\n          name: innerName,\n          params: innerParams\n        } = this.parseTypeName(typeMap[name2]);\n        return this.getTypeInterface(innerName)._encodeRaw.call(this, writer2, el, innerParams, typeMap);\n      });\n    }, function decodeVector(reader, typeParams, typeMap) {\n      return reader.readVec(reader2 => {\n        let elementType = typeParams[0];\n        if (!elementType) {\n          throw new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n        }\n        let {\n          name: name2,\n          params: params2\n        } = this.parseTypeName(elementType);\n        if (this.hasType(name2)) {\n          return this.getTypeInterface(name2)._decodeRaw.call(this, reader2, params2, typeMap);\n        }\n        if (!(name2 in typeMap)) {\n          throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);\n        }\n        let {\n          name: innerName,\n          params: innerParams\n        } = this.parseTypeName(typeMap[name2]);\n        return this.getTypeInterface(innerName)._decodeRaw.call(this, reader2, innerParams, typeMap);\n      });\n    });\n  }\n  /**\n   * Safe method to register a custom Move struct. The first argument is a name of the\n   * struct which is only used on the FrontEnd and has no affect on serialization results,\n   * and the second is a struct description passed as an Object.\n   *\n   * The description object MUST have the same order on all of the platforms (ie in Move\n   * or in Rust).\n   *\n   * @example\n   * // Move / Rust struct\n   * // struct Coin {\n   * //   value: u64,\n   * //   owner: vector<u8>, // name // Vec<u8> in Rust\n   * //   is_locked: bool,\n   * // }\n   *\n   * bcs.registerStructType('Coin', {\n   *   value: bcs.U64,\n   *   owner: bcs.STRING,\n   *   is_locked: bcs.BOOL\n   * });\n   *\n   * // Created in Rust with diem/bcs\n   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n   *  128, 209, 177,   5,  96,  0,  0,\n   *    0,  14,  66, 105, 103, 32, 87,\n   *   97, 108, 108, 101, 116, 32, 71,\n   *  117, 121,   0\n   * ];\n   *\n   * // Let's encode the value as well\n   * let test_set = bcs.ser('Coin', {\n   *   owner: 'Big Wallet Guy',\n   *   value: '412412400000',\n   *   is_locked: false,\n   * });\n   *\n   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n   *\n   * @param name Name of the type to register.\n   * @param fields Fields of the struct. Must be in the correct order.\n   * @return Returns BCS for chaining.\n   */\n  registerStructType(typeName, fields) {\n    for (let key in fields) {\n      let internalName = this.tempKey();\n      let value = fields[key];\n      if (!Array.isArray(value) && typeof value !== \"string\") {\n        fields[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(fields);\n    let canonicalOrder = Object.keys(struct);\n    let {\n      name: structName,\n      params: generics\n    } = this.parseTypeName(typeName);\n    return this.registerType(typeName, function encodeStruct(writer, data, typeParams, typeMap) {\n      if (!data || data.constructor !== Object) {\n        throw new Error(`Expected ${structName} to be an Object, got: ${data}`);\n      }\n      if (typeParams.length !== generics.length) {\n        throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);\n      }\n      for (let key of canonicalOrder) {\n        if (!(key in data)) {\n          throw new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n        }\n        const {\n          name: fieldType,\n          params: fieldParams\n        } = this.parseTypeName(struct[key]);\n        if (!generics.includes(fieldType)) {\n          this.getTypeInterface(fieldType)._encodeRaw.call(this, writer, data[key], fieldParams, typeMap);\n        } else {\n          const paramIdx = generics.indexOf(fieldType);\n          let {\n            name,\n            params\n          } = this.parseTypeName(typeParams[paramIdx]);\n          if (this.hasType(name)) {\n            this.getTypeInterface(name)._encodeRaw.call(this, writer, data[key], params, typeMap);\n            continue;\n          }\n          if (!(name in typeMap)) {\n            throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);\n          }\n          let {\n            name: innerName,\n            params: innerParams\n          } = this.parseTypeName(typeMap[name]);\n          this.getTypeInterface(innerName)._encodeRaw.call(this, writer, data[key], innerParams, typeMap);\n        }\n      }\n      return writer;\n    }, function decodeStruct(reader, typeParams, typeMap) {\n      if (typeParams.length !== generics.length) {\n        throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);\n      }\n      let result = {};\n      for (let key of canonicalOrder) {\n        const {\n          name: fieldName,\n          params: fieldParams\n        } = this.parseTypeName(struct[key]);\n        if (!generics.includes(fieldName)) {\n          result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(this, reader, fieldParams, typeMap);\n        } else {\n          const paramIdx = generics.indexOf(fieldName);\n          let {\n            name,\n            params\n          } = this.parseTypeName(typeParams[paramIdx]);\n          if (this.hasType(name)) {\n            result[key] = this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\n            continue;\n          }\n          if (!(name in typeMap)) {\n            throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);\n          }\n          let {\n            name: innerName,\n            params: innerParams\n          } = this.parseTypeName(typeMap[name]);\n          result[key] = this.getTypeInterface(innerName)._decodeRaw.call(this, reader, innerParams, typeMap);\n        }\n      }\n      return result;\n    });\n  }\n  /**\n   * Safe method to register custom enum type where each invariant holds the value of another type.\n   * @example\n   * bcs.registerStructType('Coin', { value: 'u64' });\n   * bcs.registerEnumType('MyEnum', {\n   *  single: 'Coin',\n   *  multi: 'vector<Coin>',\n   *  empty: null\n   * });\n   *\n   * console.log(\n   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n   * )\n   *\n   * // and serialization\n   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n   *\n   * @param name\n   * @param variants\n   */\n  registerEnumType(typeName, variants) {\n    for (let key in variants) {\n      let internalName = this.tempKey();\n      let value = variants[key];\n      if (value !== null && !Array.isArray(value) && typeof value !== \"string\") {\n        variants[key] = internalName;\n        this.registerStructType(internalName, value);\n      }\n    }\n    let struct = Object.freeze(variants);\n    let canonicalOrder = Object.keys(struct);\n    let {\n      name,\n      params: canonicalTypeParams\n    } = this.parseTypeName(typeName);\n    return this.registerType(typeName, function encodeEnum(writer, data, typeParams, typeMap) {\n      if (!data) {\n        throw new Error(`Unable to write enum \"${name}\", missing data.\nReceived: \"${data}\"`);\n      }\n      if (typeof data !== \"object\") {\n        throw new Error(`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\" | \")}\".\nReceived: \"${JSON.stringify(data)}\"`);\n      }\n      let key = Object.keys(data)[0];\n      if (key === void 0) {\n        throw new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n      }\n      let orderByte = canonicalOrder.indexOf(key);\n      if (orderByte === -1) {\n        throw new Error(`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\" | \")}\"; received \"${key}\"`);\n      }\n      let invariant = canonicalOrder[orderByte];\n      let invariantType = struct[invariant];\n      writer.write8(orderByte);\n      if (invariantType === null) {\n        return writer;\n      }\n      let paramIndex = canonicalTypeParams.indexOf(invariantType);\n      let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n      {\n        let {\n          name: name2,\n          params\n        } = this.parseTypeName(typeOrParam);\n        return this.getTypeInterface(name2)._encodeRaw.call(this, writer, data[key], params, typeMap);\n      }\n    }, function decodeEnum(reader, typeParams, typeMap) {\n      let orderByte = reader.readULEB();\n      let invariant = canonicalOrder[orderByte];\n      let invariantType = struct[invariant];\n      if (orderByte === -1) {\n        throw new Error(`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`);\n      }\n      if (invariantType === null) {\n        return {\n          [invariant]: true\n        };\n      }\n      let paramIndex = canonicalTypeParams.indexOf(invariantType);\n      let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n      {\n        let {\n          name: name2,\n          params\n        } = this.parseTypeName(typeOrParam);\n        return {\n          [invariant]: this.getTypeInterface(name2)._decodeRaw.call(this, reader, params, typeMap)\n        };\n      }\n    });\n  }\n  /**\n   * Get a set of encoders/decoders for specific type.\n   * Mainly used to define custom type de/serialization logic.\n   *\n   * @param type\n   * @returns {TypeInterface}\n   */\n  getTypeInterface(type) {\n    let typeInterface = this.types.get(type);\n    if (typeof typeInterface === \"string\") {\n      let chain = [];\n      while (typeof typeInterface === \"string\") {\n        if (chain.includes(typeInterface)) {\n          throw new Error(`Recursive definition found: ${chain.join(\" -> \")} -> ${typeInterface}`);\n        }\n        chain.push(typeInterface);\n        typeInterface = this.types.get(typeInterface);\n      }\n    }\n    if (typeInterface === void 0) {\n      throw new Error(`Type ${type} is not registered`);\n    }\n    return typeInterface;\n  }\n  /**\n   * Parse a type name and get the type's generics.\n   * @example\n   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n   * // typeName: Option\n   * // typeParams: [ 'Coin<SUI>' ]\n   *\n   * @param name Name of the type to process\n   * @returns Object with typeName and typeParams listed as Array\n   */\n  parseTypeName(name) {\n    if (Array.isArray(name)) {\n      let [typeName2, ...params2] = name;\n      return {\n        name: typeName2,\n        params: params2\n      };\n    }\n    if (typeof name !== \"string\") {\n      throw new Error(`Illegal type passed as a name of the type: ${name}`);\n    }\n    let [left, right] = this.schema.genericSeparators || [\"<\", \">\"];\n    let l_bound = name.indexOf(left);\n    let r_bound = Array.from(name).reverse().indexOf(right);\n    if (l_bound === -1 && r_bound === -1) {\n      return {\n        name,\n        params: []\n      };\n    }\n    if (l_bound === -1 || r_bound === -1) {\n      throw new Error(`Unclosed generic in name '${name}'`);\n    }\n    let typeName = name.slice(0, l_bound);\n    let params = splitGenericParameters(name.slice(l_bound + 1, name.length - r_bound - 1), this.schema.genericSeparators);\n    return {\n      name: typeName,\n      params\n    };\n  }\n};\nvar BCS = _BCS;\n// Prefefined types constants\nBCS.U8 = \"u8\";\nBCS.U16 = \"u16\";\nBCS.U32 = \"u32\";\nBCS.U64 = \"u64\";\nBCS.U128 = \"u128\";\nBCS.U256 = \"u256\";\nBCS.BOOL = \"bool\";\nBCS.VECTOR = \"vector\";\nBCS.ADDRESS = \"address\";\nBCS.STRING = \"string\";\nBCS.HEX = \"hex-string\";\nBCS.BASE58 = \"base58-string\";\nBCS.BASE64 = \"base64-string\";\nfunction encodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return toB58(data);\n    case \"base64\":\n      return toB64(data);\n    case \"hex\":\n      return toHEX(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction decodeStr(data, encoding) {\n  switch (encoding) {\n    case \"base58\":\n      return fromB58(data);\n    case \"base64\":\n      return fromB64(data);\n    case \"hex\":\n      return fromHEX(data);\n    default:\n      throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n  }\n}\nfunction registerPrimitives(bcs) {\n  bcs.registerType(BCS.U8, function (writer, data) {\n    return writer.write8(data);\n  }, function (reader) {\n    return reader.read8();\n  }, u8 => u8 < 256);\n  bcs.registerType(BCS.U16, function (writer, data) {\n    return writer.write16(data);\n  }, function (reader) {\n    return reader.read16();\n  }, u16 => u16 < 65536);\n  bcs.registerType(BCS.U32, function (writer, data) {\n    return writer.write32(data);\n  }, function (reader) {\n    return reader.read32();\n  }, u32 => u32 <= 4294967296n);\n  bcs.registerType(BCS.U64, function (writer, data) {\n    return writer.write64(data);\n  }, function (reader) {\n    return reader.read64();\n  });\n  bcs.registerType(BCS.U128, function (writer, data) {\n    return writer.write128(data);\n  }, function (reader) {\n    return reader.read128();\n  });\n  bcs.registerType(BCS.U256, function (writer, data) {\n    return writer.write256(data);\n  }, function (reader) {\n    return reader.read256();\n  });\n  bcs.registerType(BCS.BOOL, function (writer, data) {\n    return writer.write8(data);\n  }, function (reader) {\n    return reader.read8().toString(10) === \"1\";\n  });\n  bcs.registerType(BCS.STRING, function (writer, data) {\n    return writer.writeVec(Array.from(data), (writer2, el) => writer2.write8(el.charCodeAt(0)));\n  }, function (reader) {\n    return reader.readVec(reader2 => reader2.read8()).map(el => String.fromCharCode(Number(el))).join(\"\");\n  }, _str => true);\n  bcs.registerType(BCS.HEX, function (writer, data) {\n    return writer.writeVec(Array.from(fromHEX(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toHEX(new Uint8Array(bytes));\n  });\n  bcs.registerType(BCS.BASE58, function (writer, data) {\n    return writer.writeVec(Array.from(fromB58(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toB58(new Uint8Array(bytes));\n  });\n  bcs.registerType(BCS.BASE64, function (writer, data) {\n    return writer.writeVec(Array.from(fromB64(data)), (writer2, el) => writer2.write8(el));\n  }, function (reader) {\n    let bytes = reader.readVec(reader2 => reader2.read8());\n    return toB64(new Uint8Array(bytes));\n  });\n}\nfunction getRustConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"Vec\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\nfunction getSuiMoveConfig() {\n  return {\n    genericSeparators: [\"<\", \">\"],\n    vectorType: \"vector\",\n    addressLength: SUI_ADDRESS_LENGTH,\n    addressEncoding: \"hex\"\n  };\n}\nfunction splitGenericParameters(str) {\n  let genericSeparators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [\"<\", \">\"];\n  const [left, right] = genericSeparators;\n  const tok = [];\n  let word = \"\";\n  let nestedAngleBrackets = 0;\n  for (let i = 0; i < str.length; i++) {\n    const char = str[i];\n    if (char === left) {\n      nestedAngleBrackets++;\n    }\n    if (char === right) {\n      nestedAngleBrackets--;\n    }\n    if (nestedAngleBrackets === 0 && char === \",\") {\n      tok.push(word.trim());\n      word = \"\";\n      continue;\n    }\n    word += char;\n  }\n  tok.push(word.trim());\n  return tok;\n}\nexport { BCS, BcsReader, BcsWriter, decodeStr, encodeStr, fromB58, fromB64, fromHEX, getRustConfig, getSuiMoveConfig, registerPrimitives, splitGenericParameters, toB58, toB64, toHEX };","map":{"version":3,"names":["b64ToUint6","nChr","fromB64","sBase64","nBlocksSize","sB64Enc","replace","nInLen","length","nOutLen","Math","ceil","taBytes","Uint8Array","nMod3","nMod4","nUint24","nOutIdx","nInIdx","charCodeAt","uint6ToB64","nUint6","toB64","aBytes","nLen","nIdx","String","fromCodePoint","slice","fromHEX","hexStr","intArr","match","map","byte","parseInt","Error","from","toHEX","bytes","reduce","str","toString","padStart","bs58","SUI_ADDRESS_LENGTH","toLittleEndian","bigint","size","result","i","Number","BigInt","toB58","buffer","encode","fromB58","decode","BcsReader","constructor","data","bytePosition","dataView","DataView","shift","read8","value","getUint8","read16","getUint16","read32","getUint32","read64","value1","value2","read128","read256","readBytes","num","start","byteOffset","readULEB","ulebDecode","readVec","cb","push","BcsWriter","maxSize","allocateSize","arguments","undefined","ArrayBuffer","ensureSizeOrGrow","requiredSize","nextSize","min","nextBuffer","set","write8","setUint8","write16","setUint16","write32","setUint32","write64","forEach","el","write128","write256","writeULEB","ulebEncode","writeVec","vector","Array","Symbol","iterator","toBytes","encoding","encodeStr","arr","len","total","_BCS","schema","types","Map","counter","registerAddressType","ADDRESS","addressLength","addressEncoding","registerVectorType","vectorType","structs","name","Object","keys","registerStructType","enums","registerEnumType","aliases","registerAlias","withPrimitives","registerPrimitives","tempKey","ser","type","options","isArray","params","parseTypeName","getTypeInterface","key","temp","JSON","stringify","de","decodeStr","hasType","has","forType","registerType","typeName","encodeCb","decodeCb","validateCb","generics","self","typeParams","typeMap","acc","index","assign","_encodeRaw","call","_decodeRaw","writer","reader","encodeAddress","writer2","decodeAddress","encodeVector","elementType","name2","params2","innerName","innerParams","decodeVector","reader2","fields","internalName","struct","freeze","canonicalOrder","structName","encodeStruct","fieldType","fieldParams","includes","paramIdx","indexOf","decodeStruct","fieldName","variants","canonicalTypeParams","encodeEnum","join","orderByte","invariant","invariantType","paramIndex","typeOrParam","decodeEnum","typeInterface","get","chain","typeName2","left","right","genericSeparators","l_bound","r_bound","reverse","splitGenericParameters","BCS","U8","U16","U32","U64","U128","U256","BOOL","VECTOR","STRING","HEX","BASE58","BASE64","bcs","u8","u16","u32","fromCharCode","_str","getRustConfig","getSuiMoveConfig","tok","word","nestedAngleBrackets","char","trim"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/bcs/src/b64.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/bcs/src/hex.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/bcs/src/index.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/*\\\n|*|  Base64 / binary data / UTF-8 strings utilities\n|*|  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding\n\\*/\n\n/* Array of bytes to Base64 string decoding */\n\nfunction b64ToUint6(nChr: number) {\n\treturn nChr > 64 && nChr < 91\n\t\t? nChr - 65\n\t\t: nChr > 96 && nChr < 123\n\t\t? nChr - 71\n\t\t: nChr > 47 && nChr < 58\n\t\t? nChr + 4\n\t\t: nChr === 43\n\t\t? 62\n\t\t: nChr === 47\n\t\t? 63\n\t\t: 0;\n}\n\nexport function fromB64(sBase64: string, nBlocksSize?: number): Uint8Array {\n\tvar sB64Enc = sBase64.replace(/[^A-Za-z0-9+/]/g, ''),\n\t\tnInLen = sB64Enc.length,\n\t\tnOutLen = nBlocksSize\n\t\t\t? Math.ceil(((nInLen * 3 + 1) >> 2) / nBlocksSize) * nBlocksSize\n\t\t\t: (nInLen * 3 + 1) >> 2,\n\t\ttaBytes = new Uint8Array(nOutLen);\n\n\tfor (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {\n\t\tnMod4 = nInIdx & 3;\n\t\tnUint24 |= b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << (6 * (3 - nMod4));\n\t\tif (nMod4 === 3 || nInLen - nInIdx === 1) {\n\t\t\tfor (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {\n\t\t\t\ttaBytes[nOutIdx] = (nUint24 >>> ((16 >>> nMod3) & 24)) & 255;\n\t\t\t}\n\t\t\tnUint24 = 0;\n\t\t}\n\t}\n\n\treturn taBytes;\n}\n\n/* Base64 string to array encoding */\n\nfunction uint6ToB64(nUint6: number) {\n\treturn nUint6 < 26\n\t\t? nUint6 + 65\n\t\t: nUint6 < 52\n\t\t? nUint6 + 71\n\t\t: nUint6 < 62\n\t\t? nUint6 - 4\n\t\t: nUint6 === 62\n\t\t? 43\n\t\t: nUint6 === 63\n\t\t? 47\n\t\t: 65;\n}\n\nexport function toB64(aBytes: Uint8Array): string {\n\tvar nMod3 = 2,\n\t\tsB64Enc = '';\n\n\tfor (var nLen = aBytes.length, nUint24 = 0, nIdx = 0; nIdx < nLen; nIdx++) {\n\t\tnMod3 = nIdx % 3;\n\t\tnUint24 |= aBytes[nIdx] << ((16 >>> nMod3) & 24);\n\t\tif (nMod3 === 2 || aBytes.length - nIdx === 1) {\n\t\t\tsB64Enc += String.fromCodePoint(\n\t\t\t\tuint6ToB64((nUint24 >>> 18) & 63),\n\t\t\t\tuint6ToB64((nUint24 >>> 12) & 63),\n\t\t\t\tuint6ToB64((nUint24 >>> 6) & 63),\n\t\t\t\tuint6ToB64(nUint24 & 63),\n\t\t\t);\n\t\t\tnUint24 = 0;\n\t\t}\n\t}\n\n\treturn (\n\t\tsB64Enc.slice(0, sB64Enc.length - 2 + nMod3) + (nMod3 === 2 ? '' : nMod3 === 1 ? '=' : '==')\n\t);\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function fromHEX(hexStr: string): Uint8Array {\n\t// @ts-ignore\n\tlet intArr = hexStr\n\t\t.replace('0x', '')\n\t\t.match(/.{1,2}/g)\n\t\t.map((byte) => parseInt(byte, 16));\n\n\tif (intArr === null) {\n\t\tthrow new Error(`Unable to parse HEX: ${hexStr}`);\n\t}\n\n\treturn Uint8Array.from(intArr);\n}\n\nexport function toHEX(bytes: Uint8Array): string {\n\treturn bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n * BCS implementation {@see https://github.com/diem/bcs } for JavaScript.\n * Intended to be used for Move applications; supports both NodeJS and browser.\n *\n * For more details and examples {@see README.md }.\n *\n * @module bcs\n * @property {BcsReader}\n */\n\nimport { toB64, fromB64 } from './b64';\nimport { toHEX, fromHEX } from './hex';\nimport bs58 from 'bs58';\n\nconst SUI_ADDRESS_LENGTH = 32;\n\nfunction toLittleEndian(bigint: bigint, size: number) {\n\tlet result = new Uint8Array(size);\n\tlet i = 0;\n\twhile (bigint > 0) {\n\t\tresult[i] = Number(bigint % BigInt(256));\n\t\tbigint = bigint / BigInt(256);\n\t\ti += 1;\n\t}\n\treturn result;\n}\n\nconst toB58 = (buffer: Uint8Array) => bs58.encode(buffer);\nconst fromB58 = (str: string) => bs58.decode(str);\n\n// Re-export all encoding dependencies.\nexport { toB58, fromB58, toB64, fromB64, fromHEX, toHEX };\n\n/**\n * Supported encodings.\n * Used in `Reader.toString()` as well as in `decodeStr` and `encodeStr` functions.\n */\nexport type Encoding = 'base58' | 'base64' | 'hex';\n\n/**\n * Allows for array definitions for names.\n * @example\n * ```\n * bcs.registerStructType(['vector', BCS.STRING], ...);\n * // equals\n * bcs.registerStructType('vector<string>', ...);\n * ```\n */\nexport type TypeName = string | [string, ...(TypeName | string)[]];\n\n/**\n * Class used for reading BCS data chunk by chunk. Meant to be used\n * by some wrapper, which will make sure that data is valid and is\n * matching the desired format.\n *\n * @example\n * // data for this example is:\n * // { a: u8, b: u32, c: bool, d: u64 }\n *\n * let reader = new BcsReader(\"647f1a060001ffffe7890423c78a050102030405\");\n * let field1 = reader.read8();\n * let field2 = reader.read32();\n * let field3 = reader.read8() === '1'; // bool\n * let field4 = reader.read64();\n * // ....\n *\n * Reading vectors is another deal in bcs. To read a vector, you first need to read\n * its length using {@link readULEB}. Here's an example:\n * @example\n * // data encoded: { field: [1, 2, 3, 4, 5] }\n * let reader = new BcsReader(\"050102030405\");\n * let vec_length = reader.readULEB();\n * let elements = [];\n * for (let i = 0; i < vec_length; i++) {\n *   elements.push(reader.read8());\n * }\n * console.log(elements); // [1,2,3,4,5]\n *\n * @param {String} data HEX-encoded data (serialized BCS)\n */\nexport class BcsReader {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\n\t/**\n\t * @param {Uint8Array} data Data to use as a buffer.\n\t */\n\tconstructor(data: Uint8Array) {\n\t\tthis.dataView = new DataView(data.buffer);\n\t}\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number) {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Read U8 value from the buffer and shift cursor by 1.\n\t * @returns\n\t */\n\tread8(): number {\n\t\tlet value = this.dataView.getUint8(this.bytePosition);\n\t\tthis.shift(1);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U16 value from the buffer and shift cursor by 2.\n\t * @returns\n\t */\n\tread16(): number {\n\t\tlet value = this.dataView.getUint16(this.bytePosition, true);\n\t\tthis.shift(2);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U32 value from the buffer and shift cursor by 4.\n\t * @returns\n\t */\n\tread32(): number {\n\t\tlet value = this.dataView.getUint32(this.bytePosition, true);\n\t\tthis.shift(4);\n\t\treturn value;\n\t}\n\t/**\n\t * Read U64 value from the buffer and shift cursor by 8.\n\t * @returns\n\t */\n\tread64(): string {\n\t\tlet value1 = this.read32();\n\t\tlet value2 = this.read32();\n\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(8, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 16.\n\t */\n\tread128(): string {\n\t\tlet value1 = BigInt(this.read64());\n\t\tlet value2 = BigInt(this.read64());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(16, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read U128 value from the buffer and shift cursor by 32.\n\t * @returns\n\t */\n\tread256(): string {\n\t\tlet value1 = BigInt(this.read128());\n\t\tlet value2 = BigInt(this.read128());\n\t\tlet result = value2.toString(16) + value1.toString(16).padStart(32, '0');\n\n\t\treturn BigInt('0x' + result).toString(10);\n\t}\n\t/**\n\t * Read `num` number of bytes from the buffer and shift cursor by `num`.\n\t * @param num Number of bytes to read.\n\t */\n\treadBytes(num: number): Uint8Array {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet value = new Uint8Array(this.dataView.buffer, start, num);\n\n\t\tthis.shift(num);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read ULEB value - an integer of varying size. Used for enum indexes and\n\t * vector lengths.\n\t * @returns {Number} The ULEB value.\n\t */\n\treadULEB(): number {\n\t\tlet start = this.bytePosition + this.dataView.byteOffset;\n\t\tlet buffer = new Uint8Array(this.dataView.buffer, start);\n\t\tlet { value, length } = ulebDecode(buffer);\n\n\t\tthis.shift(length);\n\n\t\treturn value;\n\t}\n\t/**\n\t * Read a BCS vector: read a length and then apply function `cb` X times\n\t * where X is the length of the vector, defined as ULEB in BCS bytes.\n\t * @param cb Callback to process elements of vector.\n\t * @returns {Array<Any>} Array of the resulting values, returned by callback.\n\t */\n\treadVec(cb: (reader: BcsReader, i: number, length: number) => any): any[] {\n\t\tlet length = this.readULEB();\n\t\tlet result = [];\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult.push(cb(this, i, length));\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/**\n * Class used to write BCS data into a buffer. Initializer requires\n * some size of a buffer to init; default value for this buffer is 1KB.\n *\n * Most methods are chainable, so it is possible to write them in one go.\n *\n * @example\n * let serialized = new BcsWriter()\n *   .write8(10)\n *   .write32(1000000)\n *   .write64(10000001000000)\n *   .hex();\n */\n\ninterface BcsWriterOptions {\n\t/** The initial size (in bytes) of the buffer tht will be allocated */\n\tsize?: number;\n\t/** The maximum size (in bytes) that the buffer is allowed to grow to */\n\tmaxSize?: number;\n\t/** The amount of bytes that will be allocated whenever additional memory is required */\n\tallocateSize?: number;\n}\n\nexport class BcsWriter {\n\tprivate dataView: DataView;\n\tprivate bytePosition: number = 0;\n\tprivate size: number;\n\tprivate maxSize: number;\n\tprivate allocateSize: number;\n\n\tconstructor({ size = 1024, maxSize, allocateSize = 1024 }: BcsWriterOptions = {}) {\n\t\tthis.size = size;\n\t\tthis.maxSize = maxSize || size;\n\t\tthis.allocateSize = allocateSize;\n\t\tthis.dataView = new DataView(new ArrayBuffer(size));\n\t}\n\n\tprivate ensureSizeOrGrow(bytes: number) {\n\t\tconst requiredSize = this.bytePosition + bytes;\n\t\tif (requiredSize > this.size) {\n\t\t\tconst nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n\t\t\tif (requiredSize > nextSize) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tthis.size = nextSize;\n\t\t\tconst nextBuffer = new ArrayBuffer(this.size);\n\t\t\tnew Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n\t\t\tthis.dataView = new DataView(nextBuffer);\n\t\t}\n\t}\n\n\t/**\n\t * Shift current cursor position by `bytes`.\n\t *\n\t * @param {Number} bytes Number of bytes to\n\t * @returns {this} Self for possible chaining.\n\t */\n\tshift(bytes: number): this {\n\t\tthis.bytePosition += bytes;\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U8 value into a buffer and shift cursor position by 1.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite8(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(1);\n\t\tthis.dataView.setUint8(this.bytePosition, Number(value));\n\t\treturn this.shift(1);\n\t}\n\t/**\n\t * Write a U16 value into a buffer and shift cursor position by 2.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite16(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(2);\n\t\tthis.dataView.setUint16(this.bytePosition, Number(value), true);\n\t\treturn this.shift(2);\n\t}\n\t/**\n\t * Write a U32 value into a buffer and shift cursor position by 4.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twrite32(value: number | bigint): this {\n\t\tthis.ensureSizeOrGrow(4);\n\t\tthis.dataView.setUint32(this.bytePosition, Number(value), true);\n\t\treturn this.shift(4);\n\t}\n\t/**\n\t * Write a U64 value into a buffer and shift cursor position by 8.\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite64(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 8).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U128 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite128(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 16).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a U256 value into a buffer and shift cursor position by 16.\n\t *\n\t * @param {bigint} value Value to write.\n\t * @returns {this}\n\t */\n\twrite256(value: number | bigint): this {\n\t\ttoLittleEndian(BigInt(value), 32).forEach((el) => this.write8(el));\n\n\t\treturn this;\n\t}\n\t/**\n\t * Write a ULEB value into a buffer and shift cursor position by number of bytes\n\t * written.\n\t * @param {Number} value Value to write.\n\t * @returns {this}\n\t */\n\twriteULEB(value: number): this {\n\t\tulebEncode(value).forEach((el) => this.write8(el));\n\t\treturn this;\n\t}\n\t/**\n\t * Write a vector into a buffer by first writing the vector length and then calling\n\t * a callback on each passed value.\n\t *\n\t * @param {Array<Any>} vector Array of elements to write.\n\t * @param {WriteVecCb} cb Callback to call on each element of the vector.\n\t * @returns {this}\n\t */\n\twriteVec(vector: any[], cb: (writer: BcsWriter, el: any, i: number, len: number) => void): this {\n\t\tthis.writeULEB(vector.length);\n\t\tArray.from(vector).forEach((el, i) => cb(this, el, i, vector.length));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds support for iterations over the object.\n\t * @returns {Uint8Array}\n\t */\n\t*[Symbol.iterator](): Iterator<number, Iterable<number>> {\n\t\tfor (let i = 0; i < this.bytePosition; i++) {\n\t\t\tyield this.dataView.getUint8(i);\n\t\t}\n\t\treturn this.toBytes();\n\t}\n\n\t/**\n\t * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n\t * @returns {Uint8Array} Resulting bcs.\n\t */\n\ttoBytes(): Uint8Array {\n\t\treturn new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n\t}\n\n\t/**\n\t * Represent data as 'hex' or 'base64'\n\t * @param encoding Encoding to use: 'base64' or 'hex'\n\t */\n\ttoString(encoding: Encoding): string {\n\t\treturn encodeStr(this.toBytes(), encoding);\n\t}\n}\n\n// Helper utility: write number as an ULEB array.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nfunction ulebEncode(num: number): number[] {\n\tlet arr = [];\n\tlet len = 0;\n\n\tif (num === 0) {\n\t\treturn [0];\n\t}\n\n\twhile (num > 0) {\n\t\tarr[len] = num & 0x7f;\n\t\tif ((num >>= 7)) {\n\t\t\tarr[len] |= 0x80;\n\t\t}\n\t\tlen += 1;\n\t}\n\n\treturn arr;\n}\n\n// Helper utility: decode ULEB as an array of numbers.\n// Original code is taken from: https://www.npmjs.com/package/uleb128 (no longer exists)\nfunction ulebDecode(arr: number[] | Uint8Array): {\n\tvalue: number;\n\tlength: number;\n} {\n\tlet total = 0;\n\tlet shift = 0;\n\tlet len = 0;\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tlet byte = arr[len];\n\t\tlen += 1;\n\t\ttotal |= (byte & 0x7f) << shift;\n\t\tif ((byte & 0x80) === 0) {\n\t\t\tbreak;\n\t\t}\n\t\tshift += 7;\n\t}\n\n\treturn {\n\t\tvalue: total,\n\t\tlength: len,\n\t};\n}\n\n/**\n * Set of methods that allows data encoding/decoding as standalone\n * BCS value or a part of a composed structure/vector.\n */\nexport interface TypeInterface {\n\tencode: (\n\t\tself: BCS,\n\t\tdata: any,\n\t\toptions: BcsWriterOptions | undefined,\n\t\ttypeParams: TypeName[],\n\t) => BcsWriter;\n\tdecode: (self: BCS, data: Uint8Array, typeParams: TypeName[]) => any;\n\n\t_encodeRaw: (\n\t\twriter: BcsWriter,\n\t\tdata: any,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => BcsWriter;\n\t_decodeRaw: (\n\t\treader: BcsReader,\n\t\ttypeParams: TypeName[],\n\t\ttypeMap: { [key: string]: TypeName },\n\t) => any;\n}\n\n/**\n * Struct type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerStructType`.\n */\nexport type StructTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition;\n};\n\n/**\n * Enum type definition. Used as input format in BcsConfig.types\n * as well as an argument type for `bcs.registerEnumType`.\n *\n * Value can be either `string` when invariant has a type or `null`\n * when invariant is empty.\n *\n * @example\n * bcs.registerEnumType('Option<T>', {\n *   some: 'T',\n *   none: null\n * });\n */\nexport type EnumTypeDefinition = {\n\t[key: string]: TypeName | StructTypeDefinition | null;\n};\n\n/**\n * Configuration that is passed into BCS constructor.\n */\nexport type BcsConfig = {\n\t/**\n\t * Defines type name for the vector / array type.\n\t * In Move: `vector<T>` or `vector`.\n\t */\n\tvectorType: string;\n\t/**\n\t * Address length. Varies depending on a platform and\n\t * has to be specified for the `address` type.\n\t */\n\taddressLength: number;\n\n\t/**\n\t * Custom encoding for address. Supported values are\n\t * either 'hex' or 'base64'.\n\t */\n\taddressEncoding?: 'hex' | 'base64';\n\t/**\n\t * Opening and closing symbol for type parameters. Can be\n\t * any pair of symbols (eg `['(', ')']`); default value follows\n\t * Rust and Move: `<` and `>`.\n\t */\n\tgenericSeparators?: [string, string];\n\t/**\n\t * Type definitions for the BCS. This field allows spawning\n\t * BCS instance from JSON or another prepared configuration.\n\t * Optional.\n\t */\n\ttypes?: {\n\t\tstructs?: { [key: string]: StructTypeDefinition };\n\t\tenums?: { [key: string]: EnumTypeDefinition };\n\t\taliases?: { [key: string]: string };\n\t};\n\t/**\n\t * Whether to auto-register primitive types on launch.\n\t */\n\twithPrimitives?: boolean;\n};\n\n/**\n * BCS implementation for Move types and few additional built-ins.\n */\nexport class BCS {\n\t// Prefefined types constants\n\tstatic readonly U8: string = 'u8';\n\tstatic readonly U16: string = 'u16';\n\tstatic readonly U32: string = 'u32';\n\tstatic readonly U64: string = 'u64';\n\tstatic readonly U128: string = 'u128';\n\tstatic readonly U256: string = 'u256';\n\tstatic readonly BOOL: string = 'bool';\n\tstatic readonly VECTOR: string = 'vector';\n\tstatic readonly ADDRESS: string = 'address';\n\tstatic readonly STRING: string = 'string';\n\tstatic readonly HEX: string = 'hex-string';\n\tstatic readonly BASE58: string = 'base58-string';\n\tstatic readonly BASE64: string = 'base64-string';\n\n\t/**\n\t * Map of kind `TypeName => TypeInterface`. Holds all\n\t * callbacks for (de)serialization of every registered type.\n\t *\n\t * If the value stored is a string, it is treated as an alias.\n\t */\n\tpublic types: Map<string, TypeInterface | string> = new Map();\n\n\t/**\n\t * Stored BcsConfig for the current instance of BCS.\n\t */\n\tprotected schema: BcsConfig;\n\n\t/**\n\t * Count temp keys to generate a new one when requested.\n\t */\n\tprotected counter: number = 0;\n\n\t/**\n\t * Name of the key to use for temporary struct definitions.\n\t * Returns a temp key + index (for a case when multiple temp\n\t * structs are processed).\n\t */\n\tprivate tempKey() {\n\t\treturn `bcs-struct-${++this.counter}`;\n\t}\n\n\t/**\n\t * Construct a BCS instance with a prepared schema.\n\t *\n\t * @param schema A prepared schema with type definitions\n\t * @param withPrimitives Whether to register primitive types by default\n\t */\n\tconstructor(schema: BcsConfig | BCS) {\n\t\t// if BCS instance is passed -> clone its schema\n\t\tif (schema instanceof BCS) {\n\t\t\tthis.schema = schema.schema;\n\t\t\tthis.types = new Map(schema.types);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.schema = schema;\n\n\t\t// Register address type under key 'address'.\n\t\tthis.registerAddressType(BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n\t\tthis.registerVectorType(schema.vectorType);\n\n\t\t// Register struct types if they were passed.\n\t\tif (schema.types && schema.types.structs) {\n\t\t\tfor (let name of Object.keys(schema.types.structs)) {\n\t\t\t\tthis.registerStructType(name, schema.types.structs[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register enum types if they were passed.\n\t\tif (schema.types && schema.types.enums) {\n\t\t\tfor (let name of Object.keys(schema.types.enums)) {\n\t\t\t\tthis.registerEnumType(name, schema.types.enums[name]);\n\t\t\t}\n\t\t}\n\n\t\t// Register aliases if they were passed.\n\t\tif (schema.types && schema.types.aliases) {\n\t\t\tfor (let name of Object.keys(schema.types.aliases)) {\n\t\t\t\tthis.registerAlias(name, schema.types.aliases[name]);\n\t\t\t}\n\t\t}\n\n\t\tif (schema.withPrimitives !== false) {\n\t\t\tregisterPrimitives(this);\n\t\t}\n\t}\n\n\t/**\n\t * Serialize data into bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<u8>', 'u8');\n\t *\n\t * let serialized = BCS\n\t *   .set('vector<u8>', [1,2,3,4,5,6])\n\t *   .toBytes();\n\t *\n\t * console.assert(toHex(serialized) === '06010203040506');\n\t *\n\t * @param type Name of the type to serialize (must be registered) or a struct type.\n\t * @param data Data to serialize.\n\t * @param size Serialization buffer size. Default 1024 = 1KB.\n\t * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n\t */\n\tpublic ser(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: any,\n\t\toptions?: BcsWriterOptions,\n\t): BcsWriter {\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).encode(this, data, options, params as string[]);\n\t\t}\n\n\t\t// Quick serialization without registering the type in the main struct.\n\t\tif (typeof type === 'object') {\n\t\t\tconst key = this.tempKey();\n\t\t\tconst temp = new BCS(this);\n\t\t\treturn temp.registerStructType(key, type).ser(key, data, options);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.ser()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Deserialize BCS into a JS type.\n\t *\n\t * @example\n\t * let num = bcs.ser('u64', '4294967295').toString('hex');\n\t * let deNum = bcs.de('u64', num, 'hex');\n\t * console.assert(deNum.toString(10) === '4294967295');\n\t *\n\t * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n\t * @param data Data to deserialize.\n\t * @param encoding Optional - encoding to use if data is of type String\n\t * @return Deserialized data.\n\t */\n\tpublic de(\n\t\ttype: TypeName | StructTypeDefinition,\n\t\tdata: Uint8Array | string,\n\t\tencoding?: Encoding,\n\t): any {\n\t\tif (typeof data === 'string') {\n\t\t\tif (encoding) {\n\t\t\t\tdata = decodeStr(data, encoding);\n\t\t\t} else {\n\t\t\t\tthrow new Error('To pass a string to `bcs.de`, specify encoding');\n\t\t\t}\n\t\t}\n\n\t\t// In case the type specified is already registered.\n\t\tif (typeof type === 'string' || Array.isArray(type)) {\n\t\t\tconst { name, params } = this.parseTypeName(type);\n\t\t\treturn this.getTypeInterface(name).decode(this, data, params as string[]);\n\t\t}\n\n\t\t// Deserialize without registering a type using a temporary clone.\n\t\tif (typeof type === 'object') {\n\t\t\tconst temp = new BCS(this);\n\t\t\tconst key = this.tempKey();\n\t\t\treturn temp.registerStructType(key, type).de(key, data, encoding);\n\t\t}\n\n\t\tthrow new Error(`Incorrect type passed into the '.de()' function. \\n${JSON.stringify(type)}`);\n\t}\n\n\t/**\n\t * Check whether a `TypeInterface` has been loaded for a `type`.\n\t * @param type Name of the type to check.\n\t * @returns\n\t */\n\tpublic hasType(type: string): boolean {\n\t\treturn this.types.has(type);\n\t}\n\n\t/**\n\t * Create an alias for a type.\n\t * WARNING: this can potentially lead to recursion\n\t * @param name Alias to use\n\t * @param forType Type to reference\n\t * @returns\n\t *\n\t * @example\n\t * ```\n\t * let bcs = new BCS(getSuiMoveConfig());\n\t * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n\t * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n\t * ```\n\t */\n\tpublic registerAlias(name: string, forType: string): BCS {\n\t\tthis.types.set(name, forType);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Method to register new types for BCS internal representation.\n\t * For each registered type 2 callbacks must be specified and one is optional:\n\t *\n\t * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n\t * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n\t * - validateCb(data) - validate data - either return bool or throw an error\n\t *\n\t * @example\n\t * // our type would be a string that consists only of numbers\n\t * bcs.registerType('number_string',\n\t *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n\t *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n\t *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n\t * );\n\t * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n\t *\n\t * @param name\n\t * @param encodeCb Callback to encode a value.\n\t * @param decodeCb Callback to decode a value.\n\t * @param validateCb Optional validator Callback to check type before serialization.\n\t */\n\tpublic registerType(\n\t\ttypeName: TypeName,\n\t\tencodeCb: (\n\t\t\twriter: BcsWriter,\n\t\t\tdata: any,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => BcsWriter,\n\t\tdecodeCb: (\n\t\t\treader: BcsReader,\n\t\t\ttypeParams: TypeName[],\n\t\t\ttypeMap: { [key: string]: TypeName },\n\t\t) => any,\n\t\tvalidateCb: (data: any) => boolean = () => true,\n\t): BCS {\n\t\tconst { name, params: generics } = this.parseTypeName(typeName);\n\n\t\tthis.types.set(name, {\n\t\t\tencode(self: BCS, data, options: BcsWriterOptions, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._encodeRaw.call(self, new BcsWriter(options), data, typeParams, typeMap);\n\t\t\t},\n\t\t\tdecode(self: BCS, data, typeParams) {\n\t\t\t\tconst typeMap = (generics as string[]).reduce((acc: any, value: string, index) => {\n\t\t\t\t\treturn Object.assign(acc, { [value]: typeParams[index] });\n\t\t\t\t}, {});\n\n\t\t\t\treturn this._decodeRaw.call(self, new BcsReader(data), typeParams, typeMap);\n\t\t\t},\n\n\t\t\t// these methods should always be used with caution as they require pre-defined\n\t\t\t// reader and writer and mainly exist to allow multi-field (de)serialization;\n\t\t\t_encodeRaw(writer, data, typeParams, typeMap) {\n\t\t\t\tif (validateCb(data)) {\n\t\t\t\t\treturn encodeCb.call(this, writer, data, typeParams, typeMap);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Validation failed for type ${name}, data: ${data}`);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_decodeRaw(reader, typeParams, typeMap) {\n\t\t\t\treturn decodeCb.call(this, reader, typeParams, typeMap);\n\t\t\t},\n\t\t} as TypeInterface);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Register an address type which is a sequence of U8s of specified length.\n\t * @example\n\t * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n\t * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n\t *\n\t * @param name Name of the address type.\n\t * @param length Byte length of the address.\n\t * @param encoding Encoding to use for the address type\n\t * @returns\n\t */\n\tpublic registerAddressType(name: string, length: number, encoding: Encoding | void = 'hex'): BCS {\n\t\tswitch (encoding) {\n\t\t\tcase 'base64':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromB64(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toB64(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tcase 'hex':\n\t\t\t\treturn this.registerType(\n\t\t\t\t\tname,\n\t\t\t\t\tfunction encodeAddress(writer, data: string) {\n\t\t\t\t\t\treturn fromHEX(data).reduce((writer, el) => writer.write8(el), writer);\n\t\t\t\t\t},\n\t\t\t\t\tfunction decodeAddress(reader) {\n\t\t\t\t\t\treturn toHEX(reader.readBytes(length));\n\t\t\t\t\t},\n\t\t\t\t);\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unsupported encoding! Use either hex or base64');\n\t\t}\n\t}\n\n\t/**\n\t * Register custom vector type inside the bcs.\n\t *\n\t * @example\n\t * bcs.registerVectorType('vector<T>'); // generic registration\n\t * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n\t * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n\t *\n\t * @param name Name of the type to register\n\t * @param elementType Optional name of the inner type of the vector\n\t * @return Returns self for chaining.\n\t */\n\tprivate registerVectorType(typeName: string): BCS {\n\t\tlet { name, params } = this.parseTypeName(typeName);\n\t\tif (params.length > 1) {\n\t\t\tthrow new Error('Vector can have only one type parameter; got ' + name);\n\t\t}\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeVector(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: any[],\n\t\t\t\ttypeParams: TypeName[],\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\treturn writer.writeVec(data, (writer, el) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(this, writer, el, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tel,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t\tfunction decodeVector(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\treturn reader.readVec((reader) => {\n\t\t\t\t\tlet elementType: TypeName = typeParams[0];\n\t\t\t\t\tif (!elementType) {\n\t\t\t\t\t\tthrow new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name, params } = this.parseTypeName(elementType);\n\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\treturn this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in vector; make sure you passed a generic`,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\n\t\t\t\t\treturn this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\treader,\n\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register a custom Move struct. The first argument is a name of the\n\t * struct which is only used on the FrontEnd and has no affect on serialization results,\n\t * and the second is a struct description passed as an Object.\n\t *\n\t * The description object MUST have the same order on all of the platforms (ie in Move\n\t * or in Rust).\n\t *\n\t * @example\n\t * // Move / Rust struct\n\t * // struct Coin {\n\t * //   value: u64,\n\t * //   owner: vector<u8>, // name // Vec<u8> in Rust\n\t * //   is_locked: bool,\n\t * // }\n\t *\n\t * bcs.registerStructType('Coin', {\n\t *   value: bcs.U64,\n\t *   owner: bcs.STRING,\n\t *   is_locked: bcs.BOOL\n\t * });\n\t *\n\t * // Created in Rust with diem/bcs\n\t * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n\t * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n\t *  128, 209, 177,   5,  96,  0,  0,\n\t *    0,  14,  66, 105, 103, 32, 87,\n\t *   97, 108, 108, 101, 116, 32, 71,\n\t *  117, 121,   0\n\t * ];\n\t *\n\t * // Let's encode the value as well\n\t * let test_set = bcs.ser('Coin', {\n\t *   owner: 'Big Wallet Guy',\n\t *   value: '412412400000',\n\t *   is_locked: false,\n\t * });\n\t *\n\t * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n\t *\n\t * @param name Name of the type to register.\n\t * @param fields Fields of the struct. Must be in the correct order.\n\t * @return Returns BCS for chaining.\n\t */\n\tpublic registerStructType(typeName: TypeName, fields: StructTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in fields) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = fields[key];\n\n\t\t\t// TODO: add a type guard here?\n\t\t\tif (!Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tfields[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(fields); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: we need to store canonical order of fields for each registered\n\t\t// struct so we maintain it and allow developers to use any field ordering in\n\t\t// their code (and not cause mismatches based on field order).\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Holds generics for the struct definition. At this stage we can check that\n\t\t// generic parameter matches the one defined in the struct.\n\t\tlet { name: structName, params: generics } = this.parseTypeName(typeName);\n\n\t\t// Make sure all the types in the fields description are already known\n\t\t// and that all the field types are strings.\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeStruct(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data || data.constructor !== Object) {\n\t\t\t\t\tthrow new Error(`Expected ${structName} to be an Object, got: ${data}`);\n\t\t\t\t}\n\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// follow the canonical order when serializing\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tif (!(key in data)) {\n\t\t\t\t\t\tthrow new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Before deserializing, read the canonical field type.\n\t\t\t\t\tconst { name: fieldType, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// Check whether this type is a generic defined in this struct.\n\t\t\t\t\t// If it is -> read the type parameter matching its index.\n\t\t\t\t\t// If not - tread as a regular field.\n\t\t\t\t\tif (!generics.includes(fieldType)) {\n\t\t\t\t\t\tthis.getTypeInterface(fieldType)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tfieldParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldType);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tthis.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\t\tparams as string[],\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Alternatively, if it's a global generic parameter...\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tthis.getTypeInterface(innerName)._encodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\twriter,\n\t\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn writer;\n\t\t\t},\n\t\t\tfunction decodeStruct(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tif (typeParams.length !== generics.length) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet result: { [key: string]: any } = {};\n\t\t\t\tfor (let key of canonicalOrder) {\n\t\t\t\t\tconst { name: fieldName, params: fieldParams } = this.parseTypeName(\n\t\t\t\t\t\tstruct[key] as TypeName,\n\t\t\t\t\t);\n\n\t\t\t\t\t// if it's not a generic\n\t\t\t\t\tif (!generics.includes(fieldName)) {\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(fieldName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tfieldParams as string[],\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst paramIdx = generics.indexOf(fieldName);\n\t\t\t\t\t\tlet { name, params } = this.parseTypeName(typeParams[paramIdx]);\n\n\t\t\t\t\t\t// If the type from the type parameters already exists\n\t\t\t\t\t\t// and known -> proceed with type decoding.\n\t\t\t\t\t\tif (this.hasType(name)) {\n\t\t\t\t\t\t\tresult[key] = this.getTypeInterface(name)._decodeRaw.call(\n\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\t\tparams,\n\t\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(name in typeMap)) {\n\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n\t\t\t\t\t\tresult[key] = this.getTypeInterface(innerName)._decodeRaw.call(\n\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\treader,\n\t\t\t\t\t\t\tinnerParams,\n\t\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t},\n\t\t);\n\t}\n\n\t/**\n\t * Safe method to register custom enum type where each invariant holds the value of another type.\n\t * @example\n\t * bcs.registerStructType('Coin', { value: 'u64' });\n\t * bcs.registerEnumType('MyEnum', {\n\t *  single: 'Coin',\n\t *  multi: 'vector<Coin>',\n\t *  empty: null\n\t * });\n\t *\n\t * console.log(\n\t *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n\t *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n\t * )\n\t *\n\t * // and serialization\n\t * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n\t * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n\t *\n\t * @param name\n\t * @param variants\n\t */\n\tpublic registerEnumType(typeName: TypeName, variants: EnumTypeDefinition): BCS {\n\t\t// When an Object is passed, we register it under a new key and store it\n\t\t// in the registered type system. This way we allow nested inline definitions.\n\t\tfor (let key in variants) {\n\t\t\tlet internalName = this.tempKey();\n\t\t\tlet value = variants[key];\n\n\t\t\tif (value !== null && !Array.isArray(value) && typeof value !== 'string') {\n\t\t\t\tvariants[key] = internalName;\n\t\t\t\tthis.registerStructType(internalName, value as StructTypeDefinition);\n\t\t\t}\n\t\t}\n\n\t\tlet struct = Object.freeze(variants); // Make sure the order doesn't get changed\n\n\t\t// IMPORTANT: enum is an ordered type and we have to preserve ordering in BCS\n\t\tlet canonicalOrder = Object.keys(struct);\n\n\t\t// Parse type parameters in advance to know the index of each generic parameter.\n\t\tlet { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\n\n\t\treturn this.registerType(\n\t\t\ttypeName,\n\t\t\tfunction encodeEnum(\n\t\t\t\tthis: BCS,\n\t\t\t\twriter: BcsWriter,\n\t\t\t\tdata: { [key: string]: any | null },\n\t\t\t\ttypeParams,\n\t\t\t\ttypeMap,\n\t\t\t) {\n\t\t\t\tif (!data) {\n\t\t\t\t\tthrow new Error(`Unable to write enum \"${name}\", missing data.\\nReceived: \"${data}\"`);\n\t\t\t\t}\n\t\t\t\tif (typeof data !== 'object') {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\".\\nReceived: \"${JSON.stringify(data)}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tlet key = Object.keys(data)[0];\n\t\t\t\tif (key === undefined) {\n\t\t\t\t\tthrow new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n\t\t\t\t}\n\n\t\t\t\tlet orderByte = canonicalOrder.indexOf(key);\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\n\t\t\t\t\t\t\t' | ',\n\t\t\t\t\t\t)}\"; received \"${key}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\t// write order byte\n\t\t\t\twriter.write8(orderByte);\n\n\t\t\t\t// When { \"key\": null } - empty value for the invariant.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn writer;\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn this.getTypeInterface(name)._encodeRaw.call(\n\t\t\t\t\t\tthis,\n\t\t\t\t\t\twriter,\n\t\t\t\t\t\tdata[key],\n\t\t\t\t\t\tparams,\n\t\t\t\t\t\ttypeMap,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t},\n\t\t\tfunction decodeEnum(this: BCS, reader: BcsReader, typeParams, typeMap) {\n\t\t\t\tlet orderByte = reader.readULEB();\n\t\t\t\tlet invariant = canonicalOrder[orderByte];\n\t\t\t\tlet invariantType = struct[invariant] as TypeName | null;\n\n\t\t\t\tif (orderByte === -1) {\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Encode an empty value for the enum.\n\t\t\t\tif (invariantType === null) {\n\t\t\t\t\treturn { [invariant]: true };\n\t\t\t\t}\n\n\t\t\t\tlet paramIndex = canonicalTypeParams.indexOf(invariantType);\n\t\t\t\tlet typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n\n\t\t\t\t{\n\t\t\t\t\tlet { name, params } = this.parseTypeName(typeOrParam);\n\t\t\t\t\treturn {\n\t\t\t\t\t\t[invariant]: this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap),\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t}\n\t/**\n\t * Get a set of encoders/decoders for specific type.\n\t * Mainly used to define custom type de/serialization logic.\n\t *\n\t * @param type\n\t * @returns {TypeInterface}\n\t */\n\tpublic getTypeInterface(type: string): TypeInterface {\n\t\tlet typeInterface = this.types.get(type);\n\n\t\t// Special case - string means an alias.\n\t\t// Goes through the alias chain and tracks recursion.\n\t\tif (typeof typeInterface === 'string') {\n\t\t\tlet chain: string[] = [];\n\t\t\twhile (typeof typeInterface === 'string') {\n\t\t\t\tif (chain.includes(typeInterface)) {\n\t\t\t\t\tthrow new Error(`Recursive definition found: ${chain.join(' -> ')} -> ${typeInterface}`);\n\t\t\t\t}\n\t\t\t\tchain.push(typeInterface);\n\t\t\t\ttypeInterface = this.types.get(typeInterface);\n\t\t\t}\n\t\t}\n\n\t\tif (typeInterface === undefined) {\n\t\t\tthrow new Error(`Type ${type} is not registered`);\n\t\t}\n\n\t\treturn typeInterface;\n\t}\n\n\t/**\n\t * Parse a type name and get the type's generics.\n\t * @example\n\t * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n\t * // typeName: Option\n\t * // typeParams: [ 'Coin<SUI>' ]\n\t *\n\t * @param name Name of the type to process\n\t * @returns Object with typeName and typeParams listed as Array\n\t */\n\tpublic parseTypeName(name: TypeName): {\n\t\tname: string;\n\t\tparams: TypeName[];\n\t} {\n\t\tif (Array.isArray(name)) {\n\t\t\tlet [typeName, ...params] = name;\n\t\t\treturn { name: typeName, params };\n\t\t}\n\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new Error(`Illegal type passed as a name of the type: ${name}`);\n\t\t}\n\n\t\tlet [left, right] = this.schema.genericSeparators || ['<', '>'];\n\n\t\tlet l_bound = name.indexOf(left);\n\t\tlet r_bound = Array.from(name).reverse().indexOf(right);\n\n\t\t// if there are no generics - exit gracefully.\n\t\tif (l_bound === -1 && r_bound === -1) {\n\t\t\treturn { name: name, params: [] };\n\t\t}\n\n\t\t// if one of the bounds is not defined - throw an Error.\n\t\tif (l_bound === -1 || r_bound === -1) {\n\t\t\tthrow new Error(`Unclosed generic in name '${name}'`);\n\t\t}\n\n\t\tlet typeName = name.slice(0, l_bound);\n\t\tlet params = splitGenericParameters(\n\t\t\tname.slice(l_bound + 1, name.length - r_bound - 1),\n\t\t\tthis.schema.genericSeparators,\n\t\t);\n\n\t\treturn { name: typeName, params };\n\t}\n}\n\n/**\n * Encode data with either `hex` or `base64`.\n *\n * @param {Uint8Array} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {String} Encoded value.\n */\nexport function encodeStr(data: Uint8Array, encoding: Encoding): string {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn toB58(data);\n\t\tcase 'base64':\n\t\t\treturn toB64(data);\n\t\tcase 'hex':\n\t\t\treturn toHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Decode either `base64` or `hex` data.\n *\n * @param {String} data Data to encode.\n * @param {String} encoding Encoding to use: base64 or hex\n * @return {Uint8Array} Encoded value.\n */\nexport function decodeStr(data: string, encoding: Encoding): Uint8Array {\n\tswitch (encoding) {\n\t\tcase 'base58':\n\t\t\treturn fromB58(data);\n\t\tcase 'base64':\n\t\t\treturn fromB64(data);\n\t\tcase 'hex':\n\t\t\treturn fromHEX(data);\n\t\tdefault:\n\t\t\tthrow new Error('Unsupported encoding, supported values are: base64, hex');\n\t}\n}\n\n/**\n * Register the base set of primitive and common types.\n * Is called in the `BCS` constructor automatically but can\n * be ignored if the `withPrimitives` argument is not set.\n */\nexport function registerPrimitives(bcs: BCS): void {\n\tbcs.registerType(\n\t\tBCS.U8,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8();\n\t\t},\n\t\t(u8) => u8 < 256,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U16,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write16(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read16();\n\t\t},\n\t\t(u16) => u16 < 65536,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U32,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write32(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read32();\n\t\t},\n\t\t(u32) => u32 <= 4294967296n,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U64,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write64(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read64();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U128,\n\t\tfunction (writer: BcsWriter, data: bigint) {\n\t\t\treturn writer.write128(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read128();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.U256,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write256(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read256();\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BOOL,\n\t\tfunction (writer: BcsWriter, data) {\n\t\t\treturn writer.write8(data);\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader.read8().toString(10) === '1';\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.STRING,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(data), (writer, el) => writer.write8(el.charCodeAt(0)));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\treturn reader\n\t\t\t\t.readVec((reader) => reader.read8())\n\t\t\t\t.map((el: bigint) => String.fromCharCode(Number(el)))\n\t\t\t\t.join('');\n\t\t},\n\t\t(_str: string) => true,\n\t);\n\n\tbcs.registerType(\n\t\tBCS.HEX,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromHEX(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toHEX(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE58,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB58(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB58(new Uint8Array(bytes));\n\t\t},\n\t);\n\n\tbcs.registerType(\n\t\tBCS.BASE64,\n\t\tfunction (writer: BcsWriter, data: string) {\n\t\t\treturn writer.writeVec(Array.from(fromB64(data)), (writer, el) => writer.write8(el));\n\t\t},\n\t\tfunction (reader: BcsReader) {\n\t\t\tlet bytes = reader.readVec((reader) => reader.read8());\n\t\t\treturn toB64(new Uint8Array(bytes));\n\t\t},\n\t);\n}\n\nexport function getRustConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'Vec',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n\nexport function getSuiMoveConfig(): BcsConfig {\n\treturn {\n\t\tgenericSeparators: ['<', '>'],\n\t\tvectorType: 'vector',\n\t\taddressLength: SUI_ADDRESS_LENGTH,\n\t\taddressEncoding: 'hex',\n\t};\n}\n\nexport function splitGenericParameters(\n\tstr: string,\n\tgenericSeparators: [string, string] = ['<', '>'],\n) {\n\tconst [left, right] = genericSeparators;\n\tconst tok = [];\n\tlet word = '';\n\tlet nestedAngleBrackets = 0;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst char = str[i];\n\t\tif (char === left) {\n\t\t\tnestedAngleBrackets++;\n\t\t}\n\t\tif (char === right) {\n\t\t\tnestedAngleBrackets--;\n\t\t}\n\t\tif (nestedAngleBrackets === 0 && char === ',') {\n\t\t\ttok.push(word.trim());\n\t\t\tword = '';\n\t\t\tcontinue;\n\t\t}\n\t\tword += char;\n\t}\n\n\ttok.push(word.trim());\n\n\treturn tok;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}