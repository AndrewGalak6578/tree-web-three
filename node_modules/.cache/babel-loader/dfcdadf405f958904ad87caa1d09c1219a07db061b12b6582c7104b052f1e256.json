{"ast":null,"code":"import { BCS } from \"@mysten/bcs\";\nimport { bcs } from \"../types/sui-bcs.js\";\nimport { normalizeSuiAddress } from \"../types/index.js\";\nimport { TypeTagSerializer } from \"../signers/txn-data-serializers/type-tag-serializer.js\";\nconst ARGUMENT_INNER = \"Argument\";\nconst VECTOR = \"vector\";\nconst OPTION = \"Option\";\nconst CALL_ARG = \"CallArg\";\nconst TYPE_TAG = \"TypeTag\";\nconst OBJECT_ARG = \"ObjectArg\";\nconst PROGRAMMABLE_TX_BLOCK = \"ProgrammableTransaction\";\nconst PROGRAMMABLE_CALL_INNER = \"ProgrammableMoveCall\";\nconst TRANSACTION_INNER = \"Transaction\";\nconst COMPRESSED_SIGNATURE = \"CompressedSignature\";\nconst PUBLIC_KEY = \"PublicKey\";\nconst MULTISIG_PUBLIC_KEY = \"MultiSigPublicKey\";\nconst MULTISIG_PK_MAP = \"MultiSigPkMap\";\nconst MULTISIG = \"MultiSig\";\nconst ENUM_KIND = \"EnumKind\";\nconst TRANSACTION = [ENUM_KIND, TRANSACTION_INNER];\nconst ARGUMENT = [ENUM_KIND, ARGUMENT_INNER];\nconst PROGRAMMABLE_CALL = \"SimpleProgrammableMoveCall\";\nconst builder = new BCS(bcs);\nregisterFixedArray(builder, \"FixedArray[64]\", 64);\nregisterFixedArray(builder, \"FixedArray[33]\", 33);\nregisterFixedArray(builder, \"FixedArray[32]\", 32);\nbuilder.registerStructType(PROGRAMMABLE_TX_BLOCK, {\n  inputs: [VECTOR, CALL_ARG],\n  transactions: [VECTOR, TRANSACTION]\n}).registerEnumType(ARGUMENT_INNER, {\n  GasCoin: null,\n  Input: {\n    index: BCS.U16\n  },\n  Result: {\n    index: BCS.U16\n  },\n  NestedResult: {\n    index: BCS.U16,\n    resultIndex: BCS.U16\n  }\n}).registerStructType(PROGRAMMABLE_CALL_INNER, {\n  package: BCS.ADDRESS,\n  module: BCS.STRING,\n  function: BCS.STRING,\n  type_arguments: [VECTOR, TYPE_TAG],\n  arguments: [VECTOR, ARGUMENT]\n}).registerEnumType(TRANSACTION_INNER, {\n  /**\n   * A Move Call - any public Move function can be called via\n   * this transaction. The results can be used that instant to pass\n   * into the next transaction.\n   */\n  MoveCall: PROGRAMMABLE_CALL,\n  /**\n   * Transfer vector of objects to a receiver.\n   */\n  TransferObjects: {\n    objects: [VECTOR, ARGUMENT],\n    address: ARGUMENT\n  },\n  /**\n   * Split `amount` from a `coin`.\n   */\n  SplitCoins: {\n    coin: ARGUMENT,\n    amounts: [VECTOR, ARGUMENT]\n  },\n  /**\n   * Merge Vector of Coins (`sources`) into a `destination`.\n   */\n  MergeCoins: {\n    destination: ARGUMENT,\n    sources: [VECTOR, ARGUMENT]\n  },\n  /**\n   * Publish a Move module.\n   */\n  Publish: {\n    modules: [VECTOR, [VECTOR, BCS.U8]],\n    dependencies: [VECTOR, BCS.ADDRESS]\n  },\n  /**\n   * Build a vector of objects using the input arguments.\n   * It is impossible to construct a `vector<T: key>` otherwise,\n   * so this call serves a utility function.\n   */\n  MakeMoveVec: {\n    type: [OPTION, TYPE_TAG],\n    objects: [VECTOR, ARGUMENT]\n  },\n  /**  */\n  Upgrade: {\n    modules: [VECTOR, [VECTOR, BCS.U8]],\n    dependencies: [VECTOR, BCS.ADDRESS],\n    packageId: BCS.ADDRESS,\n    ticket: ARGUMENT\n  }\n}).registerEnumType(COMPRESSED_SIGNATURE, {\n  ED25519: [\"FixedArray[64]\", \"u8\"],\n  Secp256k1: [\"FixedArray[64]\", \"u8\"],\n  Secp256r1: [\"FixedArray[64]\", \"u8\"]\n}).registerEnumType(PUBLIC_KEY, {\n  ED25519: [\"FixedArray[32]\", \"u8\"],\n  Secp256k1: [\"FixedArray[33]\", \"u8\"],\n  Secp256r1: [\"FixedArray[33]\", \"u8\"]\n}).registerStructType(MULTISIG_PK_MAP, {\n  pubKey: PUBLIC_KEY,\n  weight: BCS.U8\n}).registerStructType(MULTISIG_PUBLIC_KEY, {\n  pk_map: [VECTOR, MULTISIG_PK_MAP],\n  threshold: BCS.U16\n}).registerStructType(MULTISIG, {\n  sigs: [VECTOR, COMPRESSED_SIGNATURE],\n  bitmap: BCS.U16,\n  multisig_pk: MULTISIG_PUBLIC_KEY\n});\nbuilder.registerType([ENUM_KIND, \"T\"], function encode(writer, data, typeParams, typeMap) {\n  const kind = data.kind;\n  const invariant = {\n    [kind]: data\n  };\n  const [enumType] = typeParams;\n  return this.getTypeInterface(enumType)._encodeRaw.call(this, writer, invariant, typeParams, typeMap);\n}, function decode(reader, typeParams, typeMap) {\n  const [enumType] = typeParams;\n  const data = this.getTypeInterface(enumType)._decodeRaw.call(this, reader, typeParams, typeMap);\n  const kind = Object.keys(data)[0];\n  return {\n    kind,\n    ...data[kind]\n  };\n}, data => {\n  if (typeof data !== \"object\" && !(\"kind\" in data)) {\n    throw new Error(`EnumKind: Missing property \"kind\" in the input ${JSON.stringify(data)}`);\n  }\n  return true;\n});\nbuilder.registerType(PROGRAMMABLE_CALL, function encodeProgrammableTx(writer, data, typeParams, typeMap) {\n  const [pkg, module, fun] = data.target.split(\"::\");\n  const type_arguments = data.typeArguments.map(tag => TypeTagSerializer.parseFromStr(tag, true));\n  return this.getTypeInterface(PROGRAMMABLE_CALL_INNER)._encodeRaw.call(this, writer, {\n    package: normalizeSuiAddress(pkg),\n    module,\n    function: fun,\n    type_arguments,\n    arguments: data.arguments\n  }, typeParams, typeMap);\n}, function decodeProgrammableTx(reader, typeParams, typeMap) {\n  let data = builder.getTypeInterface(PROGRAMMABLE_CALL_INNER)._decodeRaw.call(this, reader, typeParams, typeMap);\n  return {\n    target: [data.package, data.module, data.function].join(\"::\"),\n    arguments: data.arguments,\n    typeArguments: data.type_arguments.map(TypeTagSerializer.tagToString)\n  };\n},\n// Validation callback to error out if the data format is invalid.\n// TODO: make sure TypeTag can be parsed.\ndata => {\n  return data.target.split(\"::\").length === 3;\n});\nfunction registerFixedArray(bcs2, name, length) {\n  bcs2.registerType(name, function encode2(writer, data, typeParams, typeMap) {\n    if (data.length !== length) {\n      throw new Error(`Expected fixed array of length ${length}, got ${data.length}`);\n    }\n    if (typeParams.length !== 1) {\n      throw new Error(`Expected one type parameter in a fixed array, got ${typeParams.length}`);\n    }\n    let [type] = typeof typeParams[0] === \"string\" ? [typeParams[0], []] : typeParams[0];\n    for (let piece of data) {\n      this.getTypeInterface(type)._encodeRaw.call(this, writer, piece, typeParams, typeMap);\n    }\n    return writer;\n  }, function decode2(reader, typeParams, typeMap) {\n    if (typeParams.length !== 1) {\n      throw new Error(`Expected one type parameter in a fixed array, got ${typeParams.length}`);\n    }\n    let result = [];\n    let [type] = typeof typeParams[0] === \"string\" ? [typeParams[0], []] : typeParams[0];\n    for (let i = 0; i < length; i++) {\n      result.push(this.getTypeInterface(type)._decodeRaw.call(this, reader, typeParams, typeMap));\n    }\n    return result;\n  });\n}\nexport { ARGUMENT, ARGUMENT_INNER, CALL_ARG, COMPRESSED_SIGNATURE, ENUM_KIND, MULTISIG, MULTISIG_PK_MAP, MULTISIG_PUBLIC_KEY, OBJECT_ARG, OPTION, PROGRAMMABLE_CALL, PROGRAMMABLE_CALL_INNER, PROGRAMMABLE_TX_BLOCK, PUBLIC_KEY, TRANSACTION, TRANSACTION_INNER, TYPE_TAG, VECTOR, builder };","map":{"version":3,"names":["BCS","bcs","normalizeSuiAddress","TypeTagSerializer","ARGUMENT_INNER","VECTOR","OPTION","CALL_ARG","TYPE_TAG","OBJECT_ARG","PROGRAMMABLE_TX_BLOCK","PROGRAMMABLE_CALL_INNER","TRANSACTION_INNER","COMPRESSED_SIGNATURE","PUBLIC_KEY","MULTISIG_PUBLIC_KEY","MULTISIG_PK_MAP","MULTISIG","ENUM_KIND","TRANSACTION","ARGUMENT","PROGRAMMABLE_CALL","builder","registerFixedArray","registerStructType","inputs","transactions","registerEnumType","GasCoin","Input","index","U16","Result","NestedResult","resultIndex","package","ADDRESS","module","STRING","function","type_arguments","arguments","MoveCall","TransferObjects","objects","address","SplitCoins","coin","amounts","MergeCoins","destination","sources","Publish","modules","U8","dependencies","MakeMoveVec","type","Upgrade","packageId","ticket","ED25519","Secp256k1","Secp256r1","pubKey","weight","pk_map","threshold","sigs","bitmap","multisig_pk","registerType","encode","writer","data","typeParams","typeMap","kind","invariant","enumType","getTypeInterface","_encodeRaw","call","decode","reader","_decodeRaw","Object","keys","Error","JSON","stringify","encodeProgrammableTx","pkg","fun","target","split","typeArguments","map","tag","parseFromStr","decodeProgrammableTx","join","tagToString","length","bcs2","name","encode2","piece","decode2","result","i","push"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/builder/bcs.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { TypeName } from '@mysten/bcs';\nimport { BCS } from '@mysten/bcs';\nimport { bcs } from '../types/sui-bcs.js';\nimport type { TypeTag } from '../types/index.js';\nimport { normalizeSuiAddress } from '../types/index.js';\nimport { TypeTagSerializer } from '../signers/txn-data-serializers/type-tag-serializer.js';\nimport type { TransactionArgument, MoveCallTransaction } from './Transactions.js';\n\nexport const ARGUMENT_INNER = 'Argument';\nexport const VECTOR = 'vector';\nexport const OPTION = 'Option';\nexport const CALL_ARG = 'CallArg';\nexport const TYPE_TAG = 'TypeTag';\nexport const OBJECT_ARG = 'ObjectArg';\nexport const PROGRAMMABLE_TX_BLOCK = 'ProgrammableTransaction';\nexport const PROGRAMMABLE_CALL_INNER = 'ProgrammableMoveCall';\nexport const TRANSACTION_INNER = 'Transaction';\nexport const COMPRESSED_SIGNATURE = 'CompressedSignature';\nexport const PUBLIC_KEY = 'PublicKey';\nexport const MULTISIG_PUBLIC_KEY = 'MultiSigPublicKey';\nexport const MULTISIG_PK_MAP = 'MultiSigPkMap';\nexport const MULTISIG = 'MultiSig';\n\nexport const ENUM_KIND = 'EnumKind';\n\n/** Wrapper around transaction Enum to support `kind` matching in TS */\nexport const TRANSACTION: TypeName = [ENUM_KIND, TRANSACTION_INNER];\n/** Wrapper around Argument Enum to support `kind` matching in TS */\nexport const ARGUMENT: TypeName = [ENUM_KIND, ARGUMENT_INNER];\n\n/** Custom serializer for decoding package, module, function easier */\nexport const PROGRAMMABLE_CALL = 'SimpleProgrammableMoveCall';\n\n/** Transaction types */\n\nexport type Option<T> = { some: T } | { none: true };\n\nexport const builder = new BCS(bcs);\nregisterFixedArray(builder, 'FixedArray[64]', 64);\nregisterFixedArray(builder, 'FixedArray[33]', 33);\nregisterFixedArray(builder, 'FixedArray[32]', 32);\n\nbuilder\n\t.registerStructType(PROGRAMMABLE_TX_BLOCK, {\n\t\tinputs: [VECTOR, CALL_ARG],\n\t\ttransactions: [VECTOR, TRANSACTION],\n\t})\n\t.registerEnumType(ARGUMENT_INNER, {\n\t\tGasCoin: null,\n\t\tInput: { index: BCS.U16 },\n\t\tResult: { index: BCS.U16 },\n\t\tNestedResult: { index: BCS.U16, resultIndex: BCS.U16 },\n\t})\n\t.registerStructType(PROGRAMMABLE_CALL_INNER, {\n\t\tpackage: BCS.ADDRESS,\n\t\tmodule: BCS.STRING,\n\t\tfunction: BCS.STRING,\n\t\ttype_arguments: [VECTOR, TYPE_TAG],\n\t\targuments: [VECTOR, ARGUMENT],\n\t})\n\t// Keep this in sync with crates/sui-types/src/messages.rs\n\t.registerEnumType(TRANSACTION_INNER, {\n\t\t/**\n\t\t * A Move Call - any public Move function can be called via\n\t\t * this transaction. The results can be used that instant to pass\n\t\t * into the next transaction.\n\t\t */\n\t\tMoveCall: PROGRAMMABLE_CALL,\n\t\t/**\n\t\t * Transfer vector of objects to a receiver.\n\t\t */\n\t\tTransferObjects: {\n\t\t\tobjects: [VECTOR, ARGUMENT],\n\t\t\taddress: ARGUMENT,\n\t\t},\n\t\t/**\n\t\t * Split `amount` from a `coin`.\n\t\t */\n\t\tSplitCoins: { coin: ARGUMENT, amounts: [VECTOR, ARGUMENT] },\n\t\t/**\n\t\t * Merge Vector of Coins (`sources`) into a `destination`.\n\t\t */\n\t\tMergeCoins: { destination: ARGUMENT, sources: [VECTOR, ARGUMENT] },\n\t\t/**\n\t\t * Publish a Move module.\n\t\t */\n\t\tPublish: {\n\t\t\tmodules: [VECTOR, [VECTOR, BCS.U8]],\n\t\t\tdependencies: [VECTOR, BCS.ADDRESS],\n\t\t},\n\t\t/**\n\t\t * Build a vector of objects using the input arguments.\n\t\t * It is impossible to construct a `vector<T: key>` otherwise,\n\t\t * so this call serves a utility function.\n\t\t */\n\t\tMakeMoveVec: {\n\t\t\ttype: [OPTION, TYPE_TAG],\n\t\t\tobjects: [VECTOR, ARGUMENT],\n\t\t},\n\t\t/**  */\n\t\tUpgrade: {\n\t\t\tmodules: [VECTOR, [VECTOR, BCS.U8]],\n\t\t\tdependencies: [VECTOR, BCS.ADDRESS],\n\t\t\tpackageId: BCS.ADDRESS,\n\t\t\tticket: ARGUMENT,\n\t\t},\n\t})\n\t.registerEnumType(COMPRESSED_SIGNATURE, {\n\t\tED25519: ['FixedArray[64]', 'u8'],\n\t\tSecp256k1: ['FixedArray[64]', 'u8'],\n\t\tSecp256r1: ['FixedArray[64]', 'u8'],\n\t})\n\t.registerEnumType(PUBLIC_KEY, {\n\t\tED25519: ['FixedArray[32]', 'u8'],\n\t\tSecp256k1: ['FixedArray[33]', 'u8'],\n\t\tSecp256r1: ['FixedArray[33]', 'u8'],\n\t})\n\t.registerStructType(MULTISIG_PK_MAP, {\n\t\tpubKey: PUBLIC_KEY,\n\t\tweight: BCS.U8,\n\t})\n\t.registerStructType(MULTISIG_PUBLIC_KEY, {\n\t\tpk_map: [VECTOR, MULTISIG_PK_MAP],\n\t\tthreshold: BCS.U16,\n\t})\n\t.registerStructType(MULTISIG, {\n\t\tsigs: [VECTOR, COMPRESSED_SIGNATURE],\n\t\tbitmap: BCS.U16,\n\t\tmultisig_pk: MULTISIG_PUBLIC_KEY,\n\t});\n/**\n * Utilities for better decoding.\n */\n\ntype ProgrammableCallInner = {\n\tpackage: string;\n\tmodule: string;\n\tfunction: string;\n\ttype_arguments: TypeTag[];\n\targuments: TransactionArgument[];\n};\n\n/**\n * Wrapper around Enum, which transforms any `T` into an object with `kind` property:\n * @example\n * ```\n * let bcsEnum = { TransferObjects: { objects: [], address: ... } }\n * // becomes\n * let translatedEnum = { kind: 'TransferObjects', objects: [], address: ... };\n * ```\n */\nbuilder.registerType(\n\t[ENUM_KIND, 'T'],\n\tfunction encode(this: BCS, writer, data: { kind: string }, typeParams, typeMap) {\n\t\tconst kind = data.kind;\n\t\tconst invariant = { [kind]: data };\n\t\tconst [enumType] = typeParams;\n\n\t\treturn this.getTypeInterface(enumType as string)._encodeRaw.call(\n\t\t\tthis,\n\t\t\twriter,\n\t\t\tinvariant,\n\t\t\ttypeParams,\n\t\t\ttypeMap,\n\t\t);\n\t},\n\tfunction decode(this: BCS, reader, typeParams, typeMap) {\n\t\tconst [enumType] = typeParams;\n\t\tconst data = this.getTypeInterface(enumType as string)._decodeRaw.call(\n\t\t\tthis,\n\t\t\treader,\n\t\t\ttypeParams,\n\t\t\ttypeMap,\n\t\t);\n\n\t\t// enum invariant can only have one `key` field\n\t\tconst kind = Object.keys(data)[0];\n\t\treturn { kind, ...data[kind] };\n\t},\n\t(data: { kind: string }) => {\n\t\tif (typeof data !== 'object' && !('kind' in data)) {\n\t\t\tthrow new Error(`EnumKind: Missing property \"kind\" in the input ${JSON.stringify(data)}`);\n\t\t}\n\n\t\treturn true;\n\t},\n);\n\n/**\n * Custom deserializer for the ProgrammableCall.\n *\n * Hides the inner structure and gives a simpler, more convenient\n * interface to encode and decode this struct as a part of `TransactionData`.\n *\n * - `(package)::(module)::(function)` are now `target` property.\n * - `TypeTag[]` array is now passed as strings, not as a struct.\n */\nbuilder.registerType(\n\tPROGRAMMABLE_CALL,\n\tfunction encodeProgrammableTx(this: BCS, writer, data: MoveCallTransaction, typeParams, typeMap) {\n\t\tconst [pkg, module, fun] = data.target.split('::');\n\t\tconst type_arguments = data.typeArguments.map((tag) =>\n\t\t\tTypeTagSerializer.parseFromStr(tag, true),\n\t\t);\n\n\t\treturn this.getTypeInterface(PROGRAMMABLE_CALL_INNER)._encodeRaw.call(\n\t\t\tthis,\n\t\t\twriter,\n\t\t\t{\n\t\t\t\tpackage: normalizeSuiAddress(pkg),\n\t\t\t\tmodule,\n\t\t\t\tfunction: fun,\n\t\t\t\ttype_arguments,\n\t\t\t\targuments: data.arguments,\n\t\t\t} as ProgrammableCallInner,\n\t\t\ttypeParams,\n\t\t\ttypeMap,\n\t\t);\n\t},\n\tfunction decodeProgrammableTx(this: BCS, reader, typeParams, typeMap) {\n\t\tlet data: ProgrammableCallInner = builder\n\t\t\t.getTypeInterface(PROGRAMMABLE_CALL_INNER)\n\t\t\t._decodeRaw.call(this, reader, typeParams, typeMap);\n\n\t\treturn {\n\t\t\ttarget: [data.package, data.module, data.function].join('::'),\n\t\t\targuments: data.arguments,\n\t\t\ttypeArguments: data.type_arguments.map(TypeTagSerializer.tagToString),\n\t\t};\n\t},\n\t// Validation callback to error out if the data format is invalid.\n\t// TODO: make sure TypeTag can be parsed.\n\t(data: MoveCallTransaction) => {\n\t\treturn data.target.split('::').length === 3;\n\t},\n);\n\nfunction registerFixedArray(bcs: BCS, name: string, length: number) {\n\tbcs.registerType(\n\t\tname,\n\t\tfunction encode(this: BCS, writer, data, typeParams, typeMap) {\n\t\t\tif (data.length !== length) {\n\t\t\t\tthrow new Error(`Expected fixed array of length ${length}, got ${data.length}`);\n\t\t\t}\n\n\t\t\tif (typeParams.length !== 1) {\n\t\t\t\tthrow new Error(`Expected one type parameter in a fixed array, got ${typeParams.length}`);\n\t\t\t}\n\n\t\t\tlet [type] = typeof typeParams[0] === 'string' ? [typeParams[0], []] : typeParams[0];\n\n\t\t\tfor (let piece of data) {\n\t\t\t\tthis.getTypeInterface(type)._encodeRaw.call(this, writer, piece, typeParams, typeMap);\n\t\t\t}\n\n\t\t\treturn writer;\n\t\t},\n\t\tfunction decode(this: BCS, reader, typeParams, typeMap) {\n\t\t\tif (typeParams.length !== 1) {\n\t\t\t\tthrow new Error(`Expected one type parameter in a fixed array, got ${typeParams.length}`);\n\t\t\t}\n\n\t\t\tlet result: any = [];\n\t\t\tlet [type] = typeof typeParams[0] === 'string' ? [typeParams[0], []] : typeParams[0];\n\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tresult.push(this.getTypeInterface(type)._decodeRaw.call(this, reader, typeParams, typeMap));\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\t);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}