{"ast":null,"code":"import { fromB64, toB64 } from \"@mysten/bcs\";\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_FLAG } from \"./signature.js\";\nimport { Secp256r1PublicKey } from \"../keypairs/secp256r1/publickey.js\";\nimport { Secp256k1PublicKey } from \"../keypairs/secp256k1/publickey.js\";\nimport { Ed25519PublicKey } from \"../keypairs/ed25519/publickey.js\";\nimport { decodeMultiSig } from \"./multisig.js\";\nimport { Ed25519Keypair } from \"../keypairs/ed25519/keypair.js\";\nimport { Secp256k1Keypair } from \"../keypairs/secp256k1/keypair.js\";\nimport { LEGACY_PRIVATE_KEY_SIZE, PRIVATE_KEY_SIZE } from \"./keypair.js\";\nfunction toSerializedSignature(_ref) {\n  let {\n    signature,\n    signatureScheme,\n    pubKey\n  } = _ref;\n  const serializedSignature = new Uint8Array(1 + signature.length + pubKey.toBytes().length);\n  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);\n  serializedSignature.set(signature, 1);\n  serializedSignature.set(pubKey.toBytes(), 1 + signature.length);\n  return toB64(serializedSignature);\n}\nfunction toParsedSignaturePubkeyPair(serializedSignature) {\n  const bytes = fromB64(serializedSignature);\n  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];\n  if (signatureScheme === \"MultiSig\") {\n    try {\n      return decodeMultiSig(serializedSignature);\n    } catch (e) {\n      throw new Error(\"legacy multisig viewing unsupported\");\n    }\n  }\n  const SIGNATURE_SCHEME_TO_PUBLIC_KEY = {\n    ED25519: Ed25519PublicKey,\n    Secp256k1: Secp256k1PublicKey,\n    Secp256r1: Secp256r1PublicKey\n  };\n  const PublicKey = SIGNATURE_SCHEME_TO_PUBLIC_KEY[signatureScheme];\n  const signature = bytes.slice(1, bytes.length - PublicKey.SIZE);\n  const pubkeyBytes = bytes.slice(1 + signature.length);\n  const pubKey = new PublicKey(pubkeyBytes);\n  return [{\n    signatureScheme,\n    signature,\n    pubKey\n  }];\n}\nfunction toSingleSignaturePubkeyPair(serializedSignature) {\n  const res = toParsedSignaturePubkeyPair(serializedSignature);\n  if (res.length !== 1) {\n    throw Error(\"Expected a single signature\");\n  }\n  return res[0];\n}\nfunction publicKeyFromSerialized(schema, pubKey) {\n  if (schema === \"ED25519\") {\n    return new Ed25519PublicKey(pubKey);\n  }\n  if (schema === \"Secp256k1\") {\n    return new Secp256k1PublicKey(pubKey);\n  }\n  throw new Error(\"Unknown public key schema\");\n}\nfunction fromExportedKeypair(keypair) {\n  const secretKey = fromB64(keypair.privateKey);\n  switch (keypair.schema) {\n    case \"ED25519\":\n      let pureSecretKey = secretKey;\n      if (secretKey.length === LEGACY_PRIVATE_KEY_SIZE) {\n        pureSecretKey = secretKey.slice(0, PRIVATE_KEY_SIZE);\n      }\n      return Ed25519Keypair.fromSecretKey(pureSecretKey);\n    case \"Secp256k1\":\n      return Secp256k1Keypair.fromSecretKey(secretKey);\n    default:\n      throw new Error(`Invalid keypair schema ${keypair.schema}`);\n  }\n}\nexport { fromExportedKeypair, publicKeyFromSerialized, toParsedSignaturePubkeyPair, toSerializedSignature, toSingleSignaturePubkeyPair };","map":{"version":3,"names":["fromB64","toB64","SIGNATURE_FLAG_TO_SCHEME","SIGNATURE_SCHEME_TO_FLAG","Secp256r1PublicKey","Secp256k1PublicKey","Ed25519PublicKey","decodeMultiSig","Ed25519Keypair","Secp256k1Keypair","LEGACY_PRIVATE_KEY_SIZE","PRIVATE_KEY_SIZE","toSerializedSignature","_ref","signature","signatureScheme","pubKey","serializedSignature","Uint8Array","length","toBytes","set","toParsedSignaturePubkeyPair","bytes","e","Error","SIGNATURE_SCHEME_TO_PUBLIC_KEY","ED25519","Secp256k1","Secp256r1","PublicKey","slice","SIZE","pubkeyBytes","toSingleSignaturePubkeyPair","res","publicKeyFromSerialized","schema","fromExportedKeypair","keypair","secretKey","privateKey","pureSecretKey","fromSecretKey"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/utils.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n/* eslint-disable import/no-cycle */\n\nimport { fromB64, toB64 } from '@mysten/bcs';\nimport type { SerializedSignature, SignaturePubkeyPair, SignatureScheme } from './signature.js';\nimport { SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_FLAG } from './signature.js';\nimport { Secp256r1PublicKey } from '../keypairs/secp256r1/publickey.js';\nimport { Secp256k1PublicKey } from '../keypairs/secp256k1/publickey.js';\nimport { Ed25519PublicKey } from '../keypairs/ed25519/publickey.js';\nimport { decodeMultiSig } from './multisig.js';\nimport type { PublicKey } from './publickey.js';\nimport { Ed25519Keypair } from '../keypairs/ed25519/keypair.js';\nimport { Secp256k1Keypair } from '../keypairs/secp256k1/keypair.js';\nimport type { ExportedKeypair, Keypair } from './keypair.js';\nimport { LEGACY_PRIVATE_KEY_SIZE, PRIVATE_KEY_SIZE } from './keypair.js';\n\nexport function toSerializedSignature({\n\tsignature,\n\tsignatureScheme,\n\tpubKey,\n}: SignaturePubkeyPair): SerializedSignature {\n\tconst serializedSignature = new Uint8Array(1 + signature.length + pubKey.toBytes().length);\n\tserializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);\n\tserializedSignature.set(signature, 1);\n\tserializedSignature.set(pubKey.toBytes(), 1 + signature.length);\n\treturn toB64(serializedSignature);\n}\n\n/// Expects to parse a serialized signature by its signature scheme to a list of signature\n/// and public key pairs. The list is of length 1 if it is not multisig.\nexport function toParsedSignaturePubkeyPair(\n\tserializedSignature: SerializedSignature,\n): SignaturePubkeyPair[] {\n\tconst bytes = fromB64(serializedSignature);\n\tconst signatureScheme =\n\t\tSIGNATURE_FLAG_TO_SCHEME[bytes[0] as keyof typeof SIGNATURE_FLAG_TO_SCHEME];\n\n\tif (signatureScheme === 'MultiSig') {\n\t\ttry {\n\t\t\treturn decodeMultiSig(serializedSignature);\n\t\t} catch (e) {\n\t\t\t// Legacy format multisig do not render.\n\t\t\tthrow new Error('legacy multisig viewing unsupported');\n\t\t}\n\t}\n\n\tconst SIGNATURE_SCHEME_TO_PUBLIC_KEY = {\n\t\tED25519: Ed25519PublicKey,\n\t\tSecp256k1: Secp256k1PublicKey,\n\t\tSecp256r1: Secp256r1PublicKey,\n\t};\n\n\tconst PublicKey = SIGNATURE_SCHEME_TO_PUBLIC_KEY[signatureScheme];\n\n\tconst signature = bytes.slice(1, bytes.length - PublicKey.SIZE);\n\tconst pubkeyBytes = bytes.slice(1 + signature.length);\n\tconst pubKey = new PublicKey(pubkeyBytes);\n\n\treturn [\n\t\t{\n\t\t\tsignatureScheme,\n\t\t\tsignature,\n\t\t\tpubKey,\n\t\t},\n\t];\n}\n\n/// Expects to parse a single signature pubkey pair from the serialized\n/// signature. Use this only if multisig is not expected.\nexport function toSingleSignaturePubkeyPair(\n\tserializedSignature: SerializedSignature,\n): SignaturePubkeyPair {\n\tconst res = toParsedSignaturePubkeyPair(serializedSignature);\n\tif (res.length !== 1) {\n\t\tthrow Error('Expected a single signature');\n\t}\n\treturn res[0];\n}\n\nexport function publicKeyFromSerialized(schema: SignatureScheme, pubKey: string): PublicKey {\n\tif (schema === 'ED25519') {\n\t\treturn new Ed25519PublicKey(pubKey);\n\t}\n\tif (schema === 'Secp256k1') {\n\t\treturn new Secp256k1PublicKey(pubKey);\n\t}\n\tthrow new Error('Unknown public key schema');\n}\n\nexport function fromExportedKeypair(keypair: ExportedKeypair): Keypair {\n\tconst secretKey = fromB64(keypair.privateKey);\n\tswitch (keypair.schema) {\n\t\tcase 'ED25519':\n\t\t\tlet pureSecretKey = secretKey;\n\t\t\tif (secretKey.length === LEGACY_PRIVATE_KEY_SIZE) {\n\t\t\t\t// This is a legacy secret key, we need to strip the public key bytes and only read the first 32 bytes\n\t\t\t\tpureSecretKey = secretKey.slice(0, PRIVATE_KEY_SIZE);\n\t\t\t}\n\t\t\treturn Ed25519Keypair.fromSecretKey(pureSecretKey);\n\t\tcase 'Secp256k1':\n\t\t\treturn Secp256k1Keypair.fromSecretKey(secretKey);\n\t\tdefault:\n\t\t\tthrow new Error(`Invalid keypair schema ${keypair.schema}`);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}