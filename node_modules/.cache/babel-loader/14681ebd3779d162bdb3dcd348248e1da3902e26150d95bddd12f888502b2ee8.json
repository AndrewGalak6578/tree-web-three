{"ast":null,"code":"import { sha256 } from \"@noble/hashes/sha256\";\nimport { Secp256k1PublicKey } from \"./publickey.js\";\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\nimport { isValidBIP32Path, mnemonicToSeed } from \"../../cryptography/mnemonics.js\";\nimport { HDKey } from \"@scure/bip32\";\nimport { toB64 } from \"@mysten/bcs\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nconst DEFAULT_SECP256K1_DERIVATION_PATH = \"m/54'/784'/0'/0/0\";\nclass Secp256k1Keypair {\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Secp256k1Keypair} is provided.\n   *\n   * @param keypair secp256k1 keypair\n   */\n  constructor(keypair) {\n    if (keypair) {\n      this.keypair = keypair;\n    } else {\n      const secretKey = secp256k1.utils.randomPrivateKey();\n      const publicKey = secp256k1.getPublicKey(secretKey, true);\n      this.keypair = {\n        publicKey,\n        secretKey\n      };\n    }\n  }\n  /**\n   * Get the key scheme of the keypair Secp256k1\n   */\n  getKeyScheme() {\n    return \"Secp256k1\";\n  }\n  /**\n   * Generate a new random keypair\n   */\n  static generate() {\n    return new Secp256k1Keypair();\n  }\n  /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options: skip secret key validation\n   */\n  static fromSecretKey(secretKey, options) {\n    const publicKey = secp256k1.getPublicKey(secretKey, true);\n    if (!options || !options.skipValidation) {\n      const encoder = new TextEncoder();\n      const signData = encoder.encode(\"sui validation\");\n      const msgHash = bytesToHex(blake2b(signData, {\n        dkLen: 32\n      }));\n      const signature = secp256k1.sign(msgHash, secretKey);\n      if (!secp256k1.verify(signature, msgHash, publicKey, {\n        lowS: true\n      })) {\n        throw new Error(\"Provided secretKey is invalid\");\n      }\n    }\n    return new Secp256k1Keypair({\n      publicKey,\n      secretKey\n    });\n  }\n  /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   */\n  static fromSeed(seed) {\n    let publicKey = secp256k1.getPublicKey(seed, true);\n    return new Secp256k1Keypair({\n      publicKey,\n      secretKey: seed\n    });\n  }\n  /**\n   * The public key for this keypair\n   */\n  getPublicKey() {\n    return new Secp256k1PublicKey(this.keypair.publicKey);\n  }\n  /**\n   * Return the signature for the provided data.\n   */\n  signData(data) {\n    const msgHash = sha256(data);\n    const sig = secp256k1.sign(msgHash, this.keypair.secretKey, {\n      lowS: true\n    });\n    return sig.toCompactRawBytes();\n  }\n  /**\n   * Derive Secp256k1 keypair from mnemonics and path. The mnemonics must be normalized\n   * and validated against the english wordlist.\n   *\n   * If path is none, it will default to m/54'/784'/0'/0/0, otherwise the path must\n   * be compliant to BIP-32 in form m/54'/784'/{account_index}'/{change_index}/{address_index}.\n   */\n  static deriveKeypair(mnemonics, path) {\n    if (path == null) {\n      path = DEFAULT_SECP256K1_DERIVATION_PATH;\n    }\n    if (!isValidBIP32Path(path)) {\n      throw new Error(\"Invalid derivation path\");\n    }\n    const key = HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path);\n    if (key.publicKey == null || key.privateKey == null) {\n      throw new Error(\"Invalid key\");\n    }\n    return new Secp256k1Keypair({\n      publicKey: key.publicKey,\n      secretKey: key.privateKey\n    });\n  }\n  export() {\n    return {\n      schema: \"Secp256k1\",\n      privateKey: toB64(this.keypair.secretKey)\n    };\n  }\n}\nexport { DEFAULT_SECP256K1_DERIVATION_PATH, Secp256k1Keypair };","map":{"version":3,"names":["sha256","Secp256k1PublicKey","secp256k1","isValidBIP32Path","mnemonicToSeed","HDKey","toB64","bytesToHex","blake2b","DEFAULT_SECP256K1_DERIVATION_PATH","Secp256k1Keypair","constructor","keypair","secretKey","utils","randomPrivateKey","publicKey","getPublicKey","getKeyScheme","generate","fromSecretKey","options","skipValidation","encoder","TextEncoder","signData","encode","msgHash","dkLen","signature","sign","verify","lowS","Error","fromSeed","seed","data","sig","toCompactRawBytes","deriveKeypair","mnemonics","path","key","fromMasterSeed","derive","privateKey","export","schema"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/keypairs/secp256k1/keypair.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ExportedKeypair, Keypair } from '../../cryptography/keypair.js';\nimport type { PublicKey } from '../../cryptography/publickey.js';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { Secp256k1PublicKey } from './publickey.js';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { isValidBIP32Path, mnemonicToSeed } from '../../cryptography/mnemonics.js';\nimport { HDKey } from '@scure/bip32';\nimport { toB64 } from '@mysten/bcs';\nimport type { SignatureScheme } from '../../cryptography/signature.js';\nimport { bytesToHex } from '@noble/hashes/utils';\nimport { blake2b } from '@noble/hashes/blake2b';\n\nexport const DEFAULT_SECP256K1_DERIVATION_PATH = \"m/54'/784'/0'/0/0\";\n\n/**\n * Secp256k1 Keypair data\n */\nexport interface Secp256k1KeypairData {\n\tpublicKey: Uint8Array;\n\tsecretKey: Uint8Array;\n}\n\n/**\n * An Secp256k1 Keypair used for signing transactions.\n */\nexport class Secp256k1Keypair implements Keypair {\n\tprivate keypair: Secp256k1KeypairData;\n\n\t/**\n\t * Create a new keypair instance.\n\t * Generate random keypair if no {@link Secp256k1Keypair} is provided.\n\t *\n\t * @param keypair secp256k1 keypair\n\t */\n\tconstructor(keypair?: Secp256k1KeypairData) {\n\t\tif (keypair) {\n\t\t\tthis.keypair = keypair;\n\t\t} else {\n\t\t\tconst secretKey: Uint8Array = secp256k1.utils.randomPrivateKey();\n\t\t\tconst publicKey: Uint8Array = secp256k1.getPublicKey(secretKey, true);\n\n\t\t\tthis.keypair = { publicKey, secretKey };\n\t\t}\n\t}\n\n\t/**\n\t * Get the key scheme of the keypair Secp256k1\n\t */\n\tgetKeyScheme(): SignatureScheme {\n\t\treturn 'Secp256k1';\n\t}\n\n\t/**\n\t * Generate a new random keypair\n\t */\n\tstatic generate(): Secp256k1Keypair {\n\t\treturn new Secp256k1Keypair();\n\t}\n\n\t/**\n\t * Create a keypair from a raw secret key byte array.\n\t *\n\t * This method should only be used to recreate a keypair from a previously\n\t * generated secret key. Generating keypairs from a random seed should be done\n\t * with the {@link Keypair.fromSeed} method.\n\t *\n\t * @throws error if the provided secret key is invalid and validation is not skipped.\n\t *\n\t * @param secretKey secret key byte array\n\t * @param options: skip secret key validation\n\t */\n\n\tstatic fromSecretKey(\n\t\tsecretKey: Uint8Array,\n\t\toptions?: { skipValidation?: boolean },\n\t): Secp256k1Keypair {\n\t\tconst publicKey: Uint8Array = secp256k1.getPublicKey(secretKey, true);\n\t\tif (!options || !options.skipValidation) {\n\t\t\tconst encoder = new TextEncoder();\n\t\t\tconst signData = encoder.encode('sui validation');\n\t\t\tconst msgHash = bytesToHex(blake2b(signData, { dkLen: 32 }));\n\t\t\tconst signature = secp256k1.sign(msgHash, secretKey);\n\t\t\tif (!secp256k1.verify(signature, msgHash, publicKey, { lowS: true })) {\n\t\t\t\tthrow new Error('Provided secretKey is invalid');\n\t\t\t}\n\t\t}\n\t\treturn new Secp256k1Keypair({ publicKey, secretKey });\n\t}\n\n\t/**\n\t * Generate a keypair from a 32 byte seed.\n\t *\n\t * @param seed seed byte array\n\t */\n\tstatic fromSeed(seed: Uint8Array): Secp256k1Keypair {\n\t\tlet publicKey = secp256k1.getPublicKey(seed, true);\n\t\treturn new Secp256k1Keypair({ publicKey, secretKey: seed });\n\t}\n\n\t/**\n\t * The public key for this keypair\n\t */\n\tgetPublicKey(): PublicKey {\n\t\treturn new Secp256k1PublicKey(this.keypair.publicKey);\n\t}\n\n\t/**\n\t * Return the signature for the provided data.\n\t */\n\tsignData(data: Uint8Array): Uint8Array {\n\t\tconst msgHash = sha256(data);\n\t\tconst sig = secp256k1.sign(msgHash, this.keypair.secretKey, {\n\t\t\tlowS: true,\n\t\t});\n\t\treturn sig.toCompactRawBytes();\n\t}\n\n\t/**\n\t * Derive Secp256k1 keypair from mnemonics and path. The mnemonics must be normalized\n\t * and validated against the english wordlist.\n\t *\n\t * If path is none, it will default to m/54'/784'/0'/0/0, otherwise the path must\n\t * be compliant to BIP-32 in form m/54'/784'/{account_index}'/{change_index}/{address_index}.\n\t */\n\tstatic deriveKeypair(mnemonics: string, path?: string): Secp256k1Keypair {\n\t\tif (path == null) {\n\t\t\tpath = DEFAULT_SECP256K1_DERIVATION_PATH;\n\t\t}\n\t\tif (!isValidBIP32Path(path)) {\n\t\t\tthrow new Error('Invalid derivation path');\n\t\t}\n\t\tconst key = HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path);\n\t\tif (key.publicKey == null || key.privateKey == null) {\n\t\t\tthrow new Error('Invalid key');\n\t\t}\n\t\treturn new Secp256k1Keypair({\n\t\t\tpublicKey: key.publicKey,\n\t\t\tsecretKey: key.privateKey,\n\t\t});\n\t}\n\n\texport(): ExportedKeypair {\n\t\treturn {\n\t\t\tschema: 'Secp256k1',\n\t\t\tprivateKey: toB64(this.keypair.secretKey),\n\t\t};\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}