{"ast":null,"code":"import { boolean, define, literal, nullable, number, object, record, string, union } from \"superstruct\";\nimport { fromB58, splitGenericParameters } from \"@mysten/bcs\";\nconst TransactionDigest = string();\nconst TransactionEffectsDigest = string();\nconst TransactionEventDigest = string();\nconst ObjectId = string();\nconst SuiAddress = string();\nconst SequenceNumber = string();\nconst ObjectOwner = union([object({\n  AddressOwner: SuiAddress\n}), object({\n  ObjectOwner: SuiAddress\n}), object({\n  Shared: object({\n    initial_shared_version: number()\n  })\n}), literal(\"Immutable\")]);\nconst SuiJsonValue = define(\"SuiJsonValue\", () => true);\nconst ProtocolConfigValue = union([object({\n  u32: string()\n}), object({\n  u64: string()\n}), object({\n  f64: string()\n})]);\nconst ProtocolConfig = object({\n  attributes: record(string(), nullable(ProtocolConfigValue)),\n  featureFlags: record(string(), boolean()),\n  maxSupportedProtocolVersion: string(),\n  minSupportedProtocolVersion: string(),\n  protocolVersion: string()\n});\nconst TX_DIGEST_LENGTH = 32;\nfunction isValidTransactionDigest(value) {\n  try {\n    const buffer = fromB58(value);\n    return buffer.length === TX_DIGEST_LENGTH;\n  } catch (e) {\n    return false;\n  }\n}\nconst SUI_ADDRESS_LENGTH = 32;\nfunction isValidSuiAddress(value) {\n  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\nfunction isValidSuiObjectId(value) {\n  return isValidSuiAddress(value);\n}\nfunction parseTypeTag(type) {\n  if (!type.includes(\"::\")) return type;\n  return parseStructTag(type);\n}\nfunction parseStructTag(type) {\n  const [address, module] = type.split(\"::\");\n  const rest = type.slice(address.length + module.length + 4);\n  const name = rest.includes(\"<\") ? rest.slice(0, rest.indexOf(\"<\")) : rest;\n  const typeParams = rest.includes(\"<\") ? splitGenericParameters(rest.slice(rest.indexOf(\"<\") + 1, rest.lastIndexOf(\">\"))).map(typeParam => parseTypeTag(typeParam.trim())) : [];\n  return {\n    address: normalizeSuiAddress(address),\n    module,\n    name,\n    typeParams\n  };\n}\nfunction normalizeStructTag(type) {\n  const {\n    address,\n    module,\n    name,\n    typeParams\n  } = typeof type === \"string\" ? parseStructTag(type) : type;\n  const formattedTypeParams = typeParams.length > 0 ? `<${typeParams.map(typeParam => typeof typeParam === \"string\" ? typeParam : normalizeStructTag(typeParam)).join(\",\")}>` : \"\";\n  return `${address}::${module}::${name}${formattedTypeParams}`;\n}\nfunction normalizeSuiAddress(value) {\n  let forceAdd0x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let address = value.toLowerCase();\n  if (!forceAdd0x && address.startsWith(\"0x\")) {\n    address = address.slice(2);\n  }\n  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, \"0\")}`;\n}\nfunction normalizeSuiObjectId(value) {\n  let forceAdd0x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return normalizeSuiAddress(value, forceAdd0x);\n}\nfunction isHex(value) {\n  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\nfunction getHexByteLength(value) {\n  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\nexport { ObjectId, ObjectOwner, ProtocolConfig, SUI_ADDRESS_LENGTH, SequenceNumber, SuiAddress, SuiJsonValue, TransactionDigest, TransactionEffectsDigest, TransactionEventDigest, isValidSuiAddress, isValidSuiObjectId, isValidTransactionDigest, normalizeStructTag, normalizeSuiAddress, normalizeSuiObjectId, parseStructTag };","map":{"version":3,"names":["boolean","define","literal","nullable","number","object","record","string","union","fromB58","splitGenericParameters","TransactionDigest","TransactionEffectsDigest","TransactionEventDigest","ObjectId","SuiAddress","SequenceNumber","ObjectOwner","AddressOwner","Shared","initial_shared_version","SuiJsonValue","ProtocolConfigValue","u32","u64","f64","ProtocolConfig","attributes","featureFlags","maxSupportedProtocolVersion","minSupportedProtocolVersion","protocolVersion","TX_DIGEST_LENGTH","isValidTransactionDigest","value","buffer","length","e","SUI_ADDRESS_LENGTH","isValidSuiAddress","isHex","getHexByteLength","isValidSuiObjectId","parseTypeTag","type","includes","parseStructTag","address","module","split","rest","slice","name","indexOf","typeParams","lastIndexOf","map","typeParam","trim","normalizeSuiAddress","normalizeStructTag","formattedTypeParams","join","forceAdd0x","arguments","undefined","toLowerCase","startsWith","padStart","normalizeSuiObjectId","test"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/common.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { Infer } from 'superstruct';\nimport {\n\tboolean,\n\tdefine,\n\tliteral,\n\tnullable,\n\tnumber,\n\tobject,\n\trecord,\n\tstring,\n\tunion,\n} from 'superstruct';\nimport type { CallArg } from './sui-bcs.js';\nimport { fromB58, splitGenericParameters } from '@mysten/bcs';\n\nexport const TransactionDigest = string();\nexport type TransactionDigest = Infer<typeof TransactionDigest>;\n\nexport const TransactionEffectsDigest = string();\nexport type TransactionEffectsDigest = Infer<typeof TransactionEffectsDigest>;\n\nexport const TransactionEventDigest = string();\nexport type TransactionEventDigest = Infer<typeof TransactionEventDigest>;\n\nexport const ObjectId = string();\nexport type ObjectId = Infer<typeof ObjectId>;\n\nexport const SuiAddress = string();\nexport type SuiAddress = Infer<typeof SuiAddress>;\n\nexport const SequenceNumber = string();\nexport type SequenceNumber = Infer<typeof SequenceNumber>;\n\nexport const ObjectOwner = union([\n\tobject({\n\t\tAddressOwner: SuiAddress,\n\t}),\n\tobject({\n\t\tObjectOwner: SuiAddress,\n\t}),\n\tobject({\n\t\tShared: object({\n\t\t\tinitial_shared_version: number(),\n\t\t}),\n\t}),\n\tliteral('Immutable'),\n]);\nexport type ObjectOwner = Infer<typeof ObjectOwner>;\n\nexport type SuiJsonValue = boolean | number | string | CallArg | Array<SuiJsonValue>;\nexport const SuiJsonValue = define<SuiJsonValue>('SuiJsonValue', () => true);\n\nconst ProtocolConfigValue = union([\n\tobject({ u32: string() }),\n\tobject({ u64: string() }),\n\tobject({ f64: string() }),\n]);\ntype ProtocolConfigValue = Infer<typeof ProtocolConfigValue>;\n\nexport const ProtocolConfig = object({\n\tattributes: record(string(), nullable(ProtocolConfigValue)),\n\tfeatureFlags: record(string(), boolean()),\n\tmaxSupportedProtocolVersion: string(),\n\tminSupportedProtocolVersion: string(),\n\tprotocolVersion: string(),\n});\nexport type ProtocolConfig = Infer<typeof ProtocolConfig>;\n\n// source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L171\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(value: string): value is TransactionDigest {\n\ttry {\n\t\tconst buffer = fromB58(value);\n\t\treturn buffer.length === TX_DIGEST_LENGTH;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is SuiAddress {\n\treturn isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n\treturn isValidSuiAddress(value);\n}\n\ntype StructTag = {\n\taddress: string;\n\tmodule: string;\n\tname: string;\n\ttypeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n\tif (!type.includes('::')) return type;\n\n\treturn parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n\tconst [address, module] = type.split('::');\n\n\tconst rest = type.slice(address.length + module.length + 4);\n\tconst name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n\tconst typeParams = rest.includes('<')\n\t\t? splitGenericParameters(rest.slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))).map(\n\t\t\t\t(typeParam) => parseTypeTag(typeParam.trim()),\n\t\t  )\n\t\t: [];\n\n\treturn {\n\t\taddress: normalizeSuiAddress(address),\n\t\tmodule,\n\t\tname,\n\t\ttypeParams,\n\t};\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n\tconst { address, module, name, typeParams } =\n\t\ttypeof type === 'string' ? parseStructTag(type) : type;\n\n\tconst formattedTypeParams =\n\t\ttypeParams.length > 0\n\t\t\t? `<${typeParams\n\t\t\t\t\t.map((typeParam) =>\n\t\t\t\t\t\ttypeof typeParam === 'string' ? typeParam : normalizeStructTag(typeParam),\n\t\t\t\t\t)\n\t\t\t\t\t.join(',')}>`\n\t\t\t: '';\n\n\treturn `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(value: string, forceAdd0x: boolean = false): SuiAddress {\n\tlet address = value.toLowerCase();\n\tif (!forceAdd0x && address.startsWith('0x')) {\n\t\taddress = address.slice(2);\n\t}\n\treturn `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(value: string, forceAdd0x: boolean = false): ObjectId {\n\treturn normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n\treturn /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n\treturn /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}