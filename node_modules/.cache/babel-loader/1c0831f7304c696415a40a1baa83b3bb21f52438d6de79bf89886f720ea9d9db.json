{"ast":null,"code":"var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateWrapper = (obj, member, setter, getter) => ({\n  set _(value) {\n    __privateSet(obj, member, value, setter);\n  },\n  get _() {\n    return __privateGet(obj, member, getter);\n  }\n});\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\nvar _client, _subscriptions, _disconnects, _setupClient, setupClient_fn, _reconnect, reconnect_fn;\nimport { RequestManager, Client, WebSocketTransport } from \"@open-rpc/client-js\";\nconst getWebsocketUrl = (httpUrl, port) => {\n  const url = new URL(httpUrl);\n  url.protocol = url.protocol.replace(\"http\", \"ws\");\n  if (port) {\n    url.port = port.toString();\n  }\n  return url.toString();\n};\nconst DEFAULT_CLIENT_OPTIONS = {\n  callTimeout: 3e4,\n  reconnectTimeout: 3e3,\n  maxReconnects: 5\n};\nclass WebsocketClient {\n  constructor(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CLIENT_OPTIONS;\n    this.endpoint = endpoint;\n    this.options = options;\n    __privateAdd(this, _setupClient);\n    __privateAdd(this, _reconnect);\n    __privateAdd(this, _client, void 0);\n    __privateAdd(this, _subscriptions, void 0);\n    __privateAdd(this, _disconnects, void 0);\n    if (this.endpoint.startsWith(\"http\")) {\n      this.endpoint = getWebsocketUrl(this.endpoint);\n    }\n    __privateSet(this, _client, null);\n    __privateSet(this, _subscriptions, /* @__PURE__ */new Map());\n    __privateSet(this, _disconnects, 0);\n  }\n  async request(input) {\n    const client = __privateMethod(this, _setupClient, setupClient_fn).call(this);\n    const id = await client.request({\n      method: input.method,\n      params: input.params\n    }, this.options.callTimeout);\n    __privateGet(this, _subscriptions).set(input.id || id, {\n      ...input,\n      // Always set the latest actual subscription ID:\n      id\n    });\n    return async () => {\n      const client2 = __privateMethod(this, _setupClient, setupClient_fn).call(this);\n      const subscription = __privateGet(this, _subscriptions).get(id);\n      if (!subscription) return false;\n      __privateGet(this, _subscriptions).delete(id);\n      return client2.request({\n        method: input.unsubscribe,\n        params: [subscription.id]\n      }, this.options.callTimeout);\n    };\n  }\n}\n_client = new WeakMap();\n_subscriptions = new WeakMap();\n_disconnects = new WeakMap();\n_setupClient = new WeakSet();\nsetupClient_fn = function () {\n  if (__privateGet(this, _client)) {\n    return __privateGet(this, _client);\n  }\n  const transport = new WebSocketTransport(this.endpoint);\n  const requestManager = new RequestManager([transport]);\n  __privateSet(this, _client, new Client(requestManager));\n  transport.connection.addEventListener(\"open\", () => {\n    __privateSet(this, _disconnects, 0);\n  });\n  transport.connection.addEventListener(\"close\", () => {\n    __privateWrapper(this, _disconnects)._++;\n    if (__privateGet(this, _disconnects) <= this.options.maxReconnects) {\n      setTimeout(() => {\n        __privateMethod(this, _reconnect, reconnect_fn).call(this);\n      }, this.options.reconnectTimeout);\n    }\n  });\n  __privateGet(this, _client).onNotification(data => {\n    const params = data.params;\n    __privateGet(this, _subscriptions).forEach(subscription => {\n      if (subscription.method === data.method && params.subscription === subscription.id) {\n        subscription.onMessage(params.result);\n      }\n    });\n  });\n  return __privateGet(this, _client);\n};\n_reconnect = new WeakSet();\nreconnect_fn = function () {\n  __privateGet(this, _client)?.close();\n  __privateSet(this, _client, null);\n  __privateGet(this, _subscriptions).forEach(subscription => this.request(subscription));\n};\nexport { DEFAULT_CLIENT_OPTIONS, WebsocketClient, getWebsocketUrl };","map":{"version":3,"names":["_client","_subscriptions","_disconnects","_setupClient","setupClient_fn","_reconnect","reconnect_fn","RequestManager","Client","WebSocketTransport","getWebsocketUrl","httpUrl","port","url","URL","protocol","replace","toString","DEFAULT_CLIENT_OPTIONS","callTimeout","reconnectTimeout","maxReconnects","WebsocketClient","constructor","endpoint","options","arguments","length","undefined","__privateAdd","startsWith","__privateSet","Map","request","input","client","__privateMethod","call","id","method","params","__privateGet","set","client2","subscription","get","delete","unsubscribe","WeakMap","WeakSet","transport","requestManager","connection","addEventListener","__privateWrapper","_","setTimeout","onNotification","data","forEach","onMessage","result","close"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/rpc/websocket-client.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { SubscriptionId } from '../types/index.js';\nimport { RequestManager, Client, WebSocketTransport } from '@open-rpc/client-js';\n\nexport const getWebsocketUrl = (httpUrl: string, port?: number): string => {\n\tconst url = new URL(httpUrl);\n\turl.protocol = url.protocol.replace('http', 'ws');\n\tif (port) {\n\t\turl.port = port.toString();\n\t}\n\treturn url.toString();\n};\n\ntype NotificationMessageParams = {\n\tsubscription: SubscriptionId;\n\tresult: object;\n};\n\ntype SubscriptionRequest<T = any> = {\n\tid?: number;\n\tmethod: string;\n\tunsubscribe: string;\n\tparams: any[];\n\tonMessage: (event: T) => void;\n};\n\n/**\n * Configuration options for the websocket connection\n */\nexport type WebsocketClientOptions = {\n\t/**\n\t * Milliseconds before timing out while calling an RPC method\n\t */\n\tcallTimeout: number;\n\t/**\n\t * Milliseconds between attempts to connect\n\t */\n\treconnectTimeout: number;\n\t/**\n\t * Maximum number of times to try connecting before giving up\n\t */\n\tmaxReconnects: number;\n};\n\nexport const DEFAULT_CLIENT_OPTIONS: WebsocketClientOptions = {\n\tcallTimeout: 30000,\n\treconnectTimeout: 3000,\n\tmaxReconnects: 5,\n};\n\nexport class WebsocketClient {\n\t#client: Client | null;\n\t#subscriptions: Map<SubscriptionId, SubscriptionRequest & { id: number }>;\n\t#disconnects: number;\n\n\tconstructor(\n\t\tpublic endpoint: string,\n\t\tpublic options: WebsocketClientOptions = DEFAULT_CLIENT_OPTIONS,\n\t) {\n\t\tif (this.endpoint.startsWith('http')) {\n\t\t\tthis.endpoint = getWebsocketUrl(this.endpoint);\n\t\t}\n\n\t\tthis.#client = null;\n\t\tthis.#subscriptions = new Map();\n\t\tthis.#disconnects = 0;\n\t}\n\n\t#setupClient() {\n\t\tif (this.#client) {\n\t\t\treturn this.#client;\n\t\t}\n\n\t\tconst transport = new WebSocketTransport(this.endpoint);\n\t\tconst requestManager = new RequestManager([transport]);\n\t\tthis.#client = new Client(requestManager);\n\n\t\ttransport.connection.addEventListener('open', () => {\n\t\t\tthis.#disconnects = 0;\n\t\t});\n\n\t\ttransport.connection.addEventListener('close', () => {\n\t\t\tthis.#disconnects++;\n\t\t\tif (this.#disconnects <= this.options.maxReconnects) {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tthis.#reconnect();\n\t\t\t\t}, this.options.reconnectTimeout);\n\t\t\t}\n\t\t});\n\n\t\tthis.#client.onNotification((data) => {\n\t\t\tconst params = data.params as NotificationMessageParams;\n\n\t\t\tthis.#subscriptions.forEach((subscription) => {\n\t\t\t\tif (subscription.method === data.method && params.subscription === subscription.id) {\n\t\t\t\t\tsubscription.onMessage(params.result);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn this.#client;\n\t}\n\n\t#reconnect() {\n\t\tthis.#client?.close();\n\t\tthis.#client = null;\n\n\t\tthis.#subscriptions.forEach((subscription) => this.request(subscription));\n\t}\n\n\tasync request<T>(input: SubscriptionRequest<T>) {\n\t\tconst client = this.#setupClient();\n\t\tconst id = await client.request(\n\t\t\t{ method: input.method, params: input.params },\n\t\t\tthis.options.callTimeout,\n\t\t);\n\n\t\t// If an input ID is provided, this is a reconnect and we need to use that ID instead:\n\t\tthis.#subscriptions.set(input.id || id, {\n\t\t\t...input,\n\t\t\t// Always set the latest actual subscription ID:\n\t\t\tid,\n\t\t});\n\n\t\treturn async () => {\n\t\t\tconst client = this.#setupClient();\n\t\t\t// NOTE: Due to reconnects, the inner subscription ID could have actually changed:\n\t\t\tconst subscription = this.#subscriptions.get(id);\n\t\t\tif (!subscription) return false;\n\n\t\t\tthis.#subscriptions.delete(id);\n\n\t\t\treturn client.request(\n\t\t\t\t{ method: input.unsubscribe, params: [subscription.id] },\n\t\t\t\tthis.options.callTimeout,\n\t\t\t);\n\t\t};\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}