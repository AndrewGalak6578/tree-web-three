{"ast":null,"code":"var __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar __privateWrapper = (obj, member, setter, getter) => ({\n  set _(value) {\n    __privateSet(obj, member, value, setter);\n  },\n  get _() {\n    return __privateGet(obj, member, getter);\n  }\n});\nvar __privateMethod = (obj, member, method) => {\n  __accessCheck(obj, member, \"access private method\");\n  return method;\n};\n\n// src/cryptography/ed25519-keypair.ts\nimport nacl2 from \"tweetnacl\";\n\n// src/cryptography/keypair.ts\nimport { fromB64 as fromB645 } from \"@mysten/bcs\";\n\n// src/cryptography/secp256k1-keypair.ts\nimport { sha256 } from \"@noble/hashes/sha256\";\n\n// src/cryptography/secp256k1-publickey.ts\nimport { fromB64 as fromB644, toB64 as toB644 } from \"@mysten/bcs\";\nimport { blake2b as blake2b3 } from \"@noble/hashes/blake2b\";\nimport { bytesToHex as bytesToHex3 } from \"@noble/hashes/utils\";\n\n// src/types/common.ts\nimport { boolean, define, literal, nullable, number, object, record, string, union } from \"superstruct\";\nimport { fromB58 } from \"@mysten/bcs\";\nvar TransactionDigest = string();\nvar TransactionEffectsDigest = string();\nvar TransactionEventDigest = string();\nvar ObjectId = string();\nvar SuiAddress = string();\nvar SequenceNumber = string();\nvar ObjectOwner = union([object({\n  AddressOwner: SuiAddress\n}), object({\n  ObjectOwner: SuiAddress\n}), object({\n  Shared: object({\n    initial_shared_version: number()\n  })\n}), literal(\"Immutable\")]);\nvar SuiJsonValue = define(\"SuiJsonValue\", () => true);\nvar ProtocolConfigValue = union([object({\n  u32: string()\n}), object({\n  u64: string()\n}), object({\n  f64: string()\n})]);\nvar ProtocolConfig = object({\n  attributes: record(string(), nullable(ProtocolConfigValue)),\n  featureFlags: record(string(), boolean()),\n  maxSupportedProtocolVersion: string(),\n  minSupportedProtocolVersion: string(),\n  protocolVersion: string()\n});\nvar TX_DIGEST_LENGTH = 32;\nfunction isValidTransactionDigest(value) {\n  try {\n    const buffer = fromB58(value);\n    return buffer.length === TX_DIGEST_LENGTH;\n  } catch (e) {\n    return false;\n  }\n}\nvar SUI_ADDRESS_LENGTH = 32;\nfunction isValidSuiAddress(value) {\n  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\nfunction isValidSuiObjectId(value) {\n  return isValidSuiAddress(value);\n}\nfunction parseTypeTag(type) {\n  if (!type.includes(\"::\")) return type;\n  return parseStructTag(type);\n}\nfunction parseStructTag(type) {\n  const [address, module] = type.split(\"::\");\n  const rest = type.slice(address.length + module.length + 4);\n  const name = rest.includes(\"<\") ? rest.slice(0, rest.indexOf(\"<\")) : rest;\n  const typeParams = rest.includes(\"<\") ? rest.slice(rest.indexOf(\"<\") + 1, rest.lastIndexOf(\">\")).split(\",\").map(typeParam => parseTypeTag(typeParam.trim())) : [];\n  return {\n    address: normalizeSuiAddress(address),\n    module,\n    name,\n    typeParams\n  };\n}\nfunction normalizeStructTag(type) {\n  const {\n    address,\n    module,\n    name,\n    typeParams\n  } = typeof type === \"string\" ? parseStructTag(type) : type;\n  const formattedTypeParams = typeParams.length > 0 ? `<${typeParams.map(typeParam => typeof typeParam === \"string\" ? typeParam : normalizeStructTag(typeParam)).join(\",\")}>` : \"\";\n  return `${address}::${module}::${name}${formattedTypeParams}`;\n}\nfunction normalizeSuiAddress(value) {\n  let forceAdd0x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let address = value.toLowerCase();\n  if (!forceAdd0x && address.startsWith(\"0x\")) {\n    address = address.slice(2);\n  }\n  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, \"0\")}`;\n}\nfunction normalizeSuiObjectId(value) {\n  let forceAdd0x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return normalizeSuiAddress(value, forceAdd0x);\n}\nfunction isHex(value) {\n  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\nfunction getHexByteLength(value) {\n  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n\n// src/types/objects.ts\nimport { any, array, assign, boolean as boolean2, literal as literal2, number as number2, object as object2, optional, record as record2, string as string2, union as union2, is, nullable as nullable2, tuple } from \"superstruct\";\nvar ObjectType = union2([string2(), literal2(\"package\")]);\nvar SuiObjectRef = object2({\n  /** Base64 string representing the object digest */\n  digest: TransactionDigest,\n  /** Hex code as string representing the object id */\n  objectId: string2(),\n  /** Object version */\n  version: union2([number2(), string2()])\n});\nvar SuiGasData = object2({\n  payment: array(SuiObjectRef),\n  /** Gas Object's owner */\n  owner: string2(),\n  price: string2(),\n  budget: string2()\n});\nvar SuiObjectInfo = assign(SuiObjectRef, object2({\n  type: string2(),\n  owner: ObjectOwner,\n  previousTransaction: TransactionDigest\n}));\nvar ObjectContentFields = record2(string2(), any());\nvar MovePackageContent = record2(string2(), string2());\nvar SuiMoveObject = object2({\n  /** Move type (e.g., \"0x2::coin::Coin<0x2::sui::SUI>\") */\n  type: string2(),\n  /** Fields and values stored inside the Move object */\n  fields: ObjectContentFields,\n  hasPublicTransfer: boolean2()\n});\nvar SuiMovePackage = object2({\n  /** A mapping from module name to disassembled Move bytecode */\n  disassembled: MovePackageContent\n});\nvar SuiParsedData = union2([assign(SuiMoveObject, object2({\n  dataType: literal2(\"moveObject\")\n})), assign(SuiMovePackage, object2({\n  dataType: literal2(\"package\")\n}))]);\nvar SuiRawMoveObject = object2({\n  /** Move type (e.g., \"0x2::coin::Coin<0x2::sui::SUI>\") */\n  type: string2(),\n  hasPublicTransfer: boolean2(),\n  version: number2(),\n  bcsBytes: string2()\n});\nvar SuiRawMovePackage = object2({\n  id: ObjectId,\n  /** A mapping from module name to Move bytecode enocded in base64*/\n  moduleMap: record2(string2(), string2())\n});\nvar SuiRawData = union2([assign(SuiRawMoveObject, object2({\n  dataType: literal2(\"moveObject\")\n})), assign(SuiRawMovePackage, object2({\n  dataType: literal2(\"package\")\n}))]);\nvar SUI_DECIMALS = 9;\nvar MIST_PER_SUI = BigInt(1e9);\nvar ObjectDigest = string2();\nvar SuiObjectResponseError = object2({\n  code: string2(),\n  error: optional(string2()),\n  object_id: optional(ObjectId),\n  parent_object_id: optional(ObjectId),\n  version: optional(number2()),\n  digest: optional(ObjectDigest)\n});\nvar DisplayFieldsResponse = object2({\n  data: nullable2(record2(string2(), string2())),\n  error: nullable2(SuiObjectResponseError)\n});\nvar DisplayFieldsBackwardCompatibleResponse = union2([DisplayFieldsResponse, optional(record2(string2(), string2()))]);\nvar SuiObjectData = object2({\n  objectId: ObjectId,\n  version: SequenceNumber,\n  digest: ObjectDigest,\n  /**\n   * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true\n   */\n  type: optional(string2()),\n  /**\n   * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true\n   */\n  content: optional(SuiParsedData),\n  /**\n   * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true\n   */\n  bcs: optional(SuiRawData),\n  /**\n   * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true\n   */\n  owner: optional(ObjectOwner),\n  /**\n   * The digest of the transaction that created or last mutated this object.\n   * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true\n   */\n  previousTransaction: optional(TransactionDigest),\n  /**\n   * The amount of SUI we would rebate if this object gets deleted.\n   * This number is re-calculated each time the object is mutated based on\n   * the present storage gas price.\n   * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true\n   */\n  storageRebate: optional(string2()),\n  /**\n   * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true\n   * This can also be None if the struct type does not have Display defined\n   * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872\n   */\n  display: optional(DisplayFieldsBackwardCompatibleResponse)\n});\nvar SuiObjectDataOptions = object2({\n  /* Whether to fetch the object type, default to be true */\n  showType: optional(boolean2()),\n  /* Whether to fetch the object content, default to be false */\n  showContent: optional(boolean2()),\n  /* Whether to fetch the object content in BCS bytes, default to be false */\n  showBcs: optional(boolean2()),\n  /* Whether to fetch the object owner, default to be false */\n  showOwner: optional(boolean2()),\n  /* Whether to fetch the previous transaction digest, default to be false */\n  showPreviousTransaction: optional(boolean2()),\n  /* Whether to fetch the storage rebate, default to be false */\n  showStorageRebate: optional(boolean2()),\n  /* Whether to fetch the display metadata, default to be false */\n  showDisplay: optional(boolean2())\n});\nvar ObjectStatus = union2([literal2(\"Exists\"), literal2(\"notExists\"), literal2(\"Deleted\")]);\nvar GetOwnedObjectsResponse = array(SuiObjectInfo);\nvar SuiObjectResponse = object2({\n  data: optional(SuiObjectData),\n  error: optional(SuiObjectResponseError)\n});\nfunction getSuiObjectData(resp) {\n  return resp.data;\n}\nfunction getObjectDeletedResponse(resp) {\n  if (resp.error && \"object_id\" in resp.error && \"version\" in resp.error && \"digest\" in resp.error) {\n    const error = resp.error;\n    return {\n      objectId: error.object_id,\n      version: error.version,\n      digest: error.digest\n    };\n  }\n  return void 0;\n}\nfunction getObjectNotExistsResponse(resp) {\n  if (resp.error && \"object_id\" in resp.error && !(\"version\" in resp.error) && !(\"digest\" in resp.error)) {\n    return resp.error.object_id;\n  }\n  return void 0;\n}\nfunction getObjectReference(resp) {\n  if (\"reference\" in resp) {\n    return resp.reference;\n  }\n  const exists = getSuiObjectData(resp);\n  if (exists) {\n    return {\n      objectId: exists.objectId,\n      version: exists.version,\n      digest: exists.digest\n    };\n  }\n  return getObjectDeletedResponse(resp);\n}\nfunction getObjectId(data) {\n  if (\"objectId\" in data) {\n    return data.objectId;\n  }\n  return getObjectReference(data)?.objectId ?? getObjectNotExistsResponse(data);\n}\nfunction getObjectVersion(data) {\n  if (\"version\" in data) {\n    return data.version;\n  }\n  return getObjectReference(data)?.version;\n}\nfunction isSuiObjectResponse(resp) {\n  return resp.data !== void 0;\n}\nfunction getObjectType(resp) {\n  const data = isSuiObjectResponse(resp) ? resp.data : resp;\n  if (!data?.type && \"data\" in resp) {\n    if (data?.content?.dataType === \"package\") {\n      return \"package\";\n    }\n    return getMoveObjectType(resp);\n  }\n  return data?.type;\n}\nfunction getObjectPreviousTransactionDigest(resp) {\n  return getSuiObjectData(resp)?.previousTransaction;\n}\nfunction getObjectOwner(resp) {\n  if (is(resp, ObjectOwner)) {\n    return resp;\n  }\n  return getSuiObjectData(resp)?.owner;\n}\nfunction getObjectDisplay(resp) {\n  const display = getSuiObjectData(resp)?.display;\n  if (!display) {\n    return {\n      data: null,\n      error: null\n    };\n  }\n  if (is(display, DisplayFieldsResponse)) {\n    return display;\n  }\n  return {\n    data: display,\n    error: null\n  };\n}\nfunction getSharedObjectInitialVersion(resp) {\n  const owner = getObjectOwner(resp);\n  if (typeof owner === \"object\" && \"Shared\" in owner) {\n    return owner.Shared.initial_shared_version;\n  } else {\n    return void 0;\n  }\n}\nfunction isSharedObject(resp) {\n  const owner = getObjectOwner(resp);\n  return typeof owner === \"object\" && \"Shared\" in owner;\n}\nfunction isImmutableObject(resp) {\n  const owner = getObjectOwner(resp);\n  return owner === \"Immutable\";\n}\nfunction getMoveObjectType(resp) {\n  return getMoveObject(resp)?.type;\n}\nfunction getObjectFields(resp) {\n  if (\"fields\" in resp) {\n    return resp.fields;\n  }\n  return getMoveObject(resp)?.fields;\n}\nfunction isSuiObjectDataWithContent(data) {\n  return data.content !== void 0;\n}\nfunction getMoveObject(data) {\n  const suiObject = \"data\" in data ? getSuiObjectData(data) : data;\n  if (!suiObject || !isSuiObjectDataWithContent(suiObject) || suiObject.content.dataType !== \"moveObject\") {\n    return void 0;\n  }\n  return suiObject.content;\n}\nfunction hasPublicTransfer(data) {\n  return getMoveObject(data)?.hasPublicTransfer ?? false;\n}\nfunction getMovePackageContent(data) {\n  if (\"disassembled\" in data) {\n    return data.disassembled;\n  }\n  const suiObject = getSuiObjectData(data);\n  if (suiObject?.content?.dataType !== \"package\") {\n    return void 0;\n  }\n  return suiObject.content.disassembled;\n}\nvar CheckpointedObjectId = object2({\n  objectId: ObjectId,\n  atCheckpoint: optional(number2())\n});\nvar PaginatedObjectsResponse = object2({\n  data: array(SuiObjectResponse),\n  // TODO: remove union after 0.30.0 is released\n  nextCursor: union2([nullable2(ObjectId), nullable2(CheckpointedObjectId)]),\n  hasNextPage: boolean2()\n});\nvar ObjectRead = union2([object2({\n  details: SuiObjectData,\n  status: literal2(\"VersionFound\")\n}), object2({\n  details: ObjectId,\n  status: literal2(\"ObjectNotExists\")\n}), object2({\n  details: SuiObjectRef,\n  status: literal2(\"ObjectDeleted\")\n}), object2({\n  details: tuple([ObjectId, number2()]),\n  status: literal2(\"VersionNotFound\")\n}), object2({\n  details: object2({\n    asked_version: number2(),\n    latest_version: number2(),\n    object_id: ObjectId\n  }),\n  status: literal2(\"VersionTooHigh\")\n})]);\n\n// src/types/events.ts\nimport { object as object3, string as string3, array as array2, record as record3, any as any2, optional as optional2, boolean as boolean3, nullable as nullable3 } from \"superstruct\";\nvar EventId = object3({\n  txDigest: TransactionDigest,\n  eventSeq: SequenceNumber\n});\nvar SuiEvent = object3({\n  id: EventId,\n  // Move package where this event was emitted.\n  packageId: ObjectId,\n  // Move module where this event was emitted.\n  transactionModule: string3(),\n  // Sender's Sui address.\n  sender: SuiAddress,\n  // Move event type.\n  type: string3(),\n  // Parsed json value of the event\n  parsedJson: optional2(record3(string3(), any2())),\n  // Base 58 encoded bcs bytes of the move event\n  bcs: optional2(string3()),\n  timestampMs: optional2(string3())\n});\nvar PaginatedEvents = object3({\n  data: array2(SuiEvent),\n  nextCursor: nullable3(EventId),\n  hasNextPage: boolean3()\n});\nfunction getEventSender(event) {\n  return event.sender;\n}\nfunction getEventPackage(event) {\n  return event.packageId;\n}\n\n// src/types/transactions.ts\nimport { is as is2, array as array3, literal as literal3, number as number3, object as object4, optional as optional3, string as string4, union as union3, boolean as boolean4, tuple as tuple2, assign as assign2, nullable as nullable4 } from \"superstruct\";\nvar EpochId = string4();\nvar SuiChangeEpoch = object4({\n  epoch: EpochId,\n  storage_charge: string4(),\n  computation_charge: string4(),\n  storage_rebate: string4(),\n  epoch_start_timestamp_ms: optional3(string4())\n});\nvar SuiConsensusCommitPrologue = object4({\n  epoch: EpochId,\n  round: string4(),\n  commit_timestamp_ms: string4()\n});\nvar Genesis = object4({\n  objects: array3(ObjectId)\n});\nvar SuiArgument = union3([literal3(\"GasCoin\"), object4({\n  Input: number3()\n}), object4({\n  Result: number3()\n}), object4({\n  NestedResult: tuple2([number3(), number3()])\n})]);\nvar MoveCallSuiTransaction = object4({\n  arguments: optional3(array3(SuiArgument)),\n  type_arguments: optional3(array3(string4())),\n  package: ObjectId,\n  module: string4(),\n  function: string4()\n});\nvar SuiTransaction = union3([object4({\n  MoveCall: MoveCallSuiTransaction\n}), object4({\n  TransferObjects: tuple2([array3(SuiArgument), SuiArgument])\n}), object4({\n  SplitCoins: tuple2([SuiArgument, array3(SuiArgument)])\n}), object4({\n  MergeCoins: tuple2([SuiArgument, array3(SuiArgument)])\n}), object4({\n  Publish: union3([\n  // TODO: Remove this after 0.34 is released:\n  tuple2([SuiMovePackage, array3(ObjectId)]), array3(ObjectId)])\n}), object4({\n  Upgrade: union3([\n  // TODO: Remove this after 0.34 is released:\n  tuple2([SuiMovePackage, array3(ObjectId), ObjectId, SuiArgument]), tuple2([array3(ObjectId), ObjectId, SuiArgument])])\n}), object4({\n  MakeMoveVec: tuple2([nullable4(string4()), array3(SuiArgument)])\n})]);\nvar SuiCallArg = union3([object4({\n  type: literal3(\"pure\"),\n  valueType: nullable4(string4()),\n  value: SuiJsonValue\n}), object4({\n  type: literal3(\"object\"),\n  objectType: literal3(\"immOrOwnedObject\"),\n  objectId: ObjectId,\n  version: SequenceNumber,\n  digest: ObjectDigest\n}), object4({\n  type: literal3(\"object\"),\n  objectType: literal3(\"sharedObject\"),\n  objectId: ObjectId,\n  initialSharedVersion: SequenceNumber,\n  mutable: boolean4()\n})]);\nvar ProgrammableTransaction = object4({\n  transactions: array3(SuiTransaction),\n  inputs: array3(SuiCallArg)\n});\nvar SuiTransactionBlockKind = union3([assign2(SuiChangeEpoch, object4({\n  kind: literal3(\"ChangeEpoch\")\n})), assign2(SuiConsensusCommitPrologue, object4({\n  kind: literal3(\"ConsensusCommitPrologue\")\n})), assign2(Genesis, object4({\n  kind: literal3(\"Genesis\")\n})), assign2(ProgrammableTransaction, object4({\n  kind: literal3(\"ProgrammableTransaction\")\n}))]);\nvar SuiTransactionBlockData = object4({\n  // Eventually this will become union(literal('v1'), literal('v2'), ...)\n  messageVersion: literal3(\"v1\"),\n  transaction: SuiTransactionBlockKind,\n  sender: SuiAddress,\n  gasData: SuiGasData\n});\nvar AuthoritySignature = string4();\nvar GenericAuthoritySignature = union3([AuthoritySignature, array3(AuthoritySignature)]);\nvar AuthorityQuorumSignInfo = object4({\n  epoch: EpochId,\n  signature: GenericAuthoritySignature,\n  signers_map: array3(number3())\n});\nvar GasCostSummary = object4({\n  computationCost: string4(),\n  storageCost: string4(),\n  storageRebate: string4(),\n  nonRefundableStorageFee: string4()\n});\nvar ExecutionStatusType = union3([literal3(\"success\"), literal3(\"failure\")]);\nvar ExecutionStatus = object4({\n  status: ExecutionStatusType,\n  error: optional3(string4())\n});\nvar OwnedObjectRef = object4({\n  owner: ObjectOwner,\n  reference: SuiObjectRef\n});\nvar TransactionEffectsModifiedAtVersions = object4({\n  objectId: ObjectId,\n  sequenceNumber: SequenceNumber\n});\nvar TransactionEffects = object4({\n  // Eventually this will become union(literal('v1'), literal('v2'), ...)\n  messageVersion: literal3(\"v1\"),\n  /** The status of the execution */\n  status: ExecutionStatus,\n  /** The epoch when this transaction was executed */\n  executedEpoch: EpochId,\n  /** The version that every modified (mutated or deleted) object had before it was modified by this transaction. **/\n  modifiedAtVersions: optional3(array3(TransactionEffectsModifiedAtVersions)),\n  gasUsed: GasCostSummary,\n  /** The object references of the shared objects used in this transaction. Empty if no shared objects were used. */\n  sharedObjects: optional3(array3(SuiObjectRef)),\n  /** The transaction digest */\n  transactionDigest: TransactionDigest,\n  /** ObjectRef and owner of new objects created */\n  created: optional3(array3(OwnedObjectRef)),\n  /** ObjectRef and owner of mutated objects, including gas object */\n  mutated: optional3(array3(OwnedObjectRef)),\n  /**\n   * ObjectRef and owner of objects that are unwrapped in this transaction.\n   * Unwrapped objects are objects that were wrapped into other objects in the past,\n   * and just got extracted out.\n   */\n  unwrapped: optional3(array3(OwnedObjectRef)),\n  /** Object Refs of objects now deleted (the old refs) */\n  deleted: optional3(array3(SuiObjectRef)),\n  /** Object Refs of objects now deleted (the old refs) */\n  unwrappedThenDeleted: optional3(array3(SuiObjectRef)),\n  /** Object refs of objects now wrapped in other objects */\n  wrapped: optional3(array3(SuiObjectRef)),\n  /**\n   * The updated gas object reference. Have a dedicated field for convenient access.\n   * It's also included in mutated.\n   */\n  gasObject: OwnedObjectRef,\n  /** The events emitted during execution. Note that only successful transactions emit events */\n  eventsDigest: optional3(TransactionEventDigest),\n  /** The set of transaction digests this transaction depends on */\n  dependencies: optional3(array3(TransactionDigest))\n});\nvar TransactionEvents = array3(SuiEvent);\nvar ReturnValueType = tuple2([array3(number3()), string4()]);\nvar MutableReferenceOutputType = tuple2([SuiArgument, array3(number3()), string4()]);\nvar ExecutionResultType = object4({\n  mutableReferenceOutputs: optional3(array3(MutableReferenceOutputType)),\n  returnValues: optional3(array3(ReturnValueType))\n});\nvar DevInspectResults = object4({\n  effects: TransactionEffects,\n  events: TransactionEvents,\n  results: optional3(array3(ExecutionResultType)),\n  error: optional3(string4())\n});\nvar AuthorityName = string4();\nvar SuiTransactionBlock = object4({\n  data: SuiTransactionBlockData,\n  txSignatures: array3(string4())\n});\nvar SuiObjectChangePublished = object4({\n  type: literal3(\"published\"),\n  packageId: ObjectId,\n  version: SequenceNumber,\n  digest: ObjectDigest,\n  modules: array3(string4())\n});\nvar SuiObjectChangeTransferred = object4({\n  type: literal3(\"transferred\"),\n  sender: SuiAddress,\n  recipient: ObjectOwner,\n  objectType: string4(),\n  objectId: ObjectId,\n  version: SequenceNumber,\n  digest: ObjectDigest\n});\nvar SuiObjectChangeMutated = object4({\n  type: literal3(\"mutated\"),\n  sender: SuiAddress,\n  owner: ObjectOwner,\n  objectType: string4(),\n  objectId: ObjectId,\n  version: SequenceNumber,\n  previousVersion: SequenceNumber,\n  digest: ObjectDigest\n});\nvar SuiObjectChangeDeleted = object4({\n  type: literal3(\"deleted\"),\n  sender: SuiAddress,\n  objectType: string4(),\n  objectId: ObjectId,\n  version: SequenceNumber\n});\nvar SuiObjectChangeWrapped = object4({\n  type: literal3(\"wrapped\"),\n  sender: SuiAddress,\n  objectType: string4(),\n  objectId: ObjectId,\n  version: SequenceNumber\n});\nvar SuiObjectChangeCreated = object4({\n  type: literal3(\"created\"),\n  sender: SuiAddress,\n  owner: ObjectOwner,\n  objectType: string4(),\n  objectId: ObjectId,\n  version: SequenceNumber,\n  digest: ObjectDigest\n});\nvar SuiObjectChange = union3([SuiObjectChangePublished, SuiObjectChangeTransferred, SuiObjectChangeMutated, SuiObjectChangeDeleted, SuiObjectChangeWrapped, SuiObjectChangeCreated]);\nvar BalanceChange = object4({\n  owner: ObjectOwner,\n  coinType: string4(),\n  /* Coin balance change(positive means receive, negative means send) */\n  amount: string4()\n});\nvar SuiTransactionBlockResponse = object4({\n  digest: TransactionDigest,\n  transaction: optional3(SuiTransactionBlock),\n  effects: optional3(TransactionEffects),\n  events: optional3(TransactionEvents),\n  timestampMs: optional3(string4()),\n  checkpoint: optional3(string4()),\n  confirmedLocalExecution: optional3(boolean4()),\n  objectChanges: optional3(array3(SuiObjectChange)),\n  balanceChanges: optional3(array3(BalanceChange)),\n  /* Errors that occurred in fetching/serializing the transaction. */\n  errors: optional3(array3(string4()))\n});\nvar SuiTransactionBlockResponseOptions = object4({\n  /* Whether to show transaction input data. Default to be false. */\n  showInput: optional3(boolean4()),\n  /* Whether to show transaction effects. Default to be false. */\n  showEffects: optional3(boolean4()),\n  /* Whether to show transaction events. Default to be false. */\n  showEvents: optional3(boolean4()),\n  /* Whether to show object changes. Default to be false. */\n  showObjectChanges: optional3(boolean4()),\n  /* Whether to show coin balance changes. Default to be false. */\n  showBalanceChanges: optional3(boolean4())\n});\nvar PaginatedTransactionResponse = object4({\n  data: array3(SuiTransactionBlockResponse),\n  nextCursor: nullable4(TransactionDigest),\n  hasNextPage: boolean4()\n});\nvar DryRunTransactionBlockResponse = object4({\n  effects: TransactionEffects,\n  events: TransactionEvents,\n  objectChanges: array3(SuiObjectChange),\n  balanceChanges: array3(BalanceChange),\n  // TODO: Remove optional when this is rolled out to all networks:\n  input: optional3(SuiTransactionBlockData)\n});\nfunction getTransaction(tx) {\n  return tx.transaction;\n}\nfunction getTransactionDigest(tx) {\n  return tx.digest;\n}\nfunction getTransactionSignature(tx) {\n  return tx.transaction?.txSignatures;\n}\nfunction getTransactionSender(tx) {\n  return tx.transaction?.data.sender;\n}\nfunction getGasData(tx) {\n  return tx.transaction?.data.gasData;\n}\nfunction getTransactionGasObject(tx) {\n  return getGasData(tx)?.payment;\n}\nfunction getTransactionGasPrice(tx) {\n  return getGasData(tx)?.price;\n}\nfunction getTransactionGasBudget(tx) {\n  return getGasData(tx)?.budget;\n}\nfunction getChangeEpochTransaction(data) {\n  return data.kind === \"ChangeEpoch\" ? data : void 0;\n}\nfunction getConsensusCommitPrologueTransaction(data) {\n  return data.kind === \"ConsensusCommitPrologue\" ? data : void 0;\n}\nfunction getTransactionKind(data) {\n  return data.transaction?.data.transaction;\n}\nfunction getTransactionKindName(data) {\n  return data.kind;\n}\nfunction getProgrammableTransaction(data) {\n  return data.kind === \"ProgrammableTransaction\" ? data : void 0;\n}\nfunction getExecutionStatusType(data) {\n  return getExecutionStatus(data)?.status;\n}\nfunction getExecutionStatus(data) {\n  return getTransactionEffects(data)?.status;\n}\nfunction getExecutionStatusError(data) {\n  return getExecutionStatus(data)?.error;\n}\nfunction getExecutionStatusGasSummary(data) {\n  if (is2(data, TransactionEffects)) {\n    return data.gasUsed;\n  }\n  return getTransactionEffects(data)?.gasUsed;\n}\nfunction getTotalGasUsed(data) {\n  const gasSummary = getExecutionStatusGasSummary(data);\n  return gasSummary ? BigInt(gasSummary.computationCost) + BigInt(gasSummary.storageCost) - BigInt(gasSummary.storageRebate) : void 0;\n}\nfunction getTotalGasUsedUpperBound(data) {\n  const gasSummary = getExecutionStatusGasSummary(data);\n  return gasSummary ? BigInt(gasSummary.computationCost) + BigInt(gasSummary.storageCost) : void 0;\n}\nfunction getTransactionEffects(data) {\n  return data.effects;\n}\nfunction getEvents(data) {\n  return data.events;\n}\nfunction getCreatedObjects(data) {\n  return getTransactionEffects(data)?.created;\n}\nfunction getTimestampFromTransactionResponse(data) {\n  return data.timestampMs ?? void 0;\n}\nfunction getNewlyCreatedCoinRefsAfterSplit(data) {\n  return getTransactionEffects(data)?.created?.map(c => c.reference);\n}\nfunction getObjectChanges(data) {\n  return data.objectChanges;\n}\nfunction getPublishedObjectChanges(data) {\n  return data.objectChanges?.filter(a => is2(a, SuiObjectChangePublished)) ?? [];\n}\n\n// src/types/option.ts\nfunction getOption(option2) {\n  if (typeof option2 === \"object\" && option2 !== null && \"type\" in option2 && option2.type.startsWith(\"0x1::option::Option<\")) {\n    return void 0;\n  }\n  return option2;\n}\n\n// src/framework/framework.ts\nimport { nullable as nullable5, number as number4, object as object5, string as string5 } from \"superstruct\";\nvar SUI_SYSTEM_ADDRESS = \"0x3\";\nvar SUI_FRAMEWORK_ADDRESS = \"0x2\";\nvar MOVE_STDLIB_ADDRESS = \"0x1\";\nvar OBJECT_MODULE_NAME = \"object\";\nvar UID_STRUCT_NAME = \"UID\";\nvar ID_STRUCT_NAME = \"ID\";\nvar SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nvar VALIDATORS_EVENTS_QUERY = \"0x3::validator_set::ValidatorEpochInfoEventV2\";\nvar SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId(\"0x6\");\nvar PAY_MODULE_NAME = \"pay\";\nvar PAY_SPLIT_COIN_VEC_FUNC_NAME = \"split_vec\";\nvar PAY_JOIN_COIN_FUNC_NAME = \"join\";\nvar COIN_TYPE_ARG_REGEX = /^0x2::coin::Coin<(.+)>$/;\nfunction isObjectDataFull(resp) {\n  return !!resp.data || !!resp.type;\n}\nvar CoinMetadataStruct = object5({\n  decimals: number4(),\n  name: string5(),\n  symbol: string5(),\n  description: string5(),\n  iconUrl: nullable5(string5()),\n  id: nullable5(ObjectId)\n});\nvar Coin = class {\n  static isCoin(data) {\n    return Coin.getType(data)?.match(COIN_TYPE_ARG_REGEX) != null;\n  }\n  static getCoinType(type) {\n    const [, res] = type.match(COIN_TYPE_ARG_REGEX) ?? [];\n    return res || null;\n  }\n  static getCoinTypeArg(obj) {\n    const type = Coin.getType(obj);\n    return type ? Coin.getCoinType(type) : null;\n  }\n  static isSUI(obj) {\n    const arg = Coin.getCoinTypeArg(obj);\n    return arg ? Coin.getCoinSymbol(arg) === \"SUI\" : false;\n  }\n  static getCoinSymbol(coinTypeArg) {\n    return coinTypeArg.substring(coinTypeArg.lastIndexOf(\":\") + 1);\n  }\n  static getCoinStructTag(coinTypeArg) {\n    return {\n      address: normalizeSuiObjectId(coinTypeArg.split(\"::\")[0]),\n      module: coinTypeArg.split(\"::\")[1],\n      name: coinTypeArg.split(\"::\")[2],\n      typeParams: []\n    };\n  }\n  static getID(obj) {\n    if (\"fields\" in obj) {\n      return obj.fields.id.id;\n    }\n    return getObjectId(obj);\n  }\n  static totalBalance(coins) {\n    return coins.reduce((partialSum, c) => partialSum + Coin.getBalanceFromCoinStruct(c), BigInt(0));\n  }\n  /**\n   * Sort coin by balance in an ascending order\n   */\n  static sortByBalance(coins) {\n    return [...coins].sort((a, b) => Coin.getBalanceFromCoinStruct(a) < Coin.getBalanceFromCoinStruct(b) ? -1 : Coin.getBalanceFromCoinStruct(a) > Coin.getBalanceFromCoinStruct(b) ? 1 : 0);\n  }\n  static getBalanceFromCoinStruct(coin) {\n    return BigInt(coin.balance);\n  }\n  static getBalance(data) {\n    if (!Coin.isCoin(data)) {\n      return void 0;\n    }\n    const balance = getObjectFields(data)?.balance;\n    return BigInt(balance);\n  }\n  static getType(data) {\n    if (isObjectDataFull(data)) {\n      return getObjectType(data);\n    }\n    return data.type;\n  }\n};\nvar _Delegation = class {\n  static isDelegationSuiObject(obj) {\n    return \"type\" in obj && obj.type === _Delegation.SUI_OBJECT_TYPE;\n  }\n  constructor(obj) {\n    this.suiObject = obj;\n  }\n  nextRewardUnclaimedEpoch() {\n    return this.suiObject.data.fields.next_reward_unclaimed_epoch;\n  }\n  activeDelegation() {\n    return BigInt(getOption(this.suiObject.data.fields.active_delegation) || 0);\n  }\n  delegateAmount() {\n    return this.suiObject.data.fields.delegate_amount;\n  }\n  endingEpoch() {\n    return getOption(this.suiObject.data.fields.ending_epoch);\n  }\n  validatorAddress() {\n    return this.suiObject.data.fields.validator_address;\n  }\n  isActive() {\n    return this.activeDelegation() > 0 && !this.endingEpoch();\n  }\n  hasUnclaimedRewards(epoch) {\n    return this.nextRewardUnclaimedEpoch() <= epoch && (this.isActive() || (this.endingEpoch() || 0) > epoch);\n  }\n};\nvar Delegation = _Delegation;\nDelegation.SUI_OBJECT_TYPE = \"0x2::delegation::Delegation\";\n\n// src/types/sui-bcs.ts\nimport { BCS, getSuiMoveConfig } from \"@mysten/bcs\";\nfunction isPureArg(arg) {\n  return arg.Pure !== void 0;\n}\nvar VECTOR = \"vector\";\nvar TransactionDataV1 = {\n  kind: \"TransactionKind\",\n  sender: BCS.ADDRESS,\n  gasData: \"GasData\",\n  expiration: \"TransactionExpiration\"\n};\nvar BCS_SPEC = {\n  enums: {\n    \"Option<T>\": {\n      None: null,\n      Some: \"T\"\n    },\n    ObjectArg: {\n      ImmOrOwned: \"SuiObjectRef\",\n      Shared: \"SharedObjectRef\"\n    },\n    CallArg: {\n      Pure: [VECTOR, BCS.U8],\n      Object: \"ObjectArg\",\n      ObjVec: [VECTOR, \"ObjectArg\"]\n    },\n    TypeTag: {\n      bool: null,\n      u8: null,\n      u64: null,\n      u128: null,\n      address: null,\n      signer: null,\n      vector: \"TypeTag\",\n      struct: \"StructTag\",\n      u16: null,\n      u32: null,\n      u256: null\n    },\n    TransactionKind: {\n      // can not be called from sui.js; dummy placement\n      // to set the enum counter right for ProgrammableTransact\n      ProgrammableTransaction: \"ProgrammableTransaction\",\n      ChangeEpoch: null,\n      Genesis: null,\n      ConsensusCommitPrologue: null\n    },\n    TransactionExpiration: {\n      None: null,\n      Epoch: BCS.U64\n    },\n    TransactionData: {\n      V1: \"TransactionDataV1\"\n    }\n  },\n  structs: {\n    SuiObjectRef: {\n      objectId: BCS.ADDRESS,\n      version: BCS.U64,\n      digest: \"ObjectDigest\"\n    },\n    SharedObjectRef: {\n      objectId: BCS.ADDRESS,\n      initialSharedVersion: BCS.U64,\n      mutable: BCS.BOOL\n    },\n    StructTag: {\n      address: BCS.ADDRESS,\n      module: BCS.STRING,\n      name: BCS.STRING,\n      typeParams: [VECTOR, \"TypeTag\"]\n    },\n    GasData: {\n      payment: [VECTOR, \"SuiObjectRef\"],\n      owner: BCS.ADDRESS,\n      price: BCS.U64,\n      budget: BCS.U64\n    },\n    // Signed transaction data needed to generate transaction digest.\n    SenderSignedData: {\n      data: \"TransactionData\",\n      txSignatures: [VECTOR, [VECTOR, BCS.U8]]\n    },\n    TransactionDataV1\n  },\n  aliases: {\n    ObjectDigest: BCS.BASE58\n  }\n};\nvar bcs = new BCS({\n  ...getSuiMoveConfig(),\n  types: BCS_SPEC\n});\nbcs.registerType(\"utf8string\", (writer, str) => {\n  const bytes = Array.from(new TextEncoder().encode(str));\n  return writer.writeVec(bytes, (writer2, el) => writer2.write8(el));\n}, reader => {\n  let bytes = reader.readVec(reader2 => reader2.read8());\n  return new TextDecoder().decode(new Uint8Array(bytes));\n});\n\n// src/types/faucet.ts\nimport { array as array4, nullable as nullable6, number as number5, object as object6, string as string6 } from \"superstruct\";\nvar FaucetCoinInfo = object6({\n  amount: number5(),\n  id: ObjectId,\n  transferTxDigest: TransactionDigest\n});\nvar FaucetResponse = object6({\n  transferredGasObjects: array4(FaucetCoinInfo),\n  error: nullable6(string6())\n});\n\n// src/types/normalized.ts\nimport { array as array5, object as object7, string as string7, union as union4, boolean as boolean5, define as define2, number as number6, literal as literal4, record as record4, is as is3, tuple as tuple3 } from \"superstruct\";\nvar SuiMoveFunctionArgType = union4([string7(), object7({\n  Object: string7()\n})]);\nvar SuiMoveFunctionArgTypes = array5(SuiMoveFunctionArgType);\nvar SuiMoveModuleId = object7({\n  address: string7(),\n  name: string7()\n});\nvar SuiMoveVisibility = union4([literal4(\"Private\"), literal4(\"Public\"), literal4(\"Friend\")]);\nvar SuiMoveAbilitySet = object7({\n  abilities: array5(string7())\n});\nvar SuiMoveStructTypeParameter = object7({\n  constraints: SuiMoveAbilitySet,\n  isPhantom: boolean5()\n});\nvar SuiMoveNormalizedTypeParameterType = object7({\n  TypeParameter: number6()\n});\nvar MoveCallMetric = tuple3([object7({\n  module: string7(),\n  package: string7(),\n  function: string7()\n}), string7()]);\nvar MoveCallMetrics = object7({\n  rank3Days: array5(MoveCallMetric),\n  rank7Days: array5(MoveCallMetric),\n  rank30Days: array5(MoveCallMetric)\n});\nfunction isSuiMoveNormalizedType(value) {\n  if (!value) return false;\n  if (typeof value === \"string\") return true;\n  if (is3(value, SuiMoveNormalizedTypeParameterType)) return true;\n  if (isSuiMoveNormalizedStructType(value)) return true;\n  if (typeof value !== \"object\") return false;\n  const valueProperties = value;\n  if (is3(valueProperties.Reference, SuiMoveNormalizedType)) return true;\n  if (is3(valueProperties.MutableReference, SuiMoveNormalizedType)) return true;\n  if (is3(valueProperties.Vector, SuiMoveNormalizedType)) return true;\n  return false;\n}\nvar SuiMoveNormalizedType = define2(\"SuiMoveNormalizedType\", isSuiMoveNormalizedType);\nfunction isSuiMoveNormalizedStructType(value) {\n  if (!value || typeof value !== \"object\") return false;\n  const valueProperties = value;\n  if (!valueProperties.Struct || typeof valueProperties.Struct !== \"object\") return false;\n  const structProperties = valueProperties.Struct;\n  if (typeof structProperties.address !== \"string\" || typeof structProperties.module !== \"string\" || typeof structProperties.name !== \"string\" || !Array.isArray(structProperties.typeArguments) || !structProperties.typeArguments.every(value2 => isSuiMoveNormalizedType(value2))) {\n    return false;\n  }\n  return true;\n}\nvar SuiMoveNormalizedStructType = define2(\"SuiMoveNormalizedStructType\", isSuiMoveNormalizedStructType);\nvar SuiMoveNormalizedFunction = object7({\n  visibility: SuiMoveVisibility,\n  isEntry: boolean5(),\n  typeParameters: array5(SuiMoveAbilitySet),\n  parameters: array5(SuiMoveNormalizedType),\n  return: array5(SuiMoveNormalizedType)\n});\nvar SuiMoveNormalizedField = object7({\n  name: string7(),\n  type: SuiMoveNormalizedType\n});\nvar SuiMoveNormalizedStruct = object7({\n  abilities: SuiMoveAbilitySet,\n  typeParameters: array5(SuiMoveStructTypeParameter),\n  fields: array5(SuiMoveNormalizedField)\n});\nvar SuiMoveNormalizedModule = object7({\n  fileFormatVersion: number6(),\n  address: string7(),\n  name: string7(),\n  friends: array5(SuiMoveModuleId),\n  structs: record4(string7(), SuiMoveNormalizedStruct),\n  exposedFunctions: record4(string7(), SuiMoveNormalizedFunction)\n});\nvar SuiMoveNormalizedModules = record4(string7(), SuiMoveNormalizedModule);\nfunction extractMutableReference(normalizedType) {\n  return typeof normalizedType === \"object\" && \"MutableReference\" in normalizedType ? normalizedType.MutableReference : void 0;\n}\nfunction extractReference(normalizedType) {\n  return typeof normalizedType === \"object\" && \"Reference\" in normalizedType ? normalizedType.Reference : void 0;\n}\nfunction extractStructTag(normalizedType) {\n  if (typeof normalizedType === \"object\" && \"Struct\" in normalizedType) {\n    return normalizedType;\n  }\n  const ref = extractReference(normalizedType);\n  const mutRef = extractMutableReference(normalizedType);\n  if (typeof ref === \"object\" && \"Struct\" in ref) {\n    return ref;\n  }\n  if (typeof mutRef === \"object\" && \"Struct\" in mutRef) {\n    return mutRef;\n  }\n  return void 0;\n}\n\n// src/types/validator.ts\nimport { array as array6, boolean as boolean6, literal as literal5, number as number7, object as object8, string as string8, union as union5, nullable as nullable7, tuple as tuple4, optional as optional4 } from \"superstruct\";\nvar Apy = object8({\n  apy: number7(),\n  address: SuiAddress\n});\nvar ValidatorsApy = object8({\n  epoch: string8(),\n  apys: array6(Apy)\n});\nvar Balance = object8({\n  value: number7()\n});\nvar StakeObject = object8({\n  stakedSuiId: ObjectId,\n  stakeRequestEpoch: EpochId,\n  stakeActiveEpoch: EpochId,\n  principal: string8(),\n  status: union5([literal5(\"Active\"), literal5(\"Pending\"), literal5(\"Unstaked\")]),\n  estimatedReward: optional4(string8())\n});\nvar DelegatedStake = object8({\n  validatorAddress: SuiAddress,\n  stakingPool: ObjectId,\n  stakes: array6(StakeObject)\n});\nvar StakeSubsidyFields = object8({\n  balance: object8({\n    value: number7()\n  }),\n  distribution_counter: number7(),\n  current_distribution_amount: number7(),\n  stake_subsidy_period_length: number7(),\n  stake_subsidy_decrease_rate: number7()\n});\nvar StakeSubsidy = object8({\n  type: string8(),\n  fields: StakeSubsidyFields\n});\nvar SuiSupplyFields = object8({\n  value: number7()\n});\nvar ContentsFields = object8({\n  id: string8(),\n  size: number7(),\n  head: object8({\n    vec: array6()\n  }),\n  tail: object8({\n    vec: array6()\n  })\n});\nvar ContentsFieldsWithdraw = object8({\n  id: string8(),\n  size: number7()\n});\nvar Contents = object8({\n  type: string8(),\n  fields: ContentsFields\n});\nvar DelegationStakingPoolFields = object8({\n  exchangeRates: object8({\n    id: string8(),\n    size: number7()\n  }),\n  id: string8(),\n  pendingStake: number7(),\n  pendingPoolTokenWithdraw: number7(),\n  pendingTotalSuiWithdraw: number7(),\n  poolTokenBalance: number7(),\n  rewardsPool: object8({\n    value: number7()\n  }),\n  activationEpoch: object8({\n    vec: array6()\n  }),\n  deactivationEpoch: object8({\n    vec: array6()\n  }),\n  suiBalance: number7()\n});\nvar DelegationStakingPool = object8({\n  type: string8(),\n  fields: DelegationStakingPoolFields\n});\nvar Validators = array6(tuple4([AuthorityName, string8()]));\nvar CommitteeInfo = object8({\n  epoch: EpochId,\n  /** Array of (validator public key, stake unit) tuple */\n  validators: Validators\n});\nvar SuiValidatorSummary = object8({\n  suiAddress: SuiAddress,\n  protocolPubkeyBytes: string8(),\n  networkPubkeyBytes: string8(),\n  workerPubkeyBytes: string8(),\n  proofOfPossessionBytes: string8(),\n  operationCapId: string8(),\n  name: string8(),\n  description: string8(),\n  imageUrl: string8(),\n  projectUrl: string8(),\n  p2pAddress: string8(),\n  netAddress: string8(),\n  primaryAddress: string8(),\n  workerAddress: string8(),\n  nextEpochProtocolPubkeyBytes: nullable7(string8()),\n  nextEpochProofOfPossession: nullable7(string8()),\n  nextEpochNetworkPubkeyBytes: nullable7(string8()),\n  nextEpochWorkerPubkeyBytes: nullable7(string8()),\n  nextEpochNetAddress: nullable7(string8()),\n  nextEpochP2pAddress: nullable7(string8()),\n  nextEpochPrimaryAddress: nullable7(string8()),\n  nextEpochWorkerAddress: nullable7(string8()),\n  votingPower: string8(),\n  gasPrice: string8(),\n  commissionRate: string8(),\n  nextEpochStake: string8(),\n  nextEpochGasPrice: string8(),\n  nextEpochCommissionRate: string8(),\n  stakingPoolId: string8(),\n  stakingPoolActivationEpoch: nullable7(string8()),\n  stakingPoolDeactivationEpoch: nullable7(string8()),\n  stakingPoolSuiBalance: string8(),\n  rewardsPool: string8(),\n  poolTokenBalance: string8(),\n  pendingStake: string8(),\n  pendingPoolTokenWithdraw: string8(),\n  pendingTotalSuiWithdraw: string8(),\n  exchangeRatesId: string8(),\n  exchangeRatesSize: string8()\n});\nvar SuiSystemStateSummary = object8({\n  epoch: string8(),\n  protocolVersion: string8(),\n  systemStateVersion: string8(),\n  storageFundTotalObjectStorageRebates: string8(),\n  storageFundNonRefundableBalance: string8(),\n  referenceGasPrice: string8(),\n  safeMode: boolean6(),\n  safeModeStorageRewards: string8(),\n  safeModeComputationRewards: string8(),\n  safeModeStorageRebates: string8(),\n  safeModeNonRefundableStorageFee: string8(),\n  epochStartTimestampMs: string8(),\n  epochDurationMs: string8(),\n  stakeSubsidyStartEpoch: string8(),\n  maxValidatorCount: string8(),\n  minValidatorJoiningStake: string8(),\n  validatorLowStakeThreshold: string8(),\n  validatorVeryLowStakeThreshold: string8(),\n  validatorLowStakeGracePeriod: string8(),\n  stakeSubsidyBalance: string8(),\n  stakeSubsidyDistributionCounter: string8(),\n  stakeSubsidyCurrentDistributionAmount: string8(),\n  stakeSubsidyPeriodLength: string8(),\n  stakeSubsidyDecreaseRate: number7(),\n  totalStake: string8(),\n  activeValidators: array6(SuiValidatorSummary),\n  pendingActiveValidatorsId: string8(),\n  pendingActiveValidatorsSize: string8(),\n  pendingRemovals: array6(string8()),\n  stakingPoolMappingsId: string8(),\n  stakingPoolMappingsSize: string8(),\n  inactivePoolsId: string8(),\n  inactivePoolsSize: string8(),\n  validatorCandidatesId: string8(),\n  validatorCandidatesSize: string8(),\n  atRiskValidators: array6(tuple4([SuiAddress, string8()])),\n  validatorReportRecords: array6(tuple4([SuiAddress, array6(SuiAddress)]))\n});\n\n// src/types/coin.ts\nimport { array as array7, boolean as boolean7, nullable as nullable8, number as number8, object as object9, optional as optional5, string as string9 } from \"superstruct\";\nvar CoinStruct = object9({\n  coinType: string9(),\n  // TODO(chris): rename this to objectId\n  coinObjectId: ObjectId,\n  version: string9(),\n  digest: TransactionDigest,\n  balance: string9(),\n  // TODO (jian): remove this when we move to 0.34\n  lockedUntilEpoch: optional5(nullable8(number8())),\n  previousTransaction: TransactionDigest\n});\nvar PaginatedCoins = object9({\n  data: array7(CoinStruct),\n  nextCursor: nullable8(ObjectId),\n  hasNextPage: boolean7()\n});\nvar CoinBalance = object9({\n  coinType: string9(),\n  coinObjectCount: number8(),\n  totalBalance: string9(),\n  lockedBalance: object9({\n    epochId: optional5(number8()),\n    number: optional5(number8())\n  })\n});\nvar CoinSupply = object9({\n  value: string9()\n});\n\n// src/types/epochs.ts\nimport { array as array8, boolean as boolean8, nullable as nullable9, number as number9, object as object10, string as string10 } from \"superstruct\";\nvar EndOfEpochInfo = object10({\n  lastCheckpointId: string10(),\n  epochEndTimestamp: string10(),\n  protocolVersion: string10(),\n  referenceGasPrice: string10(),\n  totalStake: string10(),\n  storageFundReinvestment: string10(),\n  storageCharge: string10(),\n  storageRebate: string10(),\n  storageFundBalance: string10(),\n  stakeSubsidyAmount: string10(),\n  totalGasFees: string10(),\n  totalStakeRewardsDistributed: string10(),\n  leftoverStorageFundInflow: string10()\n});\nvar EpochInfo = object10({\n  epoch: string10(),\n  validators: array8(SuiValidatorSummary),\n  epochTotalTransactions: string10(),\n  firstCheckpointId: string10(),\n  epochStartTimestamp: string10(),\n  endOfEpochInfo: nullable9(EndOfEpochInfo),\n  referenceGasPrice: nullable9(number9())\n});\nvar EpochPage = object10({\n  data: array8(EpochInfo),\n  nextCursor: nullable9(string10()),\n  hasNextPage: boolean8()\n});\n\n// src/types/subscriptions.ts\nimport { number as number10 } from \"superstruct\";\nvar SubscriptionId = number10();\n\n// src/types/name-service.ts\nimport { array as array9, boolean as boolean9, nullable as nullable10, object as object11, string as string11 } from \"superstruct\";\nvar ResolvedNameServiceNames = object11({\n  data: array9(string11()),\n  hasNextPage: boolean9(),\n  nextCursor: nullable10(ObjectId)\n});\n\n// src/types/checkpoints.ts\nimport { array as array10, number as number11, object as object12, string as string12, tuple as tuple5, boolean as boolean10, optional as optional6, any as any3, nullable as nullable11 } from \"superstruct\";\nvar GasCostSummary2 = object12({\n  computationCost: string12(),\n  storageCost: string12(),\n  storageRebate: string12(),\n  nonRefundableStorageFee: string12()\n});\nvar CheckPointContentsDigest = string12();\nvar CheckpointDigest = string12();\nvar ECMHLiveObjectSetDigest = object12({\n  digest: array10(number11())\n});\nvar CheckpointCommitment = any3();\nvar ValidatorSignature = string12();\nvar EndOfEpochData = object12({\n  nextEpochCommittee: array10(tuple5([string12(), string12()])),\n  nextEpochProtocolVersion: string12(),\n  epochCommitments: array10(CheckpointCommitment)\n});\nvar ExecutionDigests = object12({\n  transaction: TransactionDigest,\n  effects: TransactionEffectsDigest\n});\nvar Checkpoint = object12({\n  epoch: string12(),\n  sequenceNumber: string12(),\n  digest: CheckpointDigest,\n  networkTotalTransactions: string12(),\n  previousDigest: optional6(CheckpointDigest),\n  epochRollingGasCostSummary: GasCostSummary2,\n  timestampMs: string12(),\n  endOfEpochData: optional6(EndOfEpochData),\n  // TODO(jian): remove optional after 0.30.0 is released\n  validatorSignature: optional6(ValidatorSignature),\n  transactions: array10(TransactionDigest),\n  checkpointCommitments: array10(CheckpointCommitment)\n});\nvar CheckpointPage = object12({\n  data: array10(Checkpoint),\n  nextCursor: nullable11(string12()),\n  hasNextPage: boolean10()\n});\n\n// src/cryptography/ed25519-publickey.ts\nimport { blake2b as blake2b2 } from \"@noble/hashes/blake2b\";\nimport { fromB64 as fromB643, toB64 as toB643 } from \"@mysten/bcs\";\n\n// src/cryptography/signature.ts\nimport { fromB64 as fromB642, toB64 as toB642 } from \"@mysten/bcs\";\n\n// src/cryptography/secp256r1-publickey.ts\nimport { fromB64, toB64 } from \"@mysten/bcs\";\nimport { blake2b } from \"@noble/hashes/blake2b\";\nimport { bytesToHex } from \"@noble/hashes/utils\";\nvar SECP256R1_PUBLIC_KEY_SIZE = 33;\nvar Secp256r1PublicKey = class {\n  /**\n   * Create a new Secp256r1PublicKey object\n   * @param value secp256r1 public key as buffer or base-64 encoded string\n   */\n  constructor(value) {\n    if (typeof value === \"string\") {\n      this.data = fromB64(value);\n    } else if (value instanceof Uint8Array) {\n      this.data = value;\n    } else {\n      this.data = Uint8Array.from(value);\n    }\n    if (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {\n      throw new Error(`Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`);\n    }\n  }\n  /**\n   * Checks if two Secp256r1 public keys are equal\n   */\n  equals(publicKey) {\n    return bytesEqual(this.toBytes(), publicKey.toBytes());\n  }\n  /**\n   * Return the base-64 representation of the Secp256r1 public key\n   */\n  toBase64() {\n    return toB64(this.toBytes());\n  }\n  /**\n   * Return the byte array representation of the Secp256r1 public key\n   */\n  toBytes() {\n    return this.data;\n  }\n  /**\n   * Return the base-64 representation of the Secp256r1 public key\n   */\n  toString() {\n    return this.toBase64();\n  }\n  /**\n   * Return the Sui address associated with this Secp256r1 public key\n   */\n  toSuiAddress() {\n    let tmp = new Uint8Array(SECP256R1_PUBLIC_KEY_SIZE + 1);\n    tmp.set([SIGNATURE_SCHEME_TO_FLAG[\"Secp256r1\"]]);\n    tmp.set(this.toBytes(), 1);\n    return normalizeSuiAddress(bytesToHex(blake2b(tmp, {\n      dkLen: 32\n    })).slice(0, SUI_ADDRESS_LENGTH * 2));\n  }\n  /**\n   * Return the Sui address associated with this Secp256r1 public key\n   */\n  flag() {\n    return SIGNATURE_SCHEME_TO_FLAG[\"Secp256r1\"];\n  }\n};\nSecp256r1PublicKey.SIZE = SECP256R1_PUBLIC_KEY_SIZE;\n\n// src/cryptography/signature.ts\nvar SIGNATURE_SCHEME_TO_FLAG = {\n  ED25519: 0,\n  Secp256k1: 1,\n  Secp256r1: 2,\n  MultiSig: 3\n};\nvar SIGNATURE_FLAG_TO_SCHEME = {\n  0: \"ED25519\",\n  1: \"Secp256k1\",\n  2: \"Secp256r1\",\n  3: \"MultiSig\"\n};\nfunction toSerializedSignature(_ref) {\n  let {\n    signature,\n    signatureScheme,\n    pubKey\n  } = _ref;\n  const serializedSignature = new Uint8Array(1 + signature.length + pubKey.toBytes().length);\n  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);\n  serializedSignature.set(signature, 1);\n  serializedSignature.set(pubKey.toBytes(), 1 + signature.length);\n  return toB642(serializedSignature);\n}\nfunction fromSerializedSignature(serializedSignature) {\n  const bytes = fromB642(serializedSignature);\n  const signatureScheme = SIGNATURE_FLAG_TO_SCHEME[bytes[0]];\n  if (signatureScheme === \"MultiSig\") {\n    throw new Error(\"MultiSig is not supported\");\n  }\n  const SIGNATURE_SCHEME_TO_PUBLIC_KEY = {\n    ED25519: Ed25519PublicKey,\n    Secp256k1: Secp256k1PublicKey,\n    Secp256r1: Secp256r1PublicKey\n  };\n  const PublicKey3 = SIGNATURE_SCHEME_TO_PUBLIC_KEY[signatureScheme];\n  const signature = bytes.slice(1, bytes.length - PublicKey3.SIZE);\n  const pubkeyBytes = bytes.slice(1 + signature.length);\n  const pubKey = new PublicKey3(pubkeyBytes);\n  return {\n    signatureScheme,\n    signature,\n    pubKey\n  };\n}\n\n// src/cryptography/ed25519-publickey.ts\nimport { bytesToHex as bytesToHex2 } from \"@noble/hashes/utils\";\nvar PUBLIC_KEY_SIZE = 32;\nvar Ed25519PublicKey = class {\n  /**\n   * Create a new Ed25519PublicKey object\n   * @param value ed25519 public key as buffer or base-64 encoded string\n   */\n  constructor(value) {\n    if (typeof value === \"string\") {\n      this.data = fromB643(value);\n    } else if (value instanceof Uint8Array) {\n      this.data = value;\n    } else {\n      this.data = Uint8Array.from(value);\n    }\n    if (this.data.length !== PUBLIC_KEY_SIZE) {\n      throw new Error(`Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`);\n    }\n  }\n  /**\n   * Checks if two Ed25519 public keys are equal\n   */\n  equals(publicKey) {\n    return bytesEqual(this.toBytes(), publicKey.toBytes());\n  }\n  /**\n   * Return the base-64 representation of the Ed25519 public key\n   */\n  toBase64() {\n    return toB643(this.toBytes());\n  }\n  /**\n   * Return the byte array representation of the Ed25519 public key\n   */\n  toBytes() {\n    return this.data;\n  }\n  /**\n   * Return the base-64 representation of the Ed25519 public key\n   */\n  toString() {\n    return this.toBase64();\n  }\n  /**\n   * Return the Sui address associated with this Ed25519 public key\n   */\n  toSuiAddress() {\n    let tmp = new Uint8Array(PUBLIC_KEY_SIZE + 1);\n    tmp.set([SIGNATURE_SCHEME_TO_FLAG[\"ED25519\"]]);\n    tmp.set(this.toBytes(), 1);\n    return normalizeSuiAddress(bytesToHex2(blake2b2(tmp, {\n      dkLen: 32\n    })).slice(0, SUI_ADDRESS_LENGTH * 2));\n  }\n  /**\n   * Return the Sui address associated with this Ed25519 public key\n   */\n  flag() {\n    return SIGNATURE_SCHEME_TO_FLAG[\"ED25519\"];\n  }\n};\nEd25519PublicKey.SIZE = PUBLIC_KEY_SIZE;\n\n// src/cryptography/publickey.ts\nfunction bytesEqual(a, b) {\n  if (a === b) return true;\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction publicKeyFromSerialized(schema, pubKey) {\n  if (schema === \"ED25519\") {\n    return new Ed25519PublicKey(pubKey);\n  }\n  if (schema === \"Secp256k1\") {\n    return new Secp256k1PublicKey(pubKey);\n  }\n  throw new Error(\"Unknown public key schema\");\n}\n\n// src/cryptography/secp256k1-publickey.ts\nvar SECP256K1_PUBLIC_KEY_SIZE = 33;\nvar Secp256k1PublicKey = class {\n  /**\n   * Create a new Secp256k1PublicKey object\n   * @param value secp256k1 public key as buffer or base-64 encoded string\n   */\n  constructor(value) {\n    if (typeof value === \"string\") {\n      this.data = fromB644(value);\n    } else if (value instanceof Uint8Array) {\n      this.data = value;\n    } else {\n      this.data = Uint8Array.from(value);\n    }\n    if (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {\n      throw new Error(`Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`);\n    }\n  }\n  /**\n   * Checks if two Secp256k1 public keys are equal\n   */\n  equals(publicKey) {\n    return bytesEqual(this.toBytes(), publicKey.toBytes());\n  }\n  /**\n   * Return the base-64 representation of the Secp256k1 public key\n   */\n  toBase64() {\n    return toB644(this.toBytes());\n  }\n  /**\n   * Return the byte array representation of the Secp256k1 public key\n   */\n  toBytes() {\n    return this.data;\n  }\n  /**\n   * Return the base-64 representation of the Secp256k1 public key\n   */\n  toString() {\n    return this.toBase64();\n  }\n  /**\n   * Return the Sui address associated with this Secp256k1 public key\n   */\n  toSuiAddress() {\n    let tmp = new Uint8Array(SECP256K1_PUBLIC_KEY_SIZE + 1);\n    tmp.set([SIGNATURE_SCHEME_TO_FLAG[\"Secp256k1\"]]);\n    tmp.set(this.toBytes(), 1);\n    return normalizeSuiAddress(bytesToHex3(blake2b3(tmp, {\n      dkLen: 32\n    })).slice(0, SUI_ADDRESS_LENGTH * 2));\n  }\n  /**\n   * Return the Sui address associated with this Secp256k1 public key\n   */\n  flag() {\n    return SIGNATURE_SCHEME_TO_FLAG[\"Secp256k1\"];\n  }\n};\nSecp256k1PublicKey.SIZE = SECP256K1_PUBLIC_KEY_SIZE;\n\n// src/cryptography/secp256k1-keypair.ts\nimport { secp256k1 } from \"@noble/curves/secp256k1\";\n\n// src/cryptography/mnemonics.ts\nimport { toHEX } from \"@mysten/bcs\";\nimport { mnemonicToSeedSync as bip39MnemonicToSeedSync } from \"@scure/bip39\";\nfunction isValidHardenedPath(path) {\n  if (!new RegExp(\"^m\\\\/44'\\\\/784'\\\\/[0-9]+'\\\\/[0-9]+'\\\\/[0-9]+'+$\").test(path)) {\n    return false;\n  }\n  return true;\n}\nfunction isValidBIP32Path(path) {\n  if (!new RegExp(\"^m\\\\/(54|74)'\\\\/784'\\\\/[0-9]+'\\\\/[0-9]+\\\\/[0-9]+$\").test(path)) {\n    return false;\n  }\n  return true;\n}\nfunction mnemonicToSeed(mnemonics) {\n  return bip39MnemonicToSeedSync(mnemonics, \"\");\n}\nfunction mnemonicToSeedHex(mnemonics) {\n  return toHEX(mnemonicToSeed(mnemonics));\n}\n\n// src/cryptography/secp256k1-keypair.ts\nimport { HDKey } from \"@scure/bip32\";\nimport { toB64 as toB645 } from \"@mysten/bcs\";\nimport { bytesToHex as bytesToHex4 } from \"@noble/hashes/utils\";\nimport { blake2b as blake2b4 } from \"@noble/hashes/blake2b\";\nvar DEFAULT_SECP256K1_DERIVATION_PATH = \"m/54'/784'/0'/0/0\";\nvar Secp256k1Keypair = class {\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Secp256k1Keypair} is provided.\n   *\n   * @param keypair secp256k1 keypair\n   */\n  constructor(keypair) {\n    if (keypair) {\n      this.keypair = keypair;\n    } else {\n      const secretKey = secp256k1.utils.randomPrivateKey();\n      const publicKey = secp256k1.getPublicKey(secretKey, true);\n      this.keypair = {\n        publicKey,\n        secretKey\n      };\n    }\n  }\n  /**\n   * Get the key scheme of the keypair Secp256k1\n   */\n  getKeyScheme() {\n    return \"Secp256k1\";\n  }\n  /**\n   * Generate a new random keypair\n   */\n  static generate() {\n    return new Secp256k1Keypair();\n  }\n  /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options: skip secret key validation\n   */\n  static fromSecretKey(secretKey, options) {\n    const publicKey = secp256k1.getPublicKey(secretKey, true);\n    if (!options || !options.skipValidation) {\n      const encoder = new TextEncoder();\n      const signData = encoder.encode(\"sui validation\");\n      const msgHash = bytesToHex4(blake2b4(signData, {\n        dkLen: 32\n      }));\n      const signature = secp256k1.sign(msgHash, secretKey);\n      if (!secp256k1.verify(signature, msgHash, publicKey, {\n        lowS: true\n      })) {\n        throw new Error(\"Provided secretKey is invalid\");\n      }\n    }\n    return new Secp256k1Keypair({\n      publicKey,\n      secretKey\n    });\n  }\n  /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   */\n  static fromSeed(seed) {\n    let publicKey = secp256k1.getPublicKey(seed, true);\n    return new Secp256k1Keypair({\n      publicKey,\n      secretKey: seed\n    });\n  }\n  /**\n   * The public key for this keypair\n   */\n  getPublicKey() {\n    return new Secp256k1PublicKey(this.keypair.publicKey);\n  }\n  /**\n   * Return the signature for the provided data.\n   */\n  signData(data) {\n    const msgHash = sha256(data);\n    const sig = secp256k1.sign(msgHash, this.keypair.secretKey, {\n      lowS: true\n    });\n    return sig.toCompactRawBytes();\n  }\n  /**\n   * Derive Secp256k1 keypair from mnemonics and path. The mnemonics must be normalized\n   * and validated against the english wordlist.\n   *\n   * If path is none, it will default to m/54'/784'/0'/0/0, otherwise the path must\n   * be compliant to BIP-32 in form m/54'/784'/{account_index}'/{change_index}/{address_index}.\n   */\n  static deriveKeypair(mnemonics, path) {\n    if (path == null) {\n      path = DEFAULT_SECP256K1_DERIVATION_PATH;\n    }\n    if (!isValidBIP32Path(path)) {\n      throw new Error(\"Invalid derivation path\");\n    }\n    const key = HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path);\n    if (key.publicKey == null || key.privateKey == null) {\n      throw new Error(\"Invalid key\");\n    }\n    return new Secp256k1Keypair({\n      publicKey: key.publicKey,\n      secretKey: key.privateKey\n    });\n  }\n  export() {\n    return {\n      schema: \"Secp256k1\",\n      privateKey: toB645(this.keypair.secretKey)\n    };\n  }\n};\n\n// src/cryptography/keypair.ts\nvar PRIVATE_KEY_SIZE = 32;\nvar LEGACY_PRIVATE_KEY_SIZE = 64;\nfunction fromExportedKeypair(keypair) {\n  const secretKey = fromB645(keypair.privateKey);\n  switch (keypair.schema) {\n    case \"ED25519\":\n      let pureSecretKey = secretKey;\n      if (secretKey.length === LEGACY_PRIVATE_KEY_SIZE) {\n        pureSecretKey = secretKey.slice(0, PRIVATE_KEY_SIZE);\n      }\n      return Ed25519Keypair.fromSecretKey(pureSecretKey);\n    case \"Secp256k1\":\n      return Secp256k1Keypair.fromSecretKey(secretKey);\n    default:\n      throw new Error(`Invalid keypair schema ${keypair.schema}`);\n  }\n}\n\n// src/utils/ed25519-hd-key.ts\nimport { sha512 } from \"@noble/hashes/sha512\";\nimport { hmac } from \"@noble/hashes/hmac\";\nimport nacl from \"tweetnacl\";\nimport { fromHEX } from \"@mysten/bcs\";\nvar ED25519_CURVE = \"ed25519 seed\";\nvar HARDENED_OFFSET = 2147483648;\nvar pathRegex = new RegExp(\"^m(\\\\/[0-9]+')+$\");\nvar replaceDerive = val => val.replace(\"'\", \"\");\nvar getMasterKeyFromSeed = seed => {\n  const h = hmac.create(sha512, ED25519_CURVE);\n  const I = h.update(fromHEX(seed)).digest();\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n};\nvar CKDPriv = (_ref2, index) => {\n  let {\n    key,\n    chainCode\n  } = _ref2;\n  const indexBuffer = new ArrayBuffer(4);\n  const cv = new DataView(indexBuffer);\n  cv.setUint32(0, index);\n  const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);\n  data.set(new Uint8Array(1).fill(0));\n  data.set(key, 1);\n  data.set(new Uint8Array(indexBuffer, 0, indexBuffer.byteLength), key.length + 1);\n  const I = hmac.create(sha512, chainCode).update(data).digest();\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR\n  };\n};\nvar isValidPath = path => {\n  if (!pathRegex.test(path)) {\n    return false;\n  }\n  return !path.split(\"/\").slice(1).map(replaceDerive).some(isNaN\n  /* ts T_T*/);\n};\n\nvar derivePath = function (path, seed) {\n  let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : HARDENED_OFFSET;\n  if (!isValidPath(path)) {\n    throw new Error(\"Invalid derivation path\");\n  }\n  const {\n    key,\n    chainCode\n  } = getMasterKeyFromSeed(seed);\n  const segments = path.split(\"/\").slice(1).map(replaceDerive).map(el => parseInt(el, 10));\n  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), {\n    key,\n    chainCode\n  });\n};\n\n// src/cryptography/ed25519-keypair.ts\nimport { toB64 as toB646 } from \"@mysten/bcs\";\nvar DEFAULT_ED25519_DERIVATION_PATH = \"m/44'/784'/0'/0'/0'\";\nvar Ed25519Keypair = class {\n  /**\n   * Create a new Ed25519 keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param keypair Ed25519 keypair\n   */\n  constructor(keypair) {\n    if (keypair) {\n      this.keypair = keypair;\n    } else {\n      this.keypair = nacl2.sign.keyPair();\n    }\n  }\n  /**\n   * Get the key scheme of the keypair ED25519\n   */\n  getKeyScheme() {\n    return \"ED25519\";\n  }\n  /**\n   * Generate a new random Ed25519 keypair\n   */\n  static generate() {\n    return new Ed25519Keypair(nacl2.sign.keyPair());\n  }\n  /**\n   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.\n   * This is NOT the private scalar which is result of hashing and bit clamping of\n   * the raw secret key.\n   *\n   * The sui.keystore key is a list of Base64 encoded `flag || privkey`. To import\n   * a key from sui.keystore to typescript, decode from base64 and remove the first\n   * flag byte after checking it is indeed the Ed25519 scheme flag 0x00 (See more\n   * on flag for signature scheme: https://github.com/MystenLabs/sui/blob/818406c5abdf7de1b80915a0519071eec3a5b1c7/crates/sui-types/src/crypto.rs#L1650):\n   * ```\n   * import { Ed25519Keypair, fromB64 } from '@mysten/sui.js';\n   * const raw = fromB64(t[1]);\n   * if (raw[0] !== 0 || raw.length !== PRIVATE_KEY_SIZE + 1) {\n   *   throw new Error('invalid key');\n   * }\n   * const imported = Ed25519Keypair.fromSecretKey(raw.slice(1))\n   * ```\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options: skip secret key validation\n   */\n  static fromSecretKey(secretKey, options) {\n    const secretKeyLength = secretKey.length;\n    if (secretKeyLength !== PRIVATE_KEY_SIZE) {\n      throw new Error(`Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`);\n    }\n    const keypair = nacl2.sign.keyPair.fromSeed(secretKey);\n    if (!options || !options.skipValidation) {\n      const encoder = new TextEncoder();\n      const signData = encoder.encode(\"sui validation\");\n      const signature = nacl2.sign.detached(signData, keypair.secretKey);\n      if (!nacl2.sign.detached.verify(signData, signature, keypair.publicKey)) {\n        throw new Error(\"provided secretKey is invalid\");\n      }\n    }\n    return new Ed25519Keypair(keypair);\n  }\n  /**\n   * The public key for this Ed25519 keypair\n   */\n  getPublicKey() {\n    return new Ed25519PublicKey(this.keypair.publicKey);\n  }\n  /**\n   * Return the signature for the provided data using Ed25519.\n   */\n  signData(data) {\n    return nacl2.sign.detached(data, this.keypair.secretKey);\n  }\n  /**\n   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized\n   * and validated against the english wordlist.\n   *\n   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must\n   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.\n   */\n  static deriveKeypair(mnemonics, path) {\n    if (path == null) {\n      path = DEFAULT_ED25519_DERIVATION_PATH;\n    }\n    if (!isValidHardenedPath(path)) {\n      throw new Error(\"Invalid derivation path\");\n    }\n    const {\n      key\n    } = derivePath(path, mnemonicToSeedHex(mnemonics));\n    return Ed25519Keypair.fromSecretKey(key);\n  }\n  /**\n   * This returns an exported keypair object, the private key field is the pure 32-byte seed.\n   */\n  export() {\n    return {\n      schema: \"ED25519\",\n      privateKey: toB646(this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE))\n    };\n  }\n};\n\n// src/cryptography/secp256r1-keypair.ts\nimport { sha256 as sha2562 } from \"@noble/hashes/sha256\";\nimport { secp256r1 } from \"@noble/curves/p256\";\nimport { HDKey as HDKey2 } from \"@scure/bip32\";\nimport { toB64 as toB647 } from \"@mysten/bcs\";\nimport { bytesToHex as bytesToHex5 } from \"@noble/hashes/utils\";\nimport { blake2b as blake2b5 } from \"@noble/hashes/blake2b\";\nvar DEFAULT_SECP256R1_DERIVATION_PATH = \"m/74'/784'/0'/0/0\";\nvar Secp256r1Keypair = class {\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Secp256r1Keypair} is provided.\n   *\n   * @param keypair Secp256r1 keypair\n   */\n  constructor(keypair) {\n    if (keypair) {\n      this.keypair = keypair;\n    } else {\n      const secretKey = secp256r1.utils.randomPrivateKey();\n      const publicKey = secp256r1.getPublicKey(secretKey, true);\n      this.keypair = {\n        publicKey,\n        secretKey\n      };\n    }\n  }\n  /**\n   * Get the key scheme of the keypair Secp256r1\n   */\n  getKeyScheme() {\n    return \"Secp256r1\";\n  }\n  /**\n   * Generate a new random keypair\n   */\n  static generate() {\n    return new Secp256r1Keypair();\n  }\n  /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options: skip secret key validation\n   */\n  static fromSecretKey(secretKey, options) {\n    const publicKey = secp256r1.getPublicKey(secretKey, true);\n    if (!options || !options.skipValidation) {\n      const encoder = new TextEncoder();\n      const signData = encoder.encode(\"sui validation\");\n      const msgHash = bytesToHex5(blake2b5(signData, {\n        dkLen: 32\n      }));\n      const signature = secp256r1.sign(msgHash, secretKey, {\n        lowS: true\n      });\n      if (!secp256r1.verify(signature, msgHash, publicKey, {\n        lowS: true\n      })) {\n        throw new Error(\"Provided secretKey is invalid\");\n      }\n    }\n    return new Secp256r1Keypair({\n      publicKey,\n      secretKey\n    });\n  }\n  /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   */\n  static fromSeed(seed) {\n    let publicKey = secp256r1.getPublicKey(seed, true);\n    return new Secp256r1Keypair({\n      publicKey,\n      secretKey: seed\n    });\n  }\n  /**\n   * The public key for this keypair\n   */\n  getPublicKey() {\n    return new Secp256r1PublicKey(this.keypair.publicKey);\n  }\n  /**\n   * Return the signature for the provided data.\n   */\n  signData(data) {\n    const msgHash = sha2562(data);\n    const sig = secp256r1.sign(msgHash, this.keypair.secretKey, {\n      lowS: true\n    });\n    return sig.toCompactRawBytes();\n  }\n  /**\n   * Derive Secp256r1 keypair from mnemonics and path. The mnemonics must be normalized\n   * and validated against the english wordlist.\n   *\n   * If path is none, it will default to m/74'/784'/0'/0/0, otherwise the path must\n   * be compliant to BIP-32 in form m/74'/784'/{account_index}'/{change_index}/{address_index}.\n   */\n  static deriveKeypair(mnemonics, path) {\n    if (path == null) {\n      path = DEFAULT_SECP256R1_DERIVATION_PATH;\n    }\n    if (!isValidBIP32Path(path)) {\n      throw new Error(\"Invalid derivation path\");\n    }\n    const privateKey = HDKey2.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path).privateKey;\n    return Secp256r1Keypair.fromSecretKey(privateKey);\n  }\n  export() {\n    return {\n      schema: \"Secp256r1\",\n      privateKey: toB647(this.keypair.secretKey)\n    };\n  }\n};\n\n// src/cryptography/multisig.ts\nimport { toB64 as toB648 } from \"@mysten/bcs\";\nimport { blake2b as blake2b6 } from \"@noble/hashes/blake2b\";\nimport { bytesToHex as bytesToHex6 } from \"@noble/hashes/utils\";\nvar MAX_SIGNER_IN_MULTISIG = 10;\nfunction toMultiSigAddress(pks, threshold) {\n  if (pks.length > MAX_SIGNER_IN_MULTISIG) {\n    throw new Error(`Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`);\n  }\n  let maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;\n  let tmp = new Uint8Array(maxLength);\n  tmp.set([SIGNATURE_SCHEME_TO_FLAG[\"MultiSig\"]]);\n  let arr = to_uint8array(threshold);\n  tmp.set(arr, 1);\n  let i = 3;\n  for (const pk of pks) {\n    tmp.set([pk.pubKey.flag()], i);\n    tmp.set(pk.pubKey.toBytes(), i + 1);\n    tmp.set([pk.weight], i + 1 + pk.pubKey.toBytes().length);\n    i += pk.pubKey.toBytes().length + 2;\n  }\n  return normalizeSuiAddress(bytesToHex6(blake2b6(tmp.slice(0, i), {\n    dkLen: 32\n  })));\n}\nfunction combinePartialSigs(sigs, pks, threshold) {\n  let multisig_pk = {\n    pk_map: pks.map(x => toPkWeightPair(x)),\n    threshold\n  };\n  let bitmap = 0;\n  let compressed_sigs = new Array(sigs.length);\n  for (let i = 0; i < sigs.length; i++) {\n    let parsed = fromSerializedSignature(sigs[i]);\n    let bytes2 = Array.from(parsed.signature.map(x => Number(x)));\n    if (parsed.signatureScheme === \"ED25519\") {\n      compressed_sigs[i] = {\n        ED25519: bytes2\n      };\n    } else if (parsed.signatureScheme === \"Secp256k1\") {\n      compressed_sigs[i] = {\n        Secp256k1: bytes2\n      };\n    } else if (parsed.signatureScheme === \"Secp256r1\") {\n      compressed_sigs[i] = {\n        Secp256r1: bytes2\n      };\n    }\n    for (let j = 0; j < pks.length; j++) {\n      if (parsed.pubKey.equals(pks[j].pubKey)) {\n        bitmap |= 1 << j;\n        break;\n      }\n    }\n  }\n  let multisig = {\n    sigs: compressed_sigs,\n    bitmap,\n    multisig_pk\n  };\n  const bytes = builder.ser(\"MultiSig\", multisig).toBytes();\n  let tmp = new Uint8Array(bytes.length + 1);\n  tmp.set([SIGNATURE_SCHEME_TO_FLAG[\"MultiSig\"]]);\n  tmp.set(bytes, 1);\n  return toB648(tmp);\n}\nfunction decodeMultiSig(signature) {\n  const parsed = fromB646(signature);\n  if (parsed.length < 1 || parsed[0] !== SIGNATURE_SCHEME_TO_FLAG[\"MultiSig\"]) {\n    throw new Error(\"Invalid MultiSig flag\");\n  }\n  const multisig = builder.de(\"MultiSig\", parsed.slice(1));\n  let res = new Array(multisig.sigs.length);\n  for (let i = 0; i < multisig.sigs.length; i++) {\n    let s = multisig.sigs[i];\n    let pk_index = as_indices(multisig.bitmap).at(i);\n    let pk_bytes = Object.values(multisig.multisig_pk.pk_map[pk_index].pubKey)[0];\n    const scheme = Object.keys(s)[0];\n    if (scheme === \"MultiSig\") {\n      throw new Error(\"MultiSig is not supported inside MultiSig\");\n    }\n    const SIGNATURE_SCHEME_TO_PUBLIC_KEY = {\n      ED25519: Ed25519PublicKey,\n      Secp256k1: Secp256k1PublicKey,\n      Secp256r1: Secp256r1PublicKey\n    };\n    const PublicKey3 = SIGNATURE_SCHEME_TO_PUBLIC_KEY[scheme];\n    res[i] = {\n      signatureScheme: scheme,\n      signature: Uint8Array.from(Object.values(s)[0]),\n      pubKey: new PublicKey3(pk_bytes)\n    };\n  }\n  return res;\n}\nfunction toPkWeightPair(pair) {\n  let pk_bytes = Array.from(pair.pubKey.toBytes().map(x => Number(x)));\n  switch (pair.pubKey.flag()) {\n    case SIGNATURE_SCHEME_TO_FLAG[\"Secp256k1\"]:\n      return {\n        pubKey: {\n          Secp256k1: pk_bytes\n        },\n        weight: pair.weight\n      };\n    case SIGNATURE_SCHEME_TO_FLAG[\"Secp256r1\"]:\n      return {\n        pubKey: {\n          Secp256r1: pk_bytes\n        },\n        weight: pair.weight\n      };\n    case SIGNATURE_SCHEME_TO_FLAG[\"ED25519\"]:\n      return {\n        pubKey: {\n          ED25519: pk_bytes\n        },\n        weight: pair.weight\n      };\n    default:\n      throw new Error(\"Unsupported signature scheme\");\n  }\n}\nfunction to_uint8array(threshold) {\n  if (threshold < 0 || threshold > 65535) {\n    throw new Error(\"Invalid threshold\");\n  }\n  let arr = new Uint8Array(2);\n  arr[0] = threshold & 255;\n  arr[1] = threshold >> 8;\n  return arr;\n}\nfunction as_indices(bitmap) {\n  if (bitmap < 0 || bitmap > 1024) {\n    throw new Error(\"Invalid bitmap\");\n  }\n  let res = [];\n  for (let i = 0; i < 10; i++) {\n    if ((bitmap & 1 << i) !== 0) {\n      res.push(i);\n    }\n  }\n  return Uint8Array.from(res);\n}\n\n// src/rpc/client.ts\nimport { RequestManager, HTTPTransport, Client } from \"@open-rpc/client-js\";\nimport \"superstruct\";\n\n// src/version.ts\nvar PACKAGE_VERSION = \"0.36.0\";\nvar TARGETED_RPC_VERSION = \"1.4.0\";\n\n// src/utils/errors.ts\nvar RPCValidationError = class extends Error {\n  constructor(options) {\n    super(\"RPC Validation Error: The response returned from RPC server does not match the TypeScript definition. This is likely because the SDK version is not compatible with the RPC server.\", {\n      cause: options.cause\n    });\n    this.req = options.req;\n    this.result = options.result;\n    this.message = this.toString();\n  }\n  toString() {\n    let str = super.toString();\n    if (this.cause) {\n      str += `\nCause: ${this.cause}`;\n    }\n    if (this.result) {\n      str += `\nReponse Received: ${JSON.stringify(this.result, null, 2)}`;\n    }\n    return str;\n  }\n};\nvar FaucetRateLimitError = class extends Error {};\n\n// src/rpc/client.ts\nvar JsonRpcClient = class {\n  constructor(url, httpHeaders) {\n    const transport = new HTTPTransport(url, {\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"Client-Sdk-Type\": \"typescript\",\n        \"Client-Sdk-Version\": PACKAGE_VERSION,\n        \"Client-Target-Api-Version\": TARGETED_RPC_VERSION,\n        ...httpHeaders\n      }\n    });\n    this.rpcClient = new Client(new RequestManager([transport]));\n  }\n  async requestWithType(method, args, struct) {\n    const req = {\n      method,\n      args\n    };\n    const response = await this.request(method, args);\n    if (false) {\n      const [err] = validate(response, struct);\n      if (err) {\n        throw new RPCValidationError2({\n          req,\n          result: response,\n          cause: err\n        });\n      }\n    }\n    return response;\n  }\n  async request(method, params) {\n    return await this.rpcClient.request({\n      method,\n      params\n    });\n  }\n};\n\n// src/types/dynamic_fields.ts\nimport { any as any4, array as array11, boolean as boolean11, literal as literal6, nullable as nullable12, number as number12, object as object13, string as string13, union as union6 } from \"superstruct\";\nvar DynamicFieldType = union6([literal6(\"DynamicField\"), literal6(\"DynamicObject\")]);\nvar DynamicFieldName = object13({\n  type: string13(),\n  value: any4()\n});\nvar DynamicFieldInfo = object13({\n  name: DynamicFieldName,\n  bcsName: string13(),\n  type: DynamicFieldType,\n  objectType: string13(),\n  objectId: ObjectId,\n  version: number12(),\n  digest: string13()\n});\nvar DynamicFieldPage = object13({\n  data: array11(DynamicFieldInfo),\n  nextCursor: nullable12(ObjectId),\n  hasNextPage: boolean11()\n});\n\n// src/rpc/websocket-client.ts\nimport { RequestManager as RequestManager2, Client as Client2, WebSocketTransport } from \"@open-rpc/client-js\";\nvar getWebsocketUrl = (httpUrl, port) => {\n  const url = new URL(httpUrl);\n  url.protocol = url.protocol.replace(\"http\", \"ws\");\n  if (port) {\n    url.port = port.toString();\n  }\n  return url.toString();\n};\nvar DEFAULT_CLIENT_OPTIONS = {\n  callTimeout: 3e4,\n  reconnectTimeout: 3e3,\n  maxReconnects: 5\n};\nvar _client, _subscriptions, _disconnects, _setupClient, setupClient_fn, _reconnect, reconnect_fn;\nvar WebsocketClient = class {\n  constructor(endpoint) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CLIENT_OPTIONS;\n    this.endpoint = endpoint;\n    this.options = options;\n    __privateAdd(this, _setupClient);\n    __privateAdd(this, _reconnect);\n    __privateAdd(this, _client, void 0);\n    __privateAdd(this, _subscriptions, void 0);\n    __privateAdd(this, _disconnects, void 0);\n    if (this.endpoint.startsWith(\"http\")) {\n      this.endpoint = getWebsocketUrl(this.endpoint);\n    }\n    __privateSet(this, _client, null);\n    __privateSet(this, _subscriptions, /* @__PURE__ */new Map());\n    __privateSet(this, _disconnects, 0);\n  }\n  async request(input) {\n    const client = __privateMethod(this, _setupClient, setupClient_fn).call(this);\n    const id = await client.request({\n      method: input.method,\n      params: input.params\n    }, this.options.callTimeout);\n    __privateGet(this, _subscriptions).set(input.id || id, {\n      ...input,\n      // Always set the latest actual subscription ID:\n      id\n    });\n    return async () => {\n      const client2 = __privateMethod(this, _setupClient, setupClient_fn).call(this);\n      const subscription = __privateGet(this, _subscriptions).get(id);\n      if (!subscription) return false;\n      __privateGet(this, _subscriptions).delete(id);\n      return client2.request({\n        method: input.unsubscribe,\n        params: [subscription.id]\n      }, this.options.callTimeout);\n    };\n  }\n};\n_client = new WeakMap();\n_subscriptions = new WeakMap();\n_disconnects = new WeakMap();\n_setupClient = new WeakSet();\nsetupClient_fn = function () {\n  if (__privateGet(this, _client)) {\n    return __privateGet(this, _client);\n  }\n  const transport = new WebSocketTransport(this.endpoint);\n  const requestManager = new RequestManager2([transport]);\n  __privateSet(this, _client, new Client2(requestManager));\n  transport.connection.addEventListener(\"open\", () => {\n    __privateSet(this, _disconnects, 0);\n  });\n  transport.connection.addEventListener(\"close\", () => {\n    __privateWrapper(this, _disconnects)._++;\n    if (__privateGet(this, _disconnects) <= this.options.maxReconnects) {\n      setTimeout(() => {\n        __privateMethod(this, _reconnect, reconnect_fn).call(this);\n      }, this.options.reconnectTimeout);\n    }\n  });\n  __privateGet(this, _client).onNotification(data => {\n    const params = data.params;\n    __privateGet(this, _subscriptions).forEach(subscription => {\n      if (subscription.method === data.method && params.subscription === subscription.id) {\n        subscription.onMessage(params.result);\n      }\n    });\n  });\n  return __privateGet(this, _client);\n};\n_reconnect = new WeakSet();\nreconnect_fn = function () {\n  __privateGet(this, _client)?.close();\n  __privateSet(this, _client, null);\n  __privateGet(this, _subscriptions).forEach(subscription => this.request(subscription));\n};\n\n// src/rpc/faucet-client.ts\nasync function requestSuiFromFaucet(endpoint, recipient, httpHeaders) {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    body: JSON.stringify({\n      FixedAmountRequest: {\n        recipient\n      }\n    }),\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...(httpHeaders || {})\n    }\n  });\n  if (res.status === 429) {\n    throw new FaucetRateLimitError(`Too many requests from this client have been sent to the faucet. Please retry later`);\n  }\n  let parsed;\n  try {\n    parsed = await res.json();\n  } catch (e) {\n    throw new Error(`Encountered error when parsing response from faucet, error: ${e}, status ${res.status}, response ${res}`);\n  }\n  if (parsed.error) {\n    throw new Error(`Faucet returns error: ${parsed.error}`);\n  }\n  return parsed;\n}\n\n// src/providers/json-rpc-provider.ts\nimport { any as any6, array as array15, string as string18, nullable as nullable14 } from \"superstruct\";\nimport { fromB58 as fromB582, toB64 as toB649, toHEX as toHEX2 } from \"@mysten/bcs\";\n\n// src/rpc/connection.ts\nvar _options;\nvar Connection = class {\n  constructor(options) {\n    __privateAdd(this, _options, void 0);\n    __privateSet(this, _options, options);\n  }\n  get fullnode() {\n    return __privateGet(this, _options).fullnode;\n  }\n  // TODO: Decide if we should default the websocket URL like this:\n  get websocket() {\n    return __privateGet(this, _options).websocket || __privateGet(this, _options).fullnode;\n  }\n  get faucet() {\n    return __privateGet(this, _options).faucet;\n  }\n};\n_options = new WeakMap();\nvar localnetConnection = new Connection({\n  fullnode: \"http://127.0.0.1:9000\",\n  faucet: \"http://127.0.0.1:9123/gas\"\n});\nvar devnetConnection = new Connection({\n  fullnode: \"https://fullnode.devnet.sui.io:443/\",\n  faucet: \"https://faucet.devnet.sui.io/gas\"\n});\nvar testnetConnection = new Connection({\n  fullnode: \"https://fullnode.testnet.sui.io:443/\",\n  faucet: \"https://faucet.testnet.sui.io/gas\"\n});\nvar mainnetConnection = new Connection({\n  fullnode: \"https://fullnode.mainnet.sui.io:443/\"\n});\n\n// src/builder/TransactionBlock.ts\nimport { fromB64 as fromB648 } from \"@mysten/bcs\";\nimport { is as is6, mask } from \"superstruct\";\n\n// src/builder/Transactions.ts\nimport { BCS as BCS2, fromB64 as fromB647 } from \"@mysten/bcs\";\nimport { is as is4, any as any5, array as array12, integer, literal as literal7, object as object14, optional as optional7, string as string14, union as union7, assert, define as define3, unknown, record as record5 } from \"superstruct\";\n\n// src/builder/utils.ts\nimport { create as superstructCreate } from \"superstruct\";\nfunction create(value, struct) {\n  return superstructCreate(value, struct);\n}\nvar TRANSACTION_TYPE = Symbol(\"transaction-argument-type\");\n\n// src/signers/txn-data-serializers/type-tag-serializer.ts\nvar VECTOR_REGEX = /^vector<(.+)>$/;\nvar STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\nvar TypeTagSerializer = class {\n  static parseFromStr(str) {\n    let normalizeAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (str === \"address\") {\n      return {\n        address: null\n      };\n    } else if (str === \"bool\") {\n      return {\n        bool: null\n      };\n    } else if (str === \"u8\") {\n      return {\n        u8: null\n      };\n    } else if (str === \"u16\") {\n      return {\n        u16: null\n      };\n    } else if (str === \"u32\") {\n      return {\n        u32: null\n      };\n    } else if (str === \"u64\") {\n      return {\n        u64: null\n      };\n    } else if (str === \"u128\") {\n      return {\n        u128: null\n      };\n    } else if (str === \"u256\") {\n      return {\n        u256: null\n      };\n    } else if (str === \"signer\") {\n      return {\n        signer: null\n      };\n    }\n    const vectorMatch = str.match(VECTOR_REGEX);\n    if (vectorMatch) {\n      return {\n        vector: TypeTagSerializer.parseFromStr(vectorMatch[1], normalizeAddress)\n      };\n    }\n    const structMatch = str.match(STRUCT_REGEX);\n    if (structMatch) {\n      const address = normalizeAddress ? normalizeSuiAddress(structMatch[1]) : structMatch[1];\n      return {\n        struct: {\n          address,\n          module: structMatch[2],\n          name: structMatch[3],\n          typeParams: structMatch[5] === void 0 ? [] : TypeTagSerializer.parseStructTypeArgs(structMatch[5], normalizeAddress)\n        }\n      };\n    }\n    throw new Error(`Encountered unexpected token when parsing type args for ${str}`);\n  }\n  static parseStructTypeArgs(str) {\n    let normalizeAddress = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const tok = [];\n    let word = \"\";\n    let nestedAngleBrackets = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str[i];\n      if (char === \"<\") {\n        nestedAngleBrackets++;\n      }\n      if (char === \">\") {\n        nestedAngleBrackets--;\n      }\n      if (nestedAngleBrackets === 0 && char === \",\") {\n        tok.push(word.trim());\n        word = \"\";\n        continue;\n      }\n      word += char;\n    }\n    tok.push(word.trim());\n    return tok.map(tok2 => TypeTagSerializer.parseFromStr(tok2, normalizeAddress));\n  }\n  static tagToString(tag) {\n    if (\"bool\" in tag) {\n      return \"bool\";\n    }\n    if (\"u8\" in tag) {\n      return \"u8\";\n    }\n    if (\"u16\" in tag) {\n      return \"u16\";\n    }\n    if (\"u32\" in tag) {\n      return \"u32\";\n    }\n    if (\"u64\" in tag) {\n      return \"u64\";\n    }\n    if (\"u128\" in tag) {\n      return \"u128\";\n    }\n    if (\"u256\" in tag) {\n      return \"u256\";\n    }\n    if (\"address\" in tag) {\n      return \"address\";\n    }\n    if (\"signer\" in tag) {\n      return \"signer\";\n    }\n    if (\"vector\" in tag) {\n      return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n    }\n    if (\"struct\" in tag) {\n      const struct = tag.struct;\n      const typeParams = struct.typeParams.map(TypeTagSerializer.tagToString).join(\", \");\n      return `${struct.address}::${struct.module}::${struct.name}${typeParams ? `<${typeParams}>` : \"\"}`;\n    }\n    throw new Error(\"Invalid TypeTag\");\n  }\n};\n\n// src/builder/Transactions.ts\nvar option = some => union7([object14({\n  None: union7([literal7(true), literal7(null)])\n}), object14({\n  Some: some\n})]);\nvar TransactionBlockInput = object14({\n  kind: literal7(\"Input\"),\n  index: integer(),\n  value: optional7(any5()),\n  type: optional7(union7([literal7(\"pure\"), literal7(\"object\")]))\n});\nvar TransactionArgumentTypes = [TransactionBlockInput, object14({\n  kind: literal7(\"GasCoin\")\n}), object14({\n  kind: literal7(\"Result\"),\n  index: integer()\n}), object14({\n  kind: literal7(\"NestedResult\"),\n  index: integer(),\n  resultIndex: integer()\n})];\nvar TransactionArgument = union7([...TransactionArgumentTypes]);\nvar ObjectTransactionArgument = union7([...TransactionArgumentTypes]);\nObjectTransactionArgument[TRANSACTION_TYPE] = {\n  kind: \"object\"\n};\nvar PureTransactionArgument = type => {\n  const struct = union7([...TransactionArgumentTypes]);\n  struct[TRANSACTION_TYPE] = {\n    kind: \"pure\",\n    type\n  };\n  return struct;\n};\nvar MoveCallTransaction = object14({\n  kind: literal7(\"MoveCall\"),\n  target: define3(\"target\", string14().validator),\n  typeArguments: array12(string14()),\n  arguments: array12(TransactionArgument)\n});\nvar TransferObjectsTransaction = object14({\n  kind: literal7(\"TransferObjects\"),\n  objects: array12(ObjectTransactionArgument),\n  address: PureTransactionArgument(BCS2.ADDRESS)\n});\nvar SplitCoinsTransaction = object14({\n  kind: literal7(\"SplitCoins\"),\n  coin: ObjectTransactionArgument,\n  amounts: array12(PureTransactionArgument(\"u64\"))\n});\nvar MergeCoinsTransaction = object14({\n  kind: literal7(\"MergeCoins\"),\n  destination: ObjectTransactionArgument,\n  sources: array12(ObjectTransactionArgument)\n});\nvar MakeMoveVecTransaction = object14({\n  kind: literal7(\"MakeMoveVec\"),\n  // TODO: ideally we should use `TypeTag` instead of `record()` here,\n  // but TypeTag is recursively defined and it's tricky to define a\n  // recursive struct in superstruct\n  type: optional7(option(record5(string14(), unknown()))),\n  objects: array12(ObjectTransactionArgument)\n});\nvar PublishTransaction = object14({\n  kind: literal7(\"Publish\"),\n  modules: array12(array12(integer())),\n  dependencies: array12(ObjectId)\n});\nvar UpgradePolicy = /* @__PURE__ */(UpgradePolicy2 => {\n  UpgradePolicy2[UpgradePolicy2[\"COMPATIBLE\"] = 0] = \"COMPATIBLE\";\n  UpgradePolicy2[UpgradePolicy2[\"ADDITIVE\"] = 128] = \"ADDITIVE\";\n  UpgradePolicy2[UpgradePolicy2[\"DEP_ONLY\"] = 192] = \"DEP_ONLY\";\n  return UpgradePolicy2;\n})(UpgradePolicy || {});\nvar UpgradeTransaction = object14({\n  kind: literal7(\"Upgrade\"),\n  modules: array12(array12(integer())),\n  dependencies: array12(ObjectId),\n  packageId: ObjectId,\n  ticket: ObjectTransactionArgument\n});\nvar TransactionTypes = [MoveCallTransaction, TransferObjectsTransaction, SplitCoinsTransaction, MergeCoinsTransaction, PublishTransaction, UpgradeTransaction, MakeMoveVecTransaction];\nvar TransactionType = union7([...TransactionTypes]);\nfunction getTransactionType(data) {\n  assert(data, TransactionType);\n  return TransactionTypes.find(schema => is4(data, schema));\n}\nvar Transactions = {\n  MoveCall(input) {\n    return create({\n      kind: \"MoveCall\",\n      target: input.target,\n      arguments: input.arguments ?? [],\n      typeArguments: input.typeArguments ?? []\n    }, MoveCallTransaction);\n  },\n  TransferObjects(objects, address) {\n    return create({\n      kind: \"TransferObjects\",\n      objects,\n      address\n    }, TransferObjectsTransaction);\n  },\n  SplitCoins(coin, amounts) {\n    return create({\n      kind: \"SplitCoins\",\n      coin,\n      amounts\n    }, SplitCoinsTransaction);\n  },\n  MergeCoins(destination, sources) {\n    return create({\n      kind: \"MergeCoins\",\n      destination,\n      sources\n    }, MergeCoinsTransaction);\n  },\n  Publish(_ref3) {\n    let {\n      modules,\n      dependencies\n    } = _ref3;\n    return create({\n      kind: \"Publish\",\n      modules: modules.map(module => typeof module === \"string\" ? Array.from(fromB647(module)) : module),\n      dependencies: dependencies.map(dep => normalizeSuiObjectId(dep))\n    }, PublishTransaction);\n  },\n  Upgrade(_ref4) {\n    let {\n      modules,\n      dependencies,\n      packageId,\n      ticket\n    } = _ref4;\n    return create({\n      kind: \"Upgrade\",\n      modules: modules.map(module => typeof module === \"string\" ? Array.from(fromB647(module)) : module),\n      dependencies: dependencies.map(dep => normalizeSuiObjectId(dep)),\n      packageId,\n      ticket\n    }, UpgradeTransaction);\n  },\n  MakeMoveVec(_ref5) {\n    let {\n      type,\n      objects\n    } = _ref5;\n    return create({\n      kind: \"MakeMoveVec\",\n      type: type ? {\n        Some: TypeTagSerializer.parseFromStr(type)\n      } : {\n        None: null\n      },\n      objects\n    }, MakeMoveVecTransaction);\n  }\n};\n\n// src/builder/Inputs.ts\nimport { array as array13, boolean as boolean12, integer as integer2, object as object15, string as string15, union as union8 } from \"superstruct\";\n\n// src/builder/bcs.ts\nimport { BCS as BCS3 } from \"@mysten/bcs\";\nvar ARGUMENT_INNER = \"Argument\";\nvar VECTOR2 = \"vector\";\nvar OPTION = \"Option\";\nvar CALL_ARG = \"CallArg\";\nvar TYPE_TAG = \"TypeTag\";\nvar OBJECT_ARG = \"ObjectArg\";\nvar PROGRAMMABLE_TX_BLOCK = \"ProgrammableTransaction\";\nvar PROGRAMMABLE_CALL_INNER = \"ProgrammableMoveCall\";\nvar TRANSACTION_INNER = \"Transaction\";\nvar COMPRESSED_SIGNATURE = \"CompressedSignature\";\nvar PUBLIC_KEY = \"PublicKey\";\nvar MULTISIG_PUBLIC_KEY = \"MultiSigPublicKey\";\nvar MULTISIG_PK_MAP = \"MultiSigPkMap\";\nvar MULTISIG = \"MultiSig\";\nvar ENUM_KIND = \"EnumKind\";\nvar TRANSACTION = [ENUM_KIND, TRANSACTION_INNER];\nvar ARGUMENT = [ENUM_KIND, ARGUMENT_INNER];\nvar PROGRAMMABLE_CALL = \"SimpleProgrammableMoveCall\";\nvar builder = new BCS3(bcs);\nregisterFixedArray(builder, \"FixedArray[64]\", 64);\nregisterFixedArray(builder, \"FixedArray[33]\", 33);\nregisterFixedArray(builder, \"FixedArray[32]\", 32);\nbuilder.registerStructType(PROGRAMMABLE_TX_BLOCK, {\n  inputs: [VECTOR2, CALL_ARG],\n  transactions: [VECTOR2, TRANSACTION]\n}).registerEnumType(ARGUMENT_INNER, {\n  GasCoin: null,\n  Input: {\n    index: BCS3.U16\n  },\n  Result: {\n    index: BCS3.U16\n  },\n  NestedResult: {\n    index: BCS3.U16,\n    resultIndex: BCS3.U16\n  }\n}).registerStructType(PROGRAMMABLE_CALL_INNER, {\n  package: BCS3.ADDRESS,\n  module: BCS3.STRING,\n  function: BCS3.STRING,\n  type_arguments: [VECTOR2, TYPE_TAG],\n  arguments: [VECTOR2, ARGUMENT]\n}).registerEnumType(TRANSACTION_INNER, {\n  /**\n   * A Move Call - any public Move function can be called via\n   * this transaction. The results can be used that instant to pass\n   * into the next transaction.\n   */\n  MoveCall: PROGRAMMABLE_CALL,\n  /**\n   * Transfer vector of objects to a receiver.\n   */\n  TransferObjects: {\n    objects: [VECTOR2, ARGUMENT],\n    address: ARGUMENT\n  },\n  /**\n   * Split `amount` from a `coin`.\n   */\n  SplitCoins: {\n    coin: ARGUMENT,\n    amounts: [VECTOR2, ARGUMENT]\n  },\n  /**\n   * Merge Vector of Coins (`sources`) into a `destination`.\n   */\n  MergeCoins: {\n    destination: ARGUMENT,\n    sources: [VECTOR2, ARGUMENT]\n  },\n  /**\n   * Publish a Move module.\n   */\n  Publish: {\n    modules: [VECTOR2, [VECTOR2, BCS3.U8]],\n    dependencies: [VECTOR2, BCS3.ADDRESS]\n  },\n  /**\n   * Build a vector of objects using the input arguments.\n   * It is impossible to construct a `vector<T: key>` otherwise,\n   * so this call serves a utility function.\n   */\n  MakeMoveVec: {\n    type: [OPTION, TYPE_TAG],\n    objects: [VECTOR2, ARGUMENT]\n  },\n  /**  */\n  Upgrade: {\n    modules: [VECTOR2, [VECTOR2, BCS3.U8]],\n    dependencies: [VECTOR2, BCS3.ADDRESS],\n    packageId: BCS3.ADDRESS,\n    ticket: ARGUMENT\n  }\n}).registerEnumType(COMPRESSED_SIGNATURE, {\n  ED25519: [\"FixedArray[64]\", \"u8\"],\n  Secp256k1: [\"FixedArray[64]\", \"u8\"],\n  Secp256r1: [\"FixedArray[64]\", \"u8\"]\n}).registerEnumType(PUBLIC_KEY, {\n  ED25519: [\"FixedArray[32]\", \"u8\"],\n  Secp256k1: [\"FixedArray[33]\", \"u8\"],\n  Secp256r1: [\"FixedArray[33]\", \"u8\"]\n}).registerStructType(MULTISIG_PK_MAP, {\n  pubKey: PUBLIC_KEY,\n  weight: BCS3.U8\n}).registerStructType(MULTISIG_PUBLIC_KEY, {\n  pk_map: [VECTOR2, MULTISIG_PK_MAP],\n  threshold: BCS3.U16\n}).registerStructType(MULTISIG, {\n  sigs: [VECTOR2, COMPRESSED_SIGNATURE],\n  bitmap: BCS3.U16,\n  multisig_pk: MULTISIG_PUBLIC_KEY\n});\nbuilder.registerType([ENUM_KIND, \"T\"], function encode(writer, data, typeParams, typeMap) {\n  const kind = data.kind;\n  const invariant = {\n    [kind]: data\n  };\n  const [enumType] = typeParams;\n  return this.getTypeInterface(enumType)._encodeRaw.call(this, writer, invariant, typeParams, typeMap);\n}, function decode(reader, typeParams, typeMap) {\n  const [enumType] = typeParams;\n  const data = this.getTypeInterface(enumType)._decodeRaw.call(this, reader, typeParams, typeMap);\n  const kind = Object.keys(data)[0];\n  return {\n    kind,\n    ...data[kind]\n  };\n}, data => {\n  if (typeof data !== \"object\" && !(\"kind\" in data)) {\n    throw new Error(`EnumKind: Missing property \"kind\" in the input ${JSON.stringify(data)}`);\n  }\n  return true;\n});\nbuilder.registerType(PROGRAMMABLE_CALL, function encodeProgrammableTx(writer, data, typeParams, typeMap) {\n  const [pkg, module, fun] = data.target.split(\"::\");\n  const type_arguments = data.typeArguments.map(tag => TypeTagSerializer.parseFromStr(tag, true));\n  return this.getTypeInterface(PROGRAMMABLE_CALL_INNER)._encodeRaw.call(this, writer, {\n    package: normalizeSuiAddress(pkg),\n    module,\n    function: fun,\n    type_arguments,\n    arguments: data.arguments\n  }, typeParams, typeMap);\n}, function decodeProgrammableTx(reader, typeParams, typeMap) {\n  let data = builder.getTypeInterface(PROGRAMMABLE_CALL_INNER)._decodeRaw.call(this, reader, typeParams, typeMap);\n  return {\n    target: [data.package, data.module, data.function].join(\"::\"),\n    arguments: data.arguments,\n    typeArguments: data.type_arguments.map(TypeTagSerializer.tagToString)\n  };\n},\n// Validation callback to error out if the data format is invalid.\n// TODO: make sure TypeTag can be parsed.\ndata => {\n  return data.target.split(\"::\").length === 3;\n});\nfunction registerFixedArray(bcs2, name, length) {\n  bcs2.registerType(name, function encode2(writer, data, typeParams, typeMap) {\n    if (data.length !== length) {\n      throw new Error(`Expected fixed array of length ${length}, got ${data.length}`);\n    }\n    if (typeParams.length !== 1) {\n      throw new Error(`Expected one type parameter in a fixed array, got ${typeParams.length}`);\n    }\n    let [type] = typeof typeParams[0] === \"string\" ? [typeParams[0], []] : typeParams[0];\n    for (let piece of data) {\n      this.getTypeInterface(type)._encodeRaw.call(this, writer, piece, typeParams, typeMap);\n    }\n    return writer;\n  }, function decode2(reader, typeParams, typeMap) {\n    if (typeParams.length !== 1) {\n      throw new Error(`Expected one type parameter in a fixed array, got ${typeParams.length}`);\n    }\n    let result = [];\n    let [type] = typeof typeParams[0] === \"string\" ? [typeParams[0], []] : typeParams[0];\n    for (let i = 0; i < length; i++) {\n      result.push(this.getTypeInterface(type)._decodeRaw.call(this, reader, typeParams, typeMap));\n    }\n    return result;\n  });\n}\n\n// src/builder/Inputs.ts\nvar ObjectArg = union8([object15({\n  ImmOrOwned: SuiObjectRef\n}), object15({\n  Shared: object15({\n    objectId: string15(),\n    initialSharedVersion: union8([integer2(), string15()]),\n    mutable: boolean12()\n  })\n})]);\nvar PureCallArg = object15({\n  Pure: array13(integer2())\n});\nvar ObjectCallArg = object15({\n  Object: ObjectArg\n});\nvar BuilderCallArg = union8([PureCallArg, ObjectCallArg]);\nvar Inputs = {\n  Pure(data, type) {\n    return {\n      Pure: Array.from(data instanceof Uint8Array ? data :\n      // NOTE: We explicitly set this to be growable to infinity, because we have maxSize validation at the builder-level:\n      builder.ser(type, data, {\n        maxSize: Infinity\n      }).toBytes())\n    };\n  },\n  ObjectRef(_ref6) {\n    let {\n      objectId,\n      digest,\n      version\n    } = _ref6;\n    return {\n      Object: {\n        ImmOrOwned: {\n          digest,\n          version,\n          objectId: normalizeSuiAddress(objectId)\n        }\n      }\n    };\n  },\n  SharedObjectRef(_ref7) {\n    let {\n      objectId,\n      mutable,\n      initialSharedVersion\n    } = _ref7;\n    return {\n      Object: {\n        Shared: {\n          mutable,\n          initialSharedVersion,\n          objectId: normalizeSuiAddress(objectId)\n        }\n      }\n    };\n  }\n};\nfunction getIdFromCallArg(arg) {\n  if (typeof arg === \"string\") {\n    return normalizeSuiAddress(arg);\n  }\n  if (\"ImmOrOwned\" in arg.Object) {\n    return normalizeSuiAddress(arg.Object.ImmOrOwned.objectId);\n  }\n  return normalizeSuiAddress(arg.Object.Shared.objectId);\n}\nfunction getSharedObjectInput(arg) {\n  return typeof arg === \"object\" && \"Object\" in arg && \"Shared\" in arg.Object ? arg.Object.Shared : void 0;\n}\nfunction isSharedObjectInput(arg) {\n  return !!getSharedObjectInput(arg);\n}\nfunction isMutableSharedObjectInput(arg) {\n  return getSharedObjectInput(arg)?.mutable ?? false;\n}\n\n// src/builder/serializer.ts\nvar STD_ASCII_MODULE_NAME = \"ascii\";\nvar STD_ASCII_STRUCT_NAME = \"String\";\nvar STD_UTF8_MODULE_NAME = \"string\";\nvar STD_UTF8_STRUCT_NAME = \"String\";\nvar STD_OPTION_MODULE_NAME = \"option\";\nvar STD_OPTION_STRUCT_NAME = \"Option\";\nvar RESOLVED_SUI_ID = {\n  address: SUI_FRAMEWORK_ADDRESS,\n  module: OBJECT_MODULE_NAME,\n  name: ID_STRUCT_NAME\n};\nvar RESOLVED_ASCII_STR = {\n  address: MOVE_STDLIB_ADDRESS,\n  module: STD_ASCII_MODULE_NAME,\n  name: STD_ASCII_STRUCT_NAME\n};\nvar RESOLVED_UTF8_STR = {\n  address: MOVE_STDLIB_ADDRESS,\n  module: STD_UTF8_MODULE_NAME,\n  name: STD_UTF8_STRUCT_NAME\n};\nvar RESOLVED_STD_OPTION = {\n  address: MOVE_STDLIB_ADDRESS,\n  module: STD_OPTION_MODULE_NAME,\n  name: STD_OPTION_STRUCT_NAME\n};\nvar isSameStruct = (a, b) => a.address === b.address && a.module === b.module && a.name === b.name;\nfunction isTxContext(param) {\n  const struct = extractStructTag(param)?.Struct;\n  return struct?.address === \"0x2\" && struct?.module === \"tx_context\" && struct?.name === \"TxContext\";\n}\nfunction expectType(typeName, argVal) {\n  if (typeof argVal === \"undefined\") {\n    return;\n  }\n  if (typeof argVal !== typeName) {\n    throw new Error(`Expect ${argVal} to be ${typeName}, received ${typeof argVal}`);\n  }\n}\nvar allowedTypes = [\"Address\", \"Bool\", \"U8\", \"U16\", \"U32\", \"U64\", \"U128\", \"U256\"];\nfunction getPureSerializationType(normalizedType, argVal) {\n  if (typeof normalizedType === \"string\" && allowedTypes.includes(normalizedType)) {\n    if (normalizedType in [\"U8\", \"U16\", \"U32\", \"U64\", \"U128\", \"U256\"]) {\n      expectType(\"number\", argVal);\n    } else if (normalizedType === \"Bool\") {\n      expectType(\"boolean\", argVal);\n    } else if (normalizedType === \"Address\") {\n      expectType(\"string\", argVal);\n      if (argVal && !isValidSuiAddress(argVal)) {\n        throw new Error(\"Invalid Sui Address\");\n      }\n    }\n    return normalizedType.toLowerCase();\n  } else if (typeof normalizedType === \"string\") {\n    throw new Error(`Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`);\n  }\n  if (\"Vector\" in normalizedType) {\n    if ((argVal === void 0 || typeof argVal === \"string\") && normalizedType.Vector === \"U8\") {\n      return \"string\";\n    }\n    if (argVal !== void 0 && !Array.isArray(argVal)) {\n      throw new Error(`Expect ${argVal} to be a array, received ${typeof argVal}`);\n    }\n    const innerType = getPureSerializationType(normalizedType.Vector,\n    // undefined when argVal is empty\n    argVal ? argVal[0] : void 0);\n    if (innerType === void 0) {\n      return;\n    }\n    return `vector<${innerType}>`;\n  }\n  if (\"Struct\" in normalizedType) {\n    if (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {\n      return \"string\";\n    } else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {\n      return \"utf8string\";\n    } else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {\n      return \"address\";\n    } else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {\n      const optionToVec = {\n        Vector: normalizedType.Struct.typeArguments[0]\n      };\n      return getPureSerializationType(optionToVec, argVal);\n    }\n  }\n  return void 0;\n}\n\n// src/builder/TransactionBlockData.ts\nimport { toB58 } from \"@mysten/bcs\";\nimport { array as array14, assert as assert2, define as define4, integer as integer3, is as is5, literal as literal8, nullable as nullable13, object as object16, optional as optional8, string as string16, union as union9 } from \"superstruct\";\n\n// src/cryptography/hash.ts\nimport { blake2b as blake2b7 } from \"@noble/hashes/blake2b\";\nfunction hashTypedData(typeTag, data) {\n  const typeTagBytes = Array.from(`${typeTag}::`).map(e => e.charCodeAt(0));\n  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n  dataWithTag.set(typeTagBytes);\n  dataWithTag.set(data, typeTagBytes.length);\n  return blake2b7(dataWithTag, {\n    dkLen: 32\n  });\n}\n\n// src/builder/TransactionBlockData.ts\nvar TransactionExpiration = optional8(nullable13(union9([object16({\n  Epoch: integer3()\n}), object16({\n  None: union9([literal8(true), literal8(null)])\n})])));\nvar SuiAddress3 = string16();\nvar StringEncodedBigint = define4(\"StringEncodedBigint\", val => {\n  if (![\"string\", \"number\", \"bigint\"].includes(typeof val)) return false;\n  try {\n    BigInt(val);\n    return true;\n  } catch {\n    return false;\n  }\n});\nvar GasConfig = object16({\n  budget: optional8(StringEncodedBigint),\n  price: optional8(StringEncodedBigint),\n  payment: optional8(array14(SuiObjectRef)),\n  owner: optional8(SuiAddress3)\n});\nvar SerializedTransactionDataBuilder = object16({\n  version: literal8(1),\n  sender: optional8(SuiAddress3),\n  expiration: TransactionExpiration,\n  gasConfig: GasConfig,\n  inputs: array14(TransactionBlockInput),\n  transactions: array14(TransactionType)\n});\nfunction prepareSuiAddress(address) {\n  return normalizeSuiAddress(address).replace(\"0x\", \"\");\n}\nvar TransactionBlockDataBuilder = class {\n  constructor(clone) {\n    this.version = 1;\n    this.sender = clone?.sender;\n    this.expiration = clone?.expiration;\n    this.gasConfig = clone?.gasConfig ?? {};\n    this.inputs = clone?.inputs ?? [];\n    this.transactions = clone?.transactions ?? [];\n  }\n  static fromKindBytes(bytes) {\n    const kind = builder.de(\"TransactionKind\", bytes);\n    const programmableTx = kind?.ProgrammableTransaction;\n    if (!programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    const serialized = create({\n      version: 1,\n      gasConfig: {},\n      inputs: programmableTx.inputs.map((value, index) => create({\n        kind: \"Input\",\n        value,\n        index,\n        type: is5(value, PureCallArg) ? \"pure\" : \"object\"\n      }, TransactionBlockInput)),\n      transactions: programmableTx.transactions\n    }, SerializedTransactionDataBuilder);\n    return TransactionBlockDataBuilder.restore(serialized);\n  }\n  static fromBytes(bytes) {\n    const rawData = builder.de(\"TransactionData\", bytes);\n    const data = rawData?.V1;\n    const programmableTx = data?.kind?.ProgrammableTransaction;\n    if (!data || !programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    const serialized = create({\n      version: 1,\n      sender: data.sender,\n      expiration: data.expiration,\n      gasConfig: data.gasData,\n      inputs: programmableTx.inputs.map((value, index) => create({\n        kind: \"Input\",\n        value,\n        index,\n        type: is5(value, PureCallArg) ? \"pure\" : \"object\"\n      }, TransactionBlockInput)),\n      transactions: programmableTx.transactions\n    }, SerializedTransactionDataBuilder);\n    return TransactionBlockDataBuilder.restore(serialized);\n  }\n  static restore(data) {\n    assert2(data, SerializedTransactionDataBuilder);\n    const transactionData = new TransactionBlockDataBuilder();\n    Object.assign(transactionData, data);\n    return transactionData;\n  }\n  /**\n   * Generate transaction digest.\n   *\n   * @param bytes BCS serialized transaction data\n   * @returns transaction digest.\n   */\n  static getDigestFromBytes(bytes) {\n    const hash = hashTypedData(\"TransactionData\", bytes);\n    return toB58(hash);\n  }\n  build() {\n    let {\n      maxSizeBytes = Infinity,\n      overrides,\n      onlyTransactionKind\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const inputs = this.inputs.map(input => {\n      assert2(input.value, BuilderCallArg);\n      return input.value;\n    });\n    const kind = {\n      ProgrammableTransaction: {\n        inputs,\n        transactions: this.transactions\n      }\n    };\n    if (onlyTransactionKind) {\n      return builder.ser(\"TransactionKind\", kind, {\n        maxSize: maxSizeBytes\n      }).toBytes();\n    }\n    const expiration = overrides?.expiration ?? this.expiration;\n    const sender = overrides?.sender ?? this.sender;\n    const gasConfig = {\n      ...this.gasConfig,\n      ...overrides?.gasConfig\n    };\n    if (!sender) {\n      throw new Error(\"Missing transaction sender\");\n    }\n    if (!gasConfig.budget) {\n      throw new Error(\"Missing gas budget\");\n    }\n    if (!gasConfig.payment) {\n      throw new Error(\"Missing gas payment\");\n    }\n    if (!gasConfig.price) {\n      throw new Error(\"Missing gas price\");\n    }\n    const transactionData = {\n      sender: prepareSuiAddress(sender),\n      expiration: expiration ? expiration : {\n        None: true\n      },\n      gasData: {\n        payment: gasConfig.payment,\n        owner: prepareSuiAddress(this.gasConfig.owner ?? sender),\n        price: BigInt(gasConfig.price),\n        budget: BigInt(gasConfig.budget)\n      },\n      kind: {\n        ProgrammableTransaction: {\n          inputs,\n          transactions: this.transactions\n        }\n      }\n    };\n    return builder.ser(\"TransactionData\", {\n      V1: transactionData\n    }, {\n      maxSize: maxSizeBytes\n    }).toBytes();\n  }\n  getDigest() {\n    const bytes = this.build({\n      onlyTransactionKind: false\n    });\n    return TransactionBlockDataBuilder.getDigestFromBytes(bytes);\n  }\n  snapshot() {\n    return create(this, SerializedTransactionDataBuilder);\n  }\n};\n\n// src/builder/TransactionBlock.ts\nvar DefaultOfflineLimits = {\n  maxPureArgumentSize: 16 * 1024,\n  maxTxGas: 5e10,\n  maxGasObjects: 256,\n  maxTxSizeBytes: 128 * 1024\n};\nfunction createTransactionResult(index) {\n  const baseResult = {\n    kind: \"Result\",\n    index\n  };\n  const nestedResults = [];\n  const nestedResultFor = resultIndex => nestedResults[resultIndex] ?? (nestedResults[resultIndex] = {\n    kind: \"NestedResult\",\n    index,\n    resultIndex\n  });\n  return new Proxy(baseResult, {\n    set() {\n      throw new Error(\"The transaction result is a proxy, and does not support setting properties directly\");\n    },\n    // TODO: Instead of making this return a concrete argument, we should ideally\n    // make it reference-based (so that this gets resolved at build-time), which\n    // allows re-ordering transactions.\n    get(target, property) {\n      if (property in target) {\n        return Reflect.get(target, property);\n      }\n      if (property === Symbol.iterator) {\n        return function* () {\n          let i = 0;\n          while (true) {\n            yield nestedResultFor(i);\n            i++;\n          }\n        };\n      }\n      if (typeof property === \"symbol\") return;\n      const resultIndex = parseInt(property, 10);\n      if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n      return nestedResultFor(resultIndex);\n    }\n  });\n}\nfunction expectProvider(options) {\n  if (!options.provider) {\n    throw new Error(`No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`);\n  }\n  return options.provider;\n}\nvar TRANSACTION_BRAND = Symbol.for(\"@mysten/transaction\");\nvar LIMITS = {\n  // The maximum gas that is allowed.\n  maxTxGas: \"max_tx_gas\",\n  // The maximum number of gas objects that can be selected for one transaction.\n  maxGasObjects: \"max_gas_payment_objects\",\n  // The maximum size (in bytes) that the transaction can be:\n  maxTxSizeBytes: \"max_tx_size_bytes\",\n  // The maximum size (in bytes) that pure arguments can be:\n  maxPureArgumentSize: \"max_pure_argument_size\"\n};\nvar GAS_SAFE_OVERHEAD = 1000n;\nvar MAX_OBJECTS_PER_FETCH = 50;\nvar chunk = (arr, size) => Array.from({\n  length: Math.ceil(arr.length / size)\n}, (_, i) => arr.slice(i * size, i * size + size));\nvar _blockData, _input, input_fn, _getConfig, getConfig_fn, _validate, validate_fn, _prepareGasPayment, prepareGasPayment_fn, _prepareGasPrice, prepareGasPrice_fn, _prepareTransactions, prepareTransactions_fn, _prepare, prepare_fn;\nvar _TransactionBlock = class {\n  constructor(transaction) {\n    /**\n     * Dynamically create a new input, which is separate from the `input`. This is important\n     * for generated clients to be able to define unique inputs that are non-overlapping with the\n     * defined inputs.\n     *\n     * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n     * is the format required for custom serialization.\n     *\n     */\n    __privateAdd(this, _input);\n    __privateAdd(this, _getConfig);\n    __privateAdd(this, _validate);\n    // The current default is just picking _all_ coins we can which may not be ideal.\n    __privateAdd(this, _prepareGasPayment);\n    __privateAdd(this, _prepareGasPrice);\n    __privateAdd(this, _prepareTransactions);\n    /**\n     * Prepare the transaction by valdiating the transaction data and resolving all inputs\n     * so that it can be built into bytes.\n     */\n    __privateAdd(this, _prepare);\n    __privateAdd(this, _blockData, void 0);\n    __privateSet(this, _blockData, new TransactionBlockDataBuilder(transaction ? transaction.blockData : void 0));\n  }\n  /** Returns `true` if the object is an instance of the Transaction builder class. */\n  static is(obj) {\n    return !!obj && typeof obj === \"object\" && obj[TRANSACTION_BRAND] === true;\n  }\n  /**\n   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n   * Supports either a byte array, or base64-encoded bytes.\n   */\n  static fromKind(serialized) {\n    const tx = new _TransactionBlock();\n    __privateSet(tx, _blockData, TransactionBlockDataBuilder.fromKindBytes(typeof serialized === \"string\" ? fromB648(serialized) : serialized));\n    return tx;\n  }\n  /**\n   * Converts from a serialized transaction format to a `Transaction` class.\n   * There are two supported serialized formats:\n   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n   * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n   */\n  static from(serialized) {\n    const tx = new _TransactionBlock();\n    if (typeof serialized !== \"string\" || !serialized.startsWith(\"{\")) {\n      __privateSet(tx, _blockData, TransactionBlockDataBuilder.fromBytes(typeof serialized === \"string\" ? fromB648(serialized) : serialized));\n    } else {\n      __privateSet(tx, _blockData, TransactionBlockDataBuilder.restore(JSON.parse(serialized)));\n    }\n    return tx;\n  }\n  /** A helper to retrieve the Transaction builder `Transactions` */\n  static get Transactions() {\n    return Transactions;\n  }\n  /** A helper to retrieve the Transaction builder `Inputs` */\n  static get Inputs() {\n    return Inputs;\n  }\n  setSender(sender) {\n    __privateGet(this, _blockData).sender = sender;\n  }\n  /**\n   * Sets the sender only if it has not already been set.\n   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n   */\n  setSenderIfNotSet(sender) {\n    if (!__privateGet(this, _blockData).sender) {\n      __privateGet(this, _blockData).sender = sender;\n    }\n  }\n  setExpiration(expiration) {\n    __privateGet(this, _blockData).expiration = expiration;\n  }\n  setGasPrice(price) {\n    __privateGet(this, _blockData).gasConfig.price = String(price);\n  }\n  setGasBudget(budget) {\n    __privateGet(this, _blockData).gasConfig.budget = String(budget);\n  }\n  setGasOwner(owner) {\n    __privateGet(this, _blockData).gasConfig.owner = owner;\n  }\n  setGasPayment(payments) {\n    __privateGet(this, _blockData).gasConfig.payment = payments.map(payment => mask(payment, SuiObjectRef));\n  }\n  /** Get a snapshot of the transaction data, in JSON form: */\n  get blockData() {\n    return __privateGet(this, _blockData).snapshot();\n  }\n  // Used to brand transaction classes so that they can be identified, even between multiple copies\n  // of the builder.\n  get [TRANSACTION_BRAND]() {\n    return true;\n  }\n  /** Returns an argument for the gas coin, to be used in a transaction. */\n  get gas() {\n    return {\n      kind: \"GasCoin\"\n    };\n  }\n  /**\n   * Add a new object input to the transaction.\n   */\n  object(value) {\n    const id = getIdFromCallArg(value);\n    const inserted = __privateGet(this, _blockData).inputs.find(i => i.type === \"object\" && id === getIdFromCallArg(i.value));\n    return inserted ?? __privateMethod(this, _input, input_fn).call(this, \"object\", value);\n  }\n  /**\n   * Add a new object input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  objectRef() {\n    return this.object(Inputs.ObjectRef(...arguments));\n  }\n  /**\n   * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  sharedObjectRef() {\n    return this.object(Inputs.SharedObjectRef(...arguments));\n  }\n  /**\n   * Add a new non-object input to the transaction.\n   */\n  pure(value, type) {\n    return __privateMethod(this, _input, input_fn).call(this, \"pure\", value instanceof Uint8Array ? Inputs.Pure(value) : type ? Inputs.Pure(value, type) : value);\n  }\n  /** Add a transaction to the transaction block. */\n  add(transaction) {\n    const index = __privateGet(this, _blockData).transactions.push(transaction);\n    return createTransactionResult(index - 1);\n  }\n  // Method shorthands:\n  splitCoins() {\n    return this.add(Transactions.SplitCoins(...arguments));\n  }\n  mergeCoins() {\n    return this.add(Transactions.MergeCoins(...arguments));\n  }\n  publish() {\n    return this.add(Transactions.Publish(...arguments));\n  }\n  upgrade() {\n    return this.add(Transactions.Upgrade(...arguments));\n  }\n  moveCall() {\n    return this.add(Transactions.MoveCall(...arguments));\n  }\n  transferObjects() {\n    return this.add(Transactions.TransferObjects(...arguments));\n  }\n  makeMoveVec() {\n    return this.add(Transactions.MakeMoveVec(...arguments));\n  }\n  /**\n   * Serialize the transaction to a string so that it can be sent to a separate context.\n   * This is different from `build` in that it does not serialize to BCS bytes, and instead\n   * uses a separate format that is unique to the transaction builder. This allows\n   * us to serialize partially-complete transactions, that can then be completed and\n   * built in a separate context.\n   *\n   * For example, a dapp can construct a transaction, but not provide gas objects\n   * or a gas budget. The transaction then can be sent to the wallet, where this\n   * information is automatically filled in (e.g. by querying for coin objects\n   * and performing a dry run).\n   */\n  serialize() {\n    return JSON.stringify(__privateGet(this, _blockData).snapshot());\n  }\n  /** Build the transaction to BCS bytes. */\n  async build() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await __privateMethod(this, _prepare, prepare_fn).call(this, options);\n    return __privateGet(this, _blockData).build({\n      maxSizeBytes: __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxSizeBytes\", options),\n      onlyTransactionKind: options.onlyTransactionKind\n    });\n  }\n  /** Derive transaction digest */\n  async getDigest() {\n    let {\n      provider\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    await __privateMethod(this, _prepare, prepare_fn).call(this, {\n      provider\n    });\n    return __privateGet(this, _blockData).getDigest();\n  }\n};\nvar TransactionBlock = _TransactionBlock;\n_blockData = new WeakMap();\n_input = new WeakSet();\ninput_fn = function (type, value) {\n  const index = __privateGet(this, _blockData).inputs.length;\n  const input = create({\n    kind: \"Input\",\n    // bigints can't be serialized to JSON, so just string-convert them here:\n    value: typeof value === \"bigint\" ? String(value) : value,\n    index,\n    type\n  }, TransactionBlockInput);\n  __privateGet(this, _blockData).inputs.push(input);\n  return input;\n};\n_getConfig = new WeakSet();\ngetConfig_fn = function (key, _ref8) {\n  let {\n    protocolConfig,\n    limits\n  } = _ref8;\n  if (limits && typeof limits[key] === \"number\") {\n    return limits[key];\n  }\n  if (!protocolConfig) {\n    return DefaultOfflineLimits[key];\n  }\n  const attribute = protocolConfig?.attributes[LIMITS[key]];\n  if (!attribute) {\n    throw new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n  }\n  const value = \"u64\" in attribute ? attribute.u64 : \"u32\" in attribute ? attribute.u32 : attribute.f64;\n  if (!value) {\n    throw new Error(`Unexpected protocol config value found for: \"${LIMITS[key]}\"`);\n  }\n  return Number(value);\n};\n_validate = new WeakSet();\nvalidate_fn = function (options) {\n  const maxPureArgumentSize = __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxPureArgumentSize\", options);\n  __privateGet(this, _blockData).inputs.forEach((input, index) => {\n    if (is6(input.value, PureCallArg)) {\n      if (input.value.Pure.length > maxPureArgumentSize) {\n        throw new Error(`Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`);\n      }\n    }\n  });\n};\n_prepareGasPayment = new WeakSet();\nprepareGasPayment_fn = async function (options) {\n  if (__privateGet(this, _blockData).gasConfig.payment) {\n    const maxGasObjects = __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxGasObjects\", options);\n    if (__privateGet(this, _blockData).gasConfig.payment.length > maxGasObjects) {\n      throw new Error(`Payment objects exceed maximum amount: ${maxGasObjects}`);\n    }\n  }\n  if (options.onlyTransactionKind || __privateGet(this, _blockData).gasConfig.payment) {\n    return;\n  }\n  const gasOwner = __privateGet(this, _blockData).gasConfig.owner ?? __privateGet(this, _blockData).sender;\n  const coins = await expectProvider(options).getCoins({\n    owner: gasOwner,\n    coinType: SUI_TYPE_ARG\n  });\n  const paymentCoins = coins.data.filter(coin => {\n    const matchingInput = __privateGet(this, _blockData).inputs.find(input => {\n      if (is6(input.value, BuilderCallArg) && \"Object\" in input.value && \"ImmOrOwned\" in input.value.Object) {\n        return coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n      }\n      return false;\n    });\n    return !matchingInput;\n  }).slice(0, __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxGasObjects\", options) - 1).map(coin => ({\n    objectId: coin.coinObjectId,\n    digest: coin.digest,\n    version: coin.version\n  }));\n  if (!paymentCoins.length) {\n    throw new Error(\"No valid gas coins found for the transaction.\");\n  }\n  this.setGasPayment(paymentCoins);\n};\n_prepareGasPrice = new WeakSet();\nprepareGasPrice_fn = async function (options) {\n  if (options.onlyTransactionKind || __privateGet(this, _blockData).gasConfig.price) {\n    return;\n  }\n  this.setGasPrice(await expectProvider(options).getReferenceGasPrice());\n};\n_prepareTransactions = new WeakSet();\nprepareTransactions_fn = async function (options) {\n  const {\n    inputs,\n    transactions\n  } = __privateGet(this, _blockData);\n  const moveModulesToResolve = [];\n  const objectsToResolve = [];\n  transactions.forEach(transaction => {\n    if (transaction.kind === \"MoveCall\") {\n      const needsResolution = transaction.arguments.some(arg => arg.kind === \"Input\" && !is6(inputs[arg.index].value, BuilderCallArg));\n      if (needsResolution) {\n        moveModulesToResolve.push(transaction);\n      }\n      return;\n    }\n    const transactionType = getTransactionType(transaction);\n    if (!transactionType.schema) return;\n    Object.entries(transaction).forEach(_ref9 => {\n      let [key, value] = _ref9;\n      if (key === \"kind\") return;\n      const keySchema = transactionType.schema[key];\n      const isArray = keySchema.type === \"array\";\n      const wellKnownEncoding = isArray ? keySchema.schema[TRANSACTION_TYPE] : keySchema[TRANSACTION_TYPE];\n      if (!wellKnownEncoding) return;\n      const encodeInput = index => {\n        const input = inputs[index];\n        if (!input) {\n          throw new Error(`Missing input ${value.index}`);\n        }\n        if (is6(input.value, BuilderCallArg)) return;\n        if (wellKnownEncoding.kind === \"object\" && typeof input.value === \"string\") {\n          objectsToResolve.push({\n            id: input.value,\n            input\n          });\n        } else if (wellKnownEncoding.kind === \"pure\") {\n          input.value = Inputs.Pure(input.value, wellKnownEncoding.type);\n        } else {\n          throw new Error(\"Unexpected input format.\");\n        }\n      };\n      if (isArray) {\n        value.forEach(arrayItem => {\n          if (arrayItem.kind !== \"Input\") return;\n          encodeInput(arrayItem.index);\n        });\n      } else {\n        if (value.kind !== \"Input\") return;\n        encodeInput(value.index);\n      }\n    });\n  });\n  if (moveModulesToResolve.length) {\n    await Promise.all(moveModulesToResolve.map(async moveCall => {\n      const [packageId, moduleName, functionName] = moveCall.target.split(\"::\");\n      const normalized = await expectProvider(options).getNormalizedMoveFunction({\n        package: normalizeSuiObjectId(packageId),\n        module: moduleName,\n        function: functionName\n      });\n      const hasTxContext = normalized.parameters.length > 0 && isTxContext(normalized.parameters.at(-1));\n      const params = hasTxContext ? normalized.parameters.slice(0, normalized.parameters.length - 1) : normalized.parameters;\n      if (params.length !== moveCall.arguments.length) {\n        throw new Error(\"Incorrect number of arguments.\");\n      }\n      params.forEach((param, i) => {\n        const arg = moveCall.arguments[i];\n        if (arg.kind !== \"Input\") return;\n        const input = inputs[arg.index];\n        if (is6(input.value, BuilderCallArg)) return;\n        const inputValue = input.value;\n        const serType = getPureSerializationType(param, inputValue);\n        if (serType) {\n          input.value = Inputs.Pure(inputValue, serType);\n          return;\n        }\n        const structVal = extractStructTag(param);\n        if (structVal != null || typeof param === \"object\" && \"TypeParameter\" in param) {\n          if (typeof inputValue !== \"string\") {\n            throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(inputValue, null, 2)}`);\n          }\n          objectsToResolve.push({\n            id: inputValue,\n            input,\n            normalizedType: param\n          });\n          return;\n        }\n        throw new Error(`Unknown call arg type ${JSON.stringify(param, null, 2)} for value ${JSON.stringify(inputValue, null, 2)}`);\n      });\n    }));\n  }\n  if (objectsToResolve.length) {\n    const dedupedIds = [...new Set(objectsToResolve.map(_ref10 => {\n      let {\n        id\n      } = _ref10;\n      return id;\n    }))];\n    const objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n    const objects = (await Promise.all(objectChunks.map(chunk2 => expectProvider(options).multiGetObjects({\n      ids: chunk2,\n      options: {\n        showOwner: true\n      }\n    })))).flat();\n    let objectsById = new Map(dedupedIds.map((id, index) => {\n      return [id, objects[index]];\n    }));\n    const invalidObjects = Array.from(objectsById).filter(_ref11 => {\n      let [_, obj] = _ref11;\n      return obj.error;\n    }).map(_ref12 => {\n      let [id, _] = _ref12;\n      return id;\n    });\n    if (invalidObjects.length) {\n      throw new Error(`The following input objects are not invalid: ${invalidObjects.join(\", \")}`);\n    }\n    objectsToResolve.forEach(_ref13 => {\n      let {\n        id,\n        input,\n        normalizedType\n      } = _ref13;\n      const object18 = objectsById.get(id);\n      const initialSharedVersion = getSharedObjectInitialVersion(object18);\n      if (initialSharedVersion) {\n        const mutable = isMutableSharedObjectInput(input.value) || normalizedType != null && extractMutableReference(normalizedType) != null;\n        input.value = Inputs.SharedObjectRef({\n          objectId: id,\n          initialSharedVersion,\n          mutable\n        });\n      } else {\n        input.value = Inputs.ObjectRef(getObjectReference(object18));\n      }\n    });\n  }\n};\n_prepare = new WeakSet();\nprepare_fn = async function (options) {\n  if (!options.onlyTransactionKind && !__privateGet(this, _blockData).sender) {\n    throw new Error(\"Missing transaction sender\");\n  }\n  if (!options.protocolConfig && !options.limits && options.provider) {\n    options.protocolConfig = await options.provider.getProtocolConfig();\n  }\n  await Promise.all([__privateMethod(this, _prepareGasPrice, prepareGasPrice_fn).call(this, options), __privateMethod(this, _prepareTransactions, prepareTransactions_fn).call(this, options)]);\n  if (!options.onlyTransactionKind) {\n    await __privateMethod(this, _prepareGasPayment, prepareGasPayment_fn).call(this, options);\n    if (!__privateGet(this, _blockData).gasConfig.budget) {\n      const dryRunResult = await expectProvider(options).dryRunTransactionBlock({\n        transactionBlock: __privateGet(this, _blockData).build({\n          maxSizeBytes: __privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxSizeBytes\", options),\n          overrides: {\n            gasConfig: {\n              budget: String(__privateMethod(this, _getConfig, getConfig_fn).call(this, \"maxTxGas\", options)),\n              payment: []\n            }\n          }\n        })\n      });\n      if (dryRunResult.effects.status.status !== \"success\") {\n        throw new Error(`Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`, {\n          cause: dryRunResult\n        });\n      }\n      const safeOverhead = GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n      const baseComputationCostWithOverhead = BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n      const gasBudget = baseComputationCostWithOverhead + BigInt(dryRunResult.effects.gasUsed.storageCost) - BigInt(dryRunResult.effects.gasUsed.storageRebate);\n      this.setGasBudget(gasBudget > baseComputationCostWithOverhead ? gasBudget : baseComputationCostWithOverhead);\n    }\n  }\n  __privateMethod(this, _validate, validate_fn).call(this, options);\n};\n\n// src/types/metrics.ts\nimport { number as number13, object as object17, string as string17 } from \"superstruct\";\nvar NetworkMetrics = object17({\n  currentTps: number13(),\n  tps30Days: number13(),\n  currentCheckpoint: string17(),\n  currentEpoch: string17(),\n  totalAddresses: string17(),\n  totalObjects: string17(),\n  totalPackages: string17()\n});\nvar AddressMetrics = object17({\n  checkpoint: number13(),\n  epoch: number13(),\n  timestampMs: number13(),\n  cumulativeAddresses: number13(),\n  cumulativeActiveAddresses: number13(),\n  dailyActiveAddresses: number13()\n});\n\n// src/providers/json-rpc-provider.ts\nvar DEFAULT_OPTIONS = {\n  socketOptions: DEFAULT_CLIENT_OPTIONS,\n  versionCacheTimeoutInSeconds: 600\n};\nvar JsonRpcProvider = class {\n  /**\n   * Establish a connection to a Sui RPC endpoint\n   *\n   * @param connection The `Connection` object containing configuration for the network.\n   * @param options configuration options for the provider\n   */\n  constructor() {\n    let connection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : devnetConnection;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_OPTIONS;\n    this.options = options;\n    this.connection = connection;\n    const opts = {\n      ...DEFAULT_OPTIONS,\n      ...options\n    };\n    this.options = opts;\n    this.client = opts.rpcClient ?? new JsonRpcClient(this.connection.fullnode);\n    this.wsClient = opts.websocketClient ?? new WebsocketClient(this.connection.websocket, opts.socketOptions);\n  }\n  async getRpcApiVersion() {\n    if (this.rpcApiVersion && this.cacheExpiry && this.cacheExpiry <= Date.now()) {\n      return this.rpcApiVersion;\n    }\n    try {\n      const resp = await this.client.requestWithType(\"rpc.discover\", [], any6());\n      this.rpcApiVersion = resp.info.version;\n      this.cacheExpiry =\n      // Date.now() is in milliseconds, but the timeout is in seconds\n      Date.now() + (this.options.versionCacheTimeoutInSeconds ?? 0) * 1e3;\n      return this.rpcApiVersion;\n    } catch (err) {\n      console.warn(\"Error fetching version number of the RPC API\", err);\n    }\n    return void 0;\n  }\n  async requestSuiFromFaucet(recipient, httpHeaders) {\n    if (!this.connection.faucet) {\n      throw new Error(\"Faucet URL is not specified\");\n    }\n    return requestSuiFromFaucet(this.connection.faucet, recipient, httpHeaders);\n  }\n  /**\n   * Get all Coin<`coin_type`> objects owned by an address.\n   */\n  async getCoins(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getCoins\", [input.owner, input.coinType, input.cursor, input.limit], PaginatedCoins);\n  }\n  /**\n   * Get all Coin objects owned by an address.\n   */\n  async getAllCoins(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getAllCoins\", [input.owner, input.cursor, input.limit], PaginatedCoins);\n  }\n  /**\n   * Get the total coin balance for one coin type, owned by the address owner.\n   */\n  async getBalance(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getBalance\", [input.owner, input.coinType], CoinBalance);\n  }\n  /**\n   * Get the total coin balance for all coin types, owned by the address owner.\n   */\n  async getAllBalances(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getAllBalances\", [input.owner], array15(CoinBalance));\n  }\n  /**\n   * Fetch CoinMetadata for a given coin type\n   */\n  async getCoinMetadata(input) {\n    return await this.client.requestWithType(\"suix_getCoinMetadata\", [input.coinType], CoinMetadataStruct);\n  }\n  /**\n   *  Fetch total supply for a coin\n   */\n  async getTotalSupply(input) {\n    return await this.client.requestWithType(\"suix_getTotalSupply\", [input.coinType], CoinSupply);\n  }\n  /**\n   * Invoke any RPC method\n   * @param method the method to be invoked\n   * @param args the arguments to be passed to the RPC request\n   */\n  async call(method, params) {\n    return await this.client.request(method, params);\n  }\n  /**\n   * Get Move function argument types like read, write and full access\n   */\n  async getMoveFunctionArgTypes(input) {\n    return await this.client.requestWithType(\"sui_getMoveFunctionArgTypes\", [input.package, input.module, input.function], SuiMoveFunctionArgTypes);\n  }\n  /**\n   * Get a map from module name to\n   * structured representations of Move modules\n   */\n  async getNormalizedMoveModulesByPackage(input) {\n    return await this.client.requestWithType(\"sui_getNormalizedMoveModulesByPackage\", [input.package], SuiMoveNormalizedModules);\n  }\n  /**\n   * Get a structured representation of Move module\n   */\n  async getNormalizedMoveModule(input) {\n    return await this.client.requestWithType(\"sui_getNormalizedMoveModule\", [input.package, input.module], SuiMoveNormalizedModule);\n  }\n  /**\n   * Get a structured representation of Move function\n   */\n  async getNormalizedMoveFunction(input) {\n    return await this.client.requestWithType(\"sui_getNormalizedMoveFunction\", [input.package, input.module, input.function], SuiMoveNormalizedFunction);\n  }\n  /**\n   * Get a structured representation of Move struct\n   */\n  async getNormalizedMoveStruct(input) {\n    return await this.client.requestWithType(\"sui_getNormalizedMoveStruct\", [input.package, input.module, input.struct], SuiMoveNormalizedStruct);\n  }\n  /**\n   * Get all objects owned by an address\n   */\n  async getOwnedObjects(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getOwnedObjects\", [input.owner, {\n      filter: input.filter,\n      options: input.options\n    }, input.cursor, input.limit], PaginatedObjectsResponse);\n  }\n  /**\n   * Get details about an object\n   */\n  async getObject(input) {\n    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {\n      throw new Error(\"Invalid Sui Object id\");\n    }\n    return await this.client.requestWithType(\"sui_getObject\", [input.id, input.options], SuiObjectResponse);\n  }\n  async tryGetPastObject(input) {\n    return await this.client.requestWithType(\"sui_tryGetPastObject\", [input.id, input.version, input.options], ObjectRead);\n  }\n  /**\n   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail\n   */\n  async multiGetObjects(input) {\n    input.ids.forEach(id => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(`Invalid Sui Object id ${id}`);\n      }\n    });\n    const hasDuplicates = input.ids.length !== new Set(input.ids).size;\n    if (hasDuplicates) {\n      throw new Error(`Duplicate object ids in batch call ${input.ids}`);\n    }\n    return await this.client.requestWithType(\"sui_multiGetObjects\", [input.ids, input.options], array15(SuiObjectResponse));\n  }\n  /**\n   * Get transaction blocks for a given query criteria\n   */\n  async queryTransactionBlocks(input) {\n    return await this.client.requestWithType(\"suix_queryTransactionBlocks\", [{\n      filter: input.filter,\n      options: input.options\n    }, input.cursor, input.limit, (input.order || \"descending\") === \"descending\"], PaginatedTransactionResponse);\n  }\n  async getTransactionBlock(input) {\n    if (!isValidTransactionDigest(input.digest)) {\n      throw new Error(\"Invalid Transaction digest\");\n    }\n    return await this.client.requestWithType(\"sui_getTransactionBlock\", [input.digest, input.options], SuiTransactionBlockResponse);\n  }\n  async multiGetTransactionBlocks(input) {\n    input.digests.forEach(d => {\n      if (!isValidTransactionDigest(d)) {\n        throw new Error(`Invalid Transaction digest ${d}`);\n      }\n    });\n    const hasDuplicates = input.digests.length !== new Set(input.digests).size;\n    if (hasDuplicates) {\n      throw new Error(`Duplicate digests in batch call ${input.digests}`);\n    }\n    return await this.client.requestWithType(\"sui_multiGetTransactionBlocks\", [input.digests, input.options], array15(SuiTransactionBlockResponse));\n  }\n  async executeTransactionBlock(input) {\n    return await this.client.requestWithType(\"sui_executeTransactionBlock\", [typeof input.transactionBlock === \"string\" ? input.transactionBlock : toB649(input.transactionBlock), Array.isArray(input.signature) ? input.signature : [input.signature], input.options, input.requestType], SuiTransactionBlockResponse);\n  }\n  /**\n   * Get total number of transactions\n   */\n  async getTotalTransactionBlocks() {\n    const resp = await this.client.requestWithType(\"sui_getTotalTransactionBlocks\", [], string18());\n    return BigInt(resp);\n  }\n  /**\n   * Getting the reference gas price for the network\n   */\n  async getReferenceGasPrice() {\n    const resp = await this.client.requestWithType(\"suix_getReferenceGasPrice\", [], string18());\n    return BigInt(resp);\n  }\n  /**\n   * Return the delegated stakes for an address\n   */\n  async getStakes(input) {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error(\"Invalid Sui address\");\n    }\n    return await this.client.requestWithType(\"suix_getStakes\", [input.owner], array15(DelegatedStake));\n  }\n  /**\n   * Return the delegated stakes queried by id.\n   */\n  async getStakesByIds(input) {\n    input.stakedSuiIds.forEach(id => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(`Invalid Sui Stake id ${id}`);\n      }\n    });\n    return await this.client.requestWithType(\"suix_getStakesByIds\", [input.stakedSuiIds], array15(DelegatedStake));\n  }\n  /**\n   * Return the latest system state content.\n   */\n  async getLatestSuiSystemState() {\n    return await this.client.requestWithType(\"suix_getLatestSuiSystemState\", [], SuiSystemStateSummary);\n  }\n  /**\n   * Get events for a given query criteria\n   */\n  async queryEvents(input) {\n    return await this.client.requestWithType(\"suix_queryEvents\", [input.query, input.cursor, input.limit, (input.order || \"descending\") === \"descending\"], PaginatedEvents);\n  }\n  /**\n   * Subscribe to get notifications whenever an event matching the filter occurs\n   */\n  async subscribeEvent(input) {\n    return this.wsClient.request({\n      method: \"suix_subscribeEvent\",\n      unsubscribe: \"suix_unsubscribeEvent\",\n      params: [input.filter],\n      onMessage: input.onMessage\n    });\n  }\n  async subscribeTransaction(input) {\n    return this.wsClient.request({\n      method: \"suix_subscribeTransaction\",\n      unsubscribe: \"suix_unsubscribeTransaction\",\n      params: [input.filter],\n      onMessage: input.onMessage\n    });\n  }\n  /**\n   * Runs the transaction block in dev-inspect mode. Which allows for nearly any\n   * transaction (or Move call) with any arguments. Detailed results are\n   * provided, including both the transaction effects and any return values.\n   */\n  async devInspectTransactionBlock(input) {\n    let devInspectTxBytes;\n    if (TransactionBlock.is(input.transactionBlock)) {\n      input.transactionBlock.setSenderIfNotSet(input.sender);\n      devInspectTxBytes = toB649(await input.transactionBlock.build({\n        provider: this,\n        onlyTransactionKind: true\n      }));\n    } else if (typeof input.transactionBlock === \"string\") {\n      devInspectTxBytes = input.transactionBlock;\n    } else if (input.transactionBlock instanceof Uint8Array) {\n      devInspectTxBytes = toB649(input.transactionBlock);\n    } else {\n      throw new Error(\"Unknown transaction block format.\");\n    }\n    return await this.client.requestWithType(\"sui_devInspectTransactionBlock\", [input.sender, devInspectTxBytes, input.gasPrice, input.epoch], DevInspectResults);\n  }\n  /**\n   * Dry run a transaction block and return the result.\n   */\n  async dryRunTransactionBlock(input) {\n    return await this.client.requestWithType(\"sui_dryRunTransactionBlock\", [typeof input.transactionBlock === \"string\" ? input.transactionBlock : toB649(input.transactionBlock)], DryRunTransactionBlockResponse);\n  }\n  /**\n   * Return the list of dynamic field objects owned by an object\n   */\n  async getDynamicFields(input) {\n    if (!input.parentId || !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))) {\n      throw new Error(\"Invalid Sui Object id\");\n    }\n    return await this.client.requestWithType(\"suix_getDynamicFields\", [input.parentId, input.cursor, input.limit], DynamicFieldPage);\n  }\n  /**\n   * Return the dynamic field object information for a specified object\n   */\n  async getDynamicFieldObject(input) {\n    return await this.client.requestWithType(\"suix_getDynamicFieldObject\", [input.parentId, input.name], SuiObjectResponse);\n  }\n  /**\n   * Get the sequence number of the latest checkpoint that has been executed\n   */\n  async getLatestCheckpointSequenceNumber() {\n    const resp = await this.client.requestWithType(\"sui_getLatestCheckpointSequenceNumber\", [], string18());\n    return String(resp);\n  }\n  /**\n   * Returns information about a given checkpoint\n   */\n  async getCheckpoint(input) {\n    return await this.client.requestWithType(\"sui_getCheckpoint\", [input.id], Checkpoint);\n  }\n  /**\n   * Returns historical checkpoints paginated\n   */\n  async getCheckpoints(input) {\n    const resp = await this.client.requestWithType(\"sui_getCheckpoints\", [input.cursor, input?.limit, input.descendingOrder], CheckpointPage);\n    return resp;\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCommitteeInfo(input) {\n    return await this.client.requestWithType(\"suix_getCommitteeInfo\", [input?.epoch], CommitteeInfo);\n  }\n  async getNetworkMetrics() {\n    return await this.client.requestWithType(\"suix_getNetworkMetrics\", [], NetworkMetrics);\n  }\n  async getAddressMetrics() {\n    return await this.client.requestWithType(\"suix_getLatestAddressMetrics\", [], AddressMetrics);\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getEpochs(input) {\n    return await this.client.requestWithType(\"suix_getEpochs\", [input?.cursor, input?.limit, input?.descendingOrder], EpochPage);\n  }\n  /**\n   * Returns list of top move calls by usage\n   */\n  async getMoveCallMetrics() {\n    return await this.client.requestWithType(\"suix_getMoveCallMetrics\", [], MoveCallMetrics);\n  }\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCurrentEpoch() {\n    return await this.client.requestWithType(\"suix_getCurrentEpoch\", [], EpochInfo);\n  }\n  /**\n   * Return the Validators APYs\n   */\n  async getValidatorsApy() {\n    return await this.client.requestWithType(\"suix_getValidatorsApy\", [], ValidatorsApy);\n  }\n  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.\n  async getChainIdentifier() {\n    const checkpoint = await this.getCheckpoint({\n      id: \"0\"\n    });\n    const bytes = fromB582(checkpoint.digest);\n    return toHEX2(bytes.slice(0, 4));\n  }\n  async resolveNameServiceAddress(input) {\n    return await this.client.requestWithType(\"suix_resolveNameServiceAddress\", [input.name], nullable14(SuiAddress));\n  }\n  async resolveNameServiceNames(input) {\n    return await this.client.requestWithType(\"suix_resolveNameServiceNames\", [input.address], ResolvedNameServiceNames);\n  }\n  async getProtocolConfig(input) {\n    return await this.client.requestWithType(\"sui_getProtocolConfig\", [input?.version], ProtocolConfig);\n  }\n  /**\n   * Wait for a transaction block result to be available over the API.\n   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to\n   * be available via the API.\n   * This currently polls the `getTransactionBlock` API to check for the transaction.\n   */\n  async waitForTransactionBlock(_ref14) {\n    let {\n      signal,\n      timeout = 60 * 1e3,\n      pollInterval = 2 * 1e3,\n      ...input\n    } = _ref14;\n    const timeoutSignal = AbortSignal.timeout(timeout);\n    const timeoutPromise = new Promise((_, reject) => {\n      timeoutSignal.addEventListener(\"abort\", () => reject(timeoutSignal.reason));\n    });\n    while (!timeoutSignal.aborted) {\n      signal?.throwIfAborted();\n      try {\n        return await this.getTransactionBlock(input);\n      } catch (e) {\n        await Promise.race([new Promise(resolve => setTimeout(resolve, pollInterval)), timeoutPromise]);\n      }\n    }\n    timeoutSignal.throwIfAborted();\n    throw new Error(\"Unexpected error while waiting for transaction block.\");\n  }\n};\n\n// src/signers/raw-signer.ts\nimport { blake2b as blake2b8 } from \"@noble/hashes/blake2b\";\n\n// src/signers/signer-with-provider.ts\nimport { fromB64 as fromB649, toB64 as toB6410 } from \"@mysten/bcs\";\n\n// src/utils/intent.ts\nvar AppId = /* @__PURE__ */(AppId2 => {\n  AppId2[AppId2[\"Sui\"] = 0] = \"Sui\";\n  return AppId2;\n})(AppId || {});\nvar IntentVersion = /* @__PURE__ */(IntentVersion2 => {\n  IntentVersion2[IntentVersion2[\"V0\"] = 0] = \"V0\";\n  return IntentVersion2;\n})(IntentVersion || {});\nvar IntentScope = /* @__PURE__ */(IntentScope3 => {\n  IntentScope3[IntentScope3[\"TransactionData\"] = 0] = \"TransactionData\";\n  IntentScope3[IntentScope3[\"TransactionEffects\"] = 1] = \"TransactionEffects\";\n  IntentScope3[IntentScope3[\"CheckpointSummary\"] = 2] = \"CheckpointSummary\";\n  IntentScope3[IntentScope3[\"PersonalMessage\"] = 3] = \"PersonalMessage\";\n  return IntentScope3;\n})(IntentScope || {});\nfunction intentWithScope(scope) {\n  return [scope, 0 /* V0 */, 0 /* Sui */];\n}\n\nfunction messageWithIntent(scope, message) {\n  const intent = intentWithScope(scope);\n  const intentMessage = new Uint8Array(intent.length + message.length);\n  intentMessage.set(intent);\n  intentMessage.set(message, intent.length);\n  return intentMessage;\n}\n\n// src/signers/signer-with-provider.ts\nvar SignerWithProvider = class {\n  ///////////////////\n  // Sub-classes MAY override these\n  /**\n   * Request gas tokens from a faucet server and send to the signer\n   * address\n   * @param httpHeaders optional request headers\n   */\n  async requestSuiFromFaucet(httpHeaders) {\n    return this.provider.requestSuiFromFaucet(await this.getAddress(), httpHeaders);\n  }\n  constructor(provider) {\n    this.provider = provider;\n  }\n  /**\n   * Sign a message using the keypair, with the `PersonalMessage` intent.\n   */\n  async signMessage(input) {\n    const signature = await this.signData(messageWithIntent(3 /* PersonalMessage */, input.message));\n    return {\n      messageBytes: toB6410(input.message),\n      signature\n    };\n  }\n  async prepareTransactionBlock(transactionBlock) {\n    if (TransactionBlock.is(transactionBlock)) {\n      transactionBlock.setSenderIfNotSet(await this.getAddress());\n      return await transactionBlock.build({\n        provider: this.provider\n      });\n    }\n    if (transactionBlock instanceof Uint8Array) {\n      return transactionBlock;\n    }\n    throw new Error(\"Unknown transaction format\");\n  }\n  /**\n   * Sign a transaction.\n   */\n  async signTransactionBlock(input) {\n    const transactionBlockBytes = await this.prepareTransactionBlock(input.transactionBlock);\n    const intentMessage = messageWithIntent(0 /* TransactionData */, transactionBlockBytes);\n    const signature = await this.signData(intentMessage);\n    return {\n      transactionBlockBytes: toB6410(transactionBlockBytes),\n      signature\n    };\n  }\n  /**\n   * Sign a transaction block and submit to the Fullnode for execution.\n   *\n   * @param options specify which fields to return (e.g., transaction, effects, events, etc).\n   * By default, only the transaction digest will be returned.\n   * @param requestType WaitForEffectsCert or WaitForLocalExecution, see details in `ExecuteTransactionRequestType`.\n   * Defaults to `WaitForLocalExecution` if options.show_effects or options.show_events is true\n   */\n  async signAndExecuteTransactionBlock(input) {\n    const {\n      transactionBlockBytes,\n      signature\n    } = await this.signTransactionBlock({\n      transactionBlock: input.transactionBlock\n    });\n    return await this.provider.executeTransactionBlock({\n      transactionBlock: transactionBlockBytes,\n      signature,\n      options: input.options,\n      requestType: input.requestType\n    });\n  }\n  /**\n   * Derive transaction digest from\n   * @param tx BCS serialized transaction data or a `Transaction` object\n   * @returns transaction digest\n   */\n  async getTransactionBlockDigest(tx) {\n    if (TransactionBlock.is(tx)) {\n      tx.setSenderIfNotSet(await this.getAddress());\n      return tx.getDigest({\n        provider: this.provider\n      });\n    } else if (tx instanceof Uint8Array) {\n      return TransactionBlockDataBuilder.getDigestFromBytes(tx);\n    } else {\n      throw new Error(\"Unknown transaction format.\");\n    }\n  }\n  /**\n   * Runs the transaction in dev-inpsect mode. Which allows for nearly any\n   * transaction (or Move call) with any arguments. Detailed results are\n   * provided, including both the transaction effects and any return values.\n   */\n  async devInspectTransactionBlock(input) {\n    const address = await this.getAddress();\n    return this.provider.devInspectTransactionBlock({\n      sender: address,\n      ...input\n    });\n  }\n  /**\n   * Dry run a transaction and return the result.\n   */\n  async dryRunTransactionBlock(input) {\n    let dryRunTxBytes;\n    if (TransactionBlock.is(input.transactionBlock)) {\n      input.transactionBlock.setSenderIfNotSet(await this.getAddress());\n      dryRunTxBytes = await input.transactionBlock.build({\n        provider: this.provider\n      });\n    } else if (typeof input.transactionBlock === \"string\") {\n      dryRunTxBytes = fromB649(input.transactionBlock);\n    } else if (input.transactionBlock instanceof Uint8Array) {\n      dryRunTxBytes = input.transactionBlock;\n    } else {\n      throw new Error(\"Unknown transaction format\");\n    }\n    return this.provider.dryRunTransactionBlock({\n      transactionBlock: dryRunTxBytes\n    });\n  }\n  /**\n   * Returns the estimated gas cost for the transaction\n   * @param tx The transaction to estimate the gas cost. When string it is assumed it's a serialized tx in base64\n   * @returns total gas cost estimation\n   * @throws whens fails to estimate the gas cost\n   */\n  async getGasCostEstimation() {\n    const txEffects = await this.dryRunTransactionBlock(...arguments);\n    const gasEstimation = getTotalGasUsedUpperBound(txEffects.effects);\n    if (typeof gasEstimation === \"undefined\") {\n      throw new Error(\"Failed to estimate the gas cost from transaction\");\n    }\n    return gasEstimation;\n  }\n};\n\n// src/signers/raw-signer.ts\nvar RawSigner = class extends SignerWithProvider {\n  constructor(keypair, provider) {\n    super(provider);\n    this.keypair = keypair;\n  }\n  async getAddress() {\n    return this.keypair.getPublicKey().toSuiAddress();\n  }\n  async signData(data) {\n    const pubkey = this.keypair.getPublicKey();\n    const digest = blake2b8(data, {\n      dkLen: 32\n    });\n    const signature = this.keypair.signData(digest);\n    const signatureScheme = this.keypair.getKeyScheme();\n    return toSerializedSignature({\n      signatureScheme,\n      signature,\n      pubKey: pubkey\n    });\n  }\n  connect(provider) {\n    return new RawSigner(this.keypair, provider);\n  }\n};\n\n// src/utils/format.ts\nvar ELLIPSIS = \"\\u2026\";\nfunction formatAddress(address) {\n  if (address.length <= 6) {\n    return address;\n  }\n  const offset = address.startsWith(\"0x\") ? 2 : 0;\n  return `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(-4)}`;\n}\nfunction formatDigest(digest) {\n  return `${digest.slice(0, 10)}${ELLIPSIS}`;\n}\n\n// src/utils/verify.ts\nimport { fromB64 as fromB6410 } from \"@mysten/bcs\";\nimport nacl3 from \"tweetnacl\";\nimport { secp256k1 as secp256k12 } from \"@noble/curves/secp256k1\";\nimport { sha256 as sha2563 } from \"@noble/hashes/sha256\";\nimport { blake2b as blake2b9 } from \"@noble/hashes/blake2b\";\nasync function verifyMessage(message, serializedSignature, scope) {\n  const signature = fromSerializedSignature(serializedSignature);\n  const messageBytes = messageWithIntent(scope, typeof message === \"string\" ? fromB6410(message) : message);\n  const digest = blake2b9(messageBytes, {\n    dkLen: 32\n  });\n  switch (signature.signatureScheme) {\n    case \"ED25519\":\n      return nacl3.sign.detached.verify(digest, signature.signature, signature.pubKey.toBytes());\n    case \"Secp256k1\":\n      return secp256k12.verify(secp256k12.Signature.fromCompact(signature.signature), sha2563(digest), signature.pubKey.toBytes());\n    default:\n      throw new Error(`Unknown signature scheme: \"${signature.signatureScheme}\"`);\n  }\n}\n\n// src/framework/sui-system-state.ts\nvar SUI_SYSTEM_STATE_OBJECT_ID = normalizeSuiObjectId(\"0x5\");\nvar SUI_SYSTEM_MODULE_NAME = \"sui_system\";\nvar ADD_STAKE_FUN_NAME = \"request_add_stake\";\nvar ADD_STAKE_LOCKED_COIN_FUN_NAME = \"request_add_stake_with_locked_coin\";\nvar WITHDRAW_STAKE_FUN_NAME = \"request_withdraw_stake\";\nvar SuiSystemStateUtil = class {\n  /**\n   * Create a new transaction for staking coins ready to be signed and executed with `signer-and-provider`.\n   *\n   * @param coins the coins to be staked\n   * @param amount the amount to stake\n   * @param gasBudget omittable only for DevInspect mode\n   */\n  static async newRequestAddStakeTxn(provider, coins, amount, validatorAddress) {\n    const tx = new TransactionBlock();\n    const coin = tx.splitCoins(tx.gas, [tx.pure(amount)]);\n    tx.moveCall({\n      target: `${SUI_SYSTEM_ADDRESS}::${SUI_SYSTEM_MODULE_NAME}::${ADD_STAKE_FUN_NAME}`,\n      arguments: [tx.object(SUI_SYSTEM_STATE_OBJECT_ID), coin, tx.pure(validatorAddress)]\n    });\n    const coinObjects = await provider.multiGetObjects({\n      ids: coins,\n      options: {\n        showOwner: true\n      }\n    });\n    tx.setGasPayment(coinObjects.map(obj => getObjectReference(obj)));\n    return tx;\n  }\n  /**\n   * Create a new transaction for withdrawing coins ready to be signed and\n   * executed with `signer-and-provider`.\n   *\n   * @param stake the stake object created in the requestAddStake txn\n   * @param stakedCoinId the coins to withdraw\n   * @param gasBudget omittable only for DevInspect mode\n   */\n  static async newRequestWithdrawlStakeTxn(stake, stakedCoinId) {\n    const tx = new TransactionBlock();\n    tx.moveCall({\n      target: `${SUI_SYSTEM_ADDRESS}::${SUI_SYSTEM_MODULE_NAME}::${WITHDRAW_STAKE_FUN_NAME}`,\n      arguments: [tx.object(SUI_SYSTEM_STATE_OBJECT_ID), tx.object(stake), tx.object(stakedCoinId)]\n    });\n    return tx;\n  }\n};\n\n// src/index.ts\nimport { fromB64 as fromB646, toB64 as toB6411 } from \"@mysten/bcs\";\nimport { is as is7, assert as assert3 } from \"superstruct\";\nexport { ADD_STAKE_FUN_NAME, ADD_STAKE_LOCKED_COIN_FUN_NAME, ARGUMENT, ARGUMENT_INNER, AppId, Apy, AuthorityName, AuthorityQuorumSignInfo, AuthoritySignature, Balance, BalanceChange, BuilderCallArg, CALL_ARG, COIN_TYPE_ARG_REGEX, COMPRESSED_SIGNATURE, Checkpoint, CheckpointDigest, CheckpointedObjectId, Coin, CoinBalance, CoinMetadataStruct, CoinStruct, CoinSupply, CommitteeInfo, Connection, Contents, ContentsFields, ContentsFieldsWithdraw, DEFAULT_CLIENT_OPTIONS, DEFAULT_ED25519_DERIVATION_PATH, DEFAULT_SECP256K1_DERIVATION_PATH, DEFAULT_SECP256R1_DERIVATION_PATH, DelegatedStake, Delegation, DelegationStakingPool, DelegationStakingPoolFields, DevInspectResults, DisplayFieldsBackwardCompatibleResponse, DisplayFieldsResponse, DryRunTransactionBlockResponse, ENUM_KIND, Ed25519Keypair, Ed25519PublicKey, EndOfEpochInfo, EpochId, EpochInfo, EpochPage, EventId, ExecutionStatus, ExecutionStatusType, FaucetCoinInfo, FaucetRateLimitError, FaucetResponse, GasCostSummary2 as GasCostSummary, GenericAuthoritySignature, Genesis, GetOwnedObjectsResponse, ID_STRUCT_NAME, Inputs, IntentScope, IntentVersion, JsonRpcClient, JsonRpcProvider, LEGACY_PRIVATE_KEY_SIZE, MAX_SIGNER_IN_MULTISIG, MIST_PER_SUI, MOVE_STDLIB_ADDRESS, MULTISIG, MULTISIG_PK_MAP, MULTISIG_PUBLIC_KEY, MakeMoveVecTransaction, MergeCoinsTransaction, MoveCallMetric, MoveCallMetrics, MoveCallSuiTransaction, MoveCallTransaction, MovePackageContent, OBJECT_ARG, OBJECT_MODULE_NAME, OPTION, ObjectCallArg, ObjectContentFields, ObjectDigest, ObjectId, ObjectOwner, ObjectRead, ObjectStatus, ObjectTransactionArgument, ObjectType, OwnedObjectRef, PAY_JOIN_COIN_FUNC_NAME, PAY_MODULE_NAME, PAY_SPLIT_COIN_VEC_FUNC_NAME, PRIVATE_KEY_SIZE, PROGRAMMABLE_CALL, PROGRAMMABLE_CALL_INNER, PROGRAMMABLE_TX_BLOCK, PUBLIC_KEY, PaginatedCoins, PaginatedEvents, PaginatedObjectsResponse, PaginatedTransactionResponse, ProgrammableTransaction, ProtocolConfig, PublishTransaction, PureCallArg, PureTransactionArgument, RPCValidationError, RawSigner, ResolvedNameServiceNames, SIGNATURE_FLAG_TO_SCHEME, SIGNATURE_SCHEME_TO_FLAG, SUI_ADDRESS_LENGTH, SUI_CLOCK_OBJECT_ID, SUI_DECIMALS, SUI_FRAMEWORK_ADDRESS, SUI_SYSTEM_ADDRESS, SUI_SYSTEM_MODULE_NAME, SUI_SYSTEM_STATE_OBJECT_ID, SUI_TYPE_ARG, Secp256k1Keypair, Secp256k1PublicKey, Secp256r1Keypair, Secp256r1PublicKey, SequenceNumber, SignerWithProvider, SplitCoinsTransaction, StakeObject, StakeSubsidy, StakeSubsidyFields, SubscriptionId, SuiAddress, SuiArgument, SuiCallArg, SuiChangeEpoch, SuiConsensusCommitPrologue, SuiEvent, SuiGasData, SuiJsonValue, SuiMoveAbilitySet, SuiMoveFunctionArgType, SuiMoveFunctionArgTypes, SuiMoveModuleId, SuiMoveNormalizedField, SuiMoveNormalizedFunction, SuiMoveNormalizedModule, SuiMoveNormalizedModules, SuiMoveNormalizedStruct, SuiMoveNormalizedStructType, SuiMoveNormalizedType, SuiMoveNormalizedTypeParameterType, SuiMoveObject, SuiMovePackage, SuiMoveStructTypeParameter, SuiMoveVisibility, SuiObjectChange, SuiObjectChangeCreated, SuiObjectChangeDeleted, SuiObjectChangeMutated, SuiObjectChangePublished, SuiObjectChangeTransferred, SuiObjectChangeWrapped, SuiObjectData, SuiObjectDataOptions, SuiObjectInfo, SuiObjectRef, SuiObjectResponse, SuiObjectResponseError, SuiParsedData, SuiRawData, SuiRawMoveObject, SuiRawMovePackage, SuiSupplyFields, SuiSystemStateSummary, SuiSystemStateUtil, SuiTransaction, SuiTransactionBlock, SuiTransactionBlockData, SuiTransactionBlockKind, SuiTransactionBlockResponse, SuiTransactionBlockResponseOptions, SuiValidatorSummary, TRANSACTION, TRANSACTION_INNER, TYPE_TAG, TransactionArgument, TransactionBlock, TransactionBlockInput, TransactionDigest, TransactionEffects, TransactionEffectsDigest, TransactionEffectsModifiedAtVersions, TransactionEventDigest, TransactionEvents, TransactionType, Transactions, TransferObjectsTransaction, TypeTagSerializer, UID_STRUCT_NAME, UpgradePolicy, UpgradeTransaction, VALIDATORS_EVENTS_QUERY, VECTOR2 as VECTOR, Validators, ValidatorsApy, WITHDRAW_STAKE_FUN_NAME, WebsocketClient, assert3 as assert, bcs, builder, bytesEqual, combinePartialSigs, decodeMultiSig, devnetConnection, extractMutableReference, extractReference, extractStructTag, formatAddress, formatDigest, fromB646 as fromB64, fromExportedKeypair, fromSerializedSignature, getChangeEpochTransaction, getConsensusCommitPrologueTransaction, getCreatedObjects, getEventPackage, getEventSender, getEvents, getExecutionStatus, getExecutionStatusError, getExecutionStatusGasSummary, getExecutionStatusType, getGasData, getIdFromCallArg, getMoveObject, getMoveObjectType, getMovePackageContent, getNewlyCreatedCoinRefsAfterSplit, getObjectChanges, getObjectDeletedResponse, getObjectDisplay, getObjectFields, getObjectId, getObjectNotExistsResponse, getObjectOwner, getObjectPreviousTransactionDigest, getObjectReference, getObjectType, getObjectVersion, getProgrammableTransaction, getPublishedObjectChanges, getPureSerializationType, getSharedObjectInitialVersion, getSharedObjectInput, getSuiObjectData, getTimestampFromTransactionResponse, getTotalGasUsed, getTotalGasUsedUpperBound, getTransaction, getTransactionDigest, getTransactionEffects, getTransactionGasBudget, getTransactionGasObject, getTransactionGasPrice, getTransactionKind, getTransactionKindName, getTransactionSender, getTransactionSignature, getTransactionType, getWebsocketUrl, hasPublicTransfer, is7 as is, isImmutableObject, isMutableSharedObjectInput, isObjectDataFull, isPureArg, isSharedObject, isSharedObjectInput, isSuiObjectResponse, isTxContext, isValidBIP32Path, isValidHardenedPath, isValidSuiAddress, isValidSuiObjectId, isValidTransactionDigest, localnetConnection, mainnetConnection, messageWithIntent, mnemonicToSeed, mnemonicToSeedHex, normalizeStructTag, normalizeSuiAddress, normalizeSuiObjectId, parseStructTag, publicKeyFromSerialized, requestSuiFromFaucet, testnetConnection, toB6411 as toB64, toMultiSigAddress, toSerializedSignature, verifyMessage };","map":{"version":3,"names":["nacl2","fromB64","fromB645","sha256","fromB644","toB64","toB644","blake2b","blake2b3","bytesToHex","bytesToHex3","boolean","define","literal","nullable","number","object","record","string","union","fromB58","TransactionDigest","TransactionEffectsDigest","TransactionEventDigest","ObjectId","SuiAddress","SequenceNumber","ObjectOwner","AddressOwner","Shared","initial_shared_version","SuiJsonValue","ProtocolConfigValue","u32","u64","f64","ProtocolConfig","attributes","featureFlags","maxSupportedProtocolVersion","minSupportedProtocolVersion","protocolVersion","TX_DIGEST_LENGTH","isValidTransactionDigest","value","buffer","length","e","SUI_ADDRESS_LENGTH","isValidSuiAddress","isHex","getHexByteLength","isValidSuiObjectId","parseTypeTag","type","includes","parseStructTag","address","module","split","rest","slice","name","indexOf","typeParams","lastIndexOf","map","typeParam","trim","normalizeSuiAddress","normalizeStructTag","formattedTypeParams","join","forceAdd0x","arguments","undefined","toLowerCase","startsWith","padStart","normalizeSuiObjectId","test","any","array","assign","boolean2","literal2","number2","object2","optional","record2","string2","union2","is","nullable2","tuple","ObjectType","SuiObjectRef","digest","objectId","version","SuiGasData","payment","owner","price","budget","SuiObjectInfo","previousTransaction","ObjectContentFields","MovePackageContent","SuiMoveObject","fields","hasPublicTransfer","SuiMovePackage","disassembled","SuiParsedData","dataType","SuiRawMoveObject","bcsBytes","SuiRawMovePackage","id","moduleMap","SuiRawData","SUI_DECIMALS","MIST_PER_SUI","BigInt","ObjectDigest","SuiObjectResponseError","code","error","object_id","parent_object_id","DisplayFieldsResponse","data","DisplayFieldsBackwardCompatibleResponse","SuiObjectData","content","bcs","storageRebate","display","SuiObjectDataOptions","showType","showContent","showBcs","showOwner","showPreviousTransaction","showStorageRebate","showDisplay","ObjectStatus","GetOwnedObjectsResponse","SuiObjectResponse","getSuiObjectData","resp","getObjectDeletedResponse","getObjectNotExistsResponse","getObjectReference","reference","exists","getObjectId","getObjectVersion","isSuiObjectResponse","getObjectType","getMoveObjectType","getObjectPreviousTransactionDigest","getObjectOwner","getObjectDisplay","getSharedObjectInitialVersion","isSharedObject","isImmutableObject","getMoveObject","getObjectFields","isSuiObjectDataWithContent","suiObject","getMovePackageContent","CheckpointedObjectId","atCheckpoint","PaginatedObjectsResponse","nextCursor","hasNextPage","ObjectRead","details","status","asked_version","latest_version","object3","string3","array2","record3","any2","optional2","boolean3","nullable3","EventId","txDigest","eventSeq","SuiEvent","packageId","transactionModule","sender","parsedJson","timestampMs","PaginatedEvents","getEventSender","event","getEventPackage","is2","array3","literal3","number3","object4","optional3","string4","union3","boolean4","tuple2","assign2","nullable4","EpochId","SuiChangeEpoch","epoch","storage_charge","computation_charge","storage_rebate","epoch_start_timestamp_ms","SuiConsensusCommitPrologue","round","commit_timestamp_ms","Genesis","objects","SuiArgument","Input","Result","NestedResult","MoveCallSuiTransaction","type_arguments","package","function","SuiTransaction","MoveCall","TransferObjects","SplitCoins","MergeCoins","Publish","Upgrade","MakeMoveVec","SuiCallArg","valueType","objectType","initialSharedVersion","mutable","ProgrammableTransaction","transactions","inputs","SuiTransactionBlockKind","kind","SuiTransactionBlockData","messageVersion","transaction","gasData","AuthoritySignature","GenericAuthoritySignature","AuthorityQuorumSignInfo","signature","signers_map","GasCostSummary","computationCost","storageCost","nonRefundableStorageFee","ExecutionStatusType","ExecutionStatus","OwnedObjectRef","TransactionEffectsModifiedAtVersions","sequenceNumber","TransactionEffects","executedEpoch","modifiedAtVersions","gasUsed","sharedObjects","transactionDigest","created","mutated","unwrapped","deleted","unwrappedThenDeleted","wrapped","gasObject","eventsDigest","dependencies","TransactionEvents","ReturnValueType","MutableReferenceOutputType","ExecutionResultType","mutableReferenceOutputs","returnValues","DevInspectResults","effects","events","results","AuthorityName","SuiTransactionBlock","txSignatures","SuiObjectChangePublished","modules","SuiObjectChangeTransferred","recipient","SuiObjectChangeMutated","previousVersion","SuiObjectChangeDeleted","SuiObjectChangeWrapped","SuiObjectChangeCreated","SuiObjectChange","BalanceChange","coinType","amount","SuiTransactionBlockResponse","checkpoint","confirmedLocalExecution","objectChanges","balanceChanges","errors","SuiTransactionBlockResponseOptions","showInput","showEffects","showEvents","showObjectChanges","showBalanceChanges","PaginatedTransactionResponse","DryRunTransactionBlockResponse","input","getTransaction","tx","getTransactionDigest","getTransactionSignature","getTransactionSender","getGasData","getTransactionGasObject","getTransactionGasPrice","getTransactionGasBudget","getChangeEpochTransaction","getConsensusCommitPrologueTransaction","getTransactionKind","getTransactionKindName","getProgrammableTransaction","getExecutionStatusType","getExecutionStatus","getTransactionEffects","getExecutionStatusError","getExecutionStatusGasSummary","getTotalGasUsed","gasSummary","getTotalGasUsedUpperBound","getEvents","getCreatedObjects","getTimestampFromTransactionResponse","getNewlyCreatedCoinRefsAfterSplit","c","getObjectChanges","getPublishedObjectChanges","filter","a","getOption","option2","nullable5","number4","object5","string5","SUI_SYSTEM_ADDRESS","SUI_FRAMEWORK_ADDRESS","MOVE_STDLIB_ADDRESS","OBJECT_MODULE_NAME","UID_STRUCT_NAME","ID_STRUCT_NAME","SUI_TYPE_ARG","VALIDATORS_EVENTS_QUERY","SUI_CLOCK_OBJECT_ID","PAY_MODULE_NAME","PAY_SPLIT_COIN_VEC_FUNC_NAME","PAY_JOIN_COIN_FUNC_NAME","COIN_TYPE_ARG_REGEX","isObjectDataFull","CoinMetadataStruct","decimals","symbol","description","iconUrl","Coin","isCoin","getType","match","getCoinType","res","getCoinTypeArg","obj","isSUI","arg","getCoinSymbol","coinTypeArg","substring","getCoinStructTag","getID","totalBalance","coins","reduce","partialSum","getBalanceFromCoinStruct","sortByBalance","sort","b","coin","balance","getBalance","_Delegation","isDelegationSuiObject","SUI_OBJECT_TYPE","constructor","nextRewardUnclaimedEpoch","next_reward_unclaimed_epoch","activeDelegation","active_delegation","delegateAmount","delegate_amount","endingEpoch","ending_epoch","validatorAddress","validator_address","isActive","hasUnclaimedRewards","Delegation","BCS","getSuiMoveConfig","isPureArg","Pure","VECTOR","TransactionDataV1","ADDRESS","expiration","BCS_SPEC","enums","None","Some","ObjectArg","ImmOrOwned","CallArg","U8","Object","ObjVec","TypeTag","bool","u8","u128","signer","vector","struct","u16","u256","TransactionKind","ChangeEpoch","ConsensusCommitPrologue","TransactionExpiration","Epoch","U64","TransactionData","V1","structs","SharedObjectRef","BOOL","StructTag","STRING","GasData","SenderSignedData","aliases","BASE58","types","registerType","writer","str","bytes","Array","from","TextEncoder","encode","writeVec","writer2","el","write8","reader","readVec","reader2","read8","TextDecoder","decode","Uint8Array","array4","nullable6","number5","object6","string6","FaucetCoinInfo","transferTxDigest","FaucetResponse","transferredGasObjects","array5","object7","string7","union4","boolean5","define2","number6","literal4","record4","is3","tuple3","SuiMoveFunctionArgType","SuiMoveFunctionArgTypes","SuiMoveModuleId","SuiMoveVisibility","SuiMoveAbilitySet","abilities","SuiMoveStructTypeParameter","constraints","isPhantom","SuiMoveNormalizedTypeParameterType","TypeParameter","MoveCallMetric","MoveCallMetrics","rank3Days","rank7Days","rank30Days","isSuiMoveNormalizedType","isSuiMoveNormalizedStructType","valueProperties","Reference","SuiMoveNormalizedType","MutableReference","Vector","Struct","structProperties","isArray","typeArguments","every","value2","SuiMoveNormalizedStructType","SuiMoveNormalizedFunction","visibility","isEntry","typeParameters","parameters","return","SuiMoveNormalizedField","SuiMoveNormalizedStruct","SuiMoveNormalizedModule","fileFormatVersion","friends","exposedFunctions","SuiMoveNormalizedModules","extractMutableReference","normalizedType","extractReference","extractStructTag","ref","mutRef","array6","boolean6","literal5","number7","object8","string8","union5","nullable7","tuple4","optional4","Apy","apy","ValidatorsApy","apys","Balance","StakeObject","stakedSuiId","stakeRequestEpoch","stakeActiveEpoch","principal","estimatedReward","DelegatedStake","stakingPool","stakes","StakeSubsidyFields","distribution_counter","current_distribution_amount","stake_subsidy_period_length","stake_subsidy_decrease_rate","StakeSubsidy","SuiSupplyFields","ContentsFields","size","head","vec","tail","ContentsFieldsWithdraw","Contents","DelegationStakingPoolFields","exchangeRates","pendingStake","pendingPoolTokenWithdraw","pendingTotalSuiWithdraw","poolTokenBalance","rewardsPool","activationEpoch","deactivationEpoch","suiBalance","DelegationStakingPool","Validators","CommitteeInfo","validators","SuiValidatorSummary","suiAddress","protocolPubkeyBytes","networkPubkeyBytes","workerPubkeyBytes","proofOfPossessionBytes","operationCapId","imageUrl","projectUrl","p2pAddress","netAddress","primaryAddress","workerAddress","nextEpochProtocolPubkeyBytes","nextEpochProofOfPossession","nextEpochNetworkPubkeyBytes","nextEpochWorkerPubkeyBytes","nextEpochNetAddress","nextEpochP2pAddress","nextEpochPrimaryAddress","nextEpochWorkerAddress","votingPower","gasPrice","commissionRate","nextEpochStake","nextEpochGasPrice","nextEpochCommissionRate","stakingPoolId","stakingPoolActivationEpoch","stakingPoolDeactivationEpoch","stakingPoolSuiBalance","exchangeRatesId","exchangeRatesSize","SuiSystemStateSummary","systemStateVersion","storageFundTotalObjectStorageRebates","storageFundNonRefundableBalance","referenceGasPrice","safeMode","safeModeStorageRewards","safeModeComputationRewards","safeModeStorageRebates","safeModeNonRefundableStorageFee","epochStartTimestampMs","epochDurationMs","stakeSubsidyStartEpoch","maxValidatorCount","minValidatorJoiningStake","validatorLowStakeThreshold","validatorVeryLowStakeThreshold","validatorLowStakeGracePeriod","stakeSubsidyBalance","stakeSubsidyDistributionCounter","stakeSubsidyCurrentDistributionAmount","stakeSubsidyPeriodLength","stakeSubsidyDecreaseRate","totalStake","activeValidators","pendingActiveValidatorsId","pendingActiveValidatorsSize","pendingRemovals","stakingPoolMappingsId","stakingPoolMappingsSize","inactivePoolsId","inactivePoolsSize","validatorCandidatesId","validatorCandidatesSize","atRiskValidators","validatorReportRecords","array7","boolean7","nullable8","number8","object9","optional5","string9","CoinStruct","coinObjectId","lockedUntilEpoch","PaginatedCoins","CoinBalance","coinObjectCount","lockedBalance","epochId","CoinSupply","array8","boolean8","nullable9","number9","object10","string10","EndOfEpochInfo","lastCheckpointId","epochEndTimestamp","storageFundReinvestment","storageCharge","storageFundBalance","stakeSubsidyAmount","totalGasFees","totalStakeRewardsDistributed","leftoverStorageFundInflow","EpochInfo","epochTotalTransactions","firstCheckpointId","epochStartTimestamp","endOfEpochInfo","EpochPage","number10","SubscriptionId","array9","boolean9","nullable10","object11","string11","ResolvedNameServiceNames","array10","number11","object12","string12","tuple5","boolean10","optional6","any3","nullable11","GasCostSummary2","CheckPointContentsDigest","CheckpointDigest","ECMHLiveObjectSetDigest","CheckpointCommitment","ValidatorSignature","EndOfEpochData","nextEpochCommittee","nextEpochProtocolVersion","epochCommitments","ExecutionDigests","Checkpoint","networkTotalTransactions","previousDigest","epochRollingGasCostSummary","endOfEpochData","validatorSignature","checkpointCommitments","CheckpointPage","blake2b2","fromB643","toB643","fromB642","toB642","SECP256R1_PUBLIC_KEY_SIZE","Secp256r1PublicKey","Error","equals","publicKey","bytesEqual","toBytes","toBase64","toString","toSuiAddress","tmp","set","SIGNATURE_SCHEME_TO_FLAG","dkLen","flag","SIZE","ED25519","Secp256k1","Secp256r1","MultiSig","SIGNATURE_FLAG_TO_SCHEME","toSerializedSignature","_ref","signatureScheme","pubKey","serializedSignature","fromSerializedSignature","SIGNATURE_SCHEME_TO_PUBLIC_KEY","Ed25519PublicKey","Secp256k1PublicKey","PublicKey3","pubkeyBytes","bytesToHex2","PUBLIC_KEY_SIZE","i","publicKeyFromSerialized","schema","SECP256K1_PUBLIC_KEY_SIZE","secp256k1","toHEX","mnemonicToSeedSync","bip39MnemonicToSeedSync","isValidHardenedPath","path","RegExp","isValidBIP32Path","mnemonicToSeed","mnemonics","mnemonicToSeedHex","HDKey","toB645","bytesToHex4","blake2b4","DEFAULT_SECP256K1_DERIVATION_PATH","Secp256k1Keypair","keypair","secretKey","utils","randomPrivateKey","getPublicKey","getKeyScheme","generate","fromSecretKey","options","skipValidation","encoder","signData","msgHash","sign","verify","lowS","fromSeed","seed","sig","toCompactRawBytes","deriveKeypair","key","fromMasterSeed","derive","privateKey","export","PRIVATE_KEY_SIZE","LEGACY_PRIVATE_KEY_SIZE","fromExportedKeypair","pureSecretKey","Ed25519Keypair","sha512","hmac","nacl","fromHEX","ED25519_CURVE","HARDENED_OFFSET","pathRegex","replaceDerive","val","replace","getMasterKeyFromSeed","h","create","I","update","IL","IR","chainCode","CKDPriv","_ref2","index","indexBuffer","ArrayBuffer","cv","DataView","setUint32","byteLength","fill","isValidPath","some","isNaN","derivePath","offset","segments","parseInt","parentKeys","segment","toB646","DEFAULT_ED25519_DERIVATION_PATH","keyPair","secretKeyLength","detached","sha2562","secp256r1","HDKey2","toB647","bytesToHex5","blake2b5","DEFAULT_SECP256R1_DERIVATION_PATH","Secp256r1Keypair","toB648","blake2b6","bytesToHex6","MAX_SIGNER_IN_MULTISIG","toMultiSigAddress","pks","threshold","maxLength","arr","to_uint8array","pk","weight","combinePartialSigs","sigs","multisig_pk","pk_map","x","toPkWeightPair","bitmap","compressed_sigs","parsed","bytes2","Number","j","multisig","builder","ser","decodeMultiSig","fromB646","de","s","pk_index","as_indices","at","pk_bytes","values","scheme","keys","pair","push","RequestManager","HTTPTransport","Client","PACKAGE_VERSION","TARGETED_RPC_VERSION","RPCValidationError","cause","req","result","message","JSON","stringify","FaucetRateLimitError","JsonRpcClient","url","httpHeaders","transport","headers","rpcClient","requestWithType","method","args","response","request","err","validate","RPCValidationError2","params","any4","array11","boolean11","literal6","nullable12","number12","object13","string13","union6","DynamicFieldType","DynamicFieldName","DynamicFieldInfo","bcsName","DynamicFieldPage","RequestManager2","Client2","WebSocketTransport","getWebsocketUrl","httpUrl","port","URL","protocol","DEFAULT_CLIENT_OPTIONS","callTimeout","reconnectTimeout","maxReconnects","_client","_subscriptions","_disconnects","_setupClient","setupClient_fn","_reconnect","reconnect_fn","WebsocketClient","endpoint","__privateAdd","__privateSet","Map","client","__privateMethod","call","__privateGet","client2","subscription","get","delete","unsubscribe","WeakMap","WeakSet","requestManager","connection","addEventListener","__privateWrapper","_","setTimeout","onNotification","forEach","onMessage","close","requestSuiFromFaucet","fetch","body","FixedAmountRequest","json","any6","array15","string18","nullable14","fromB582","toB649","toHEX2","_options","Connection","fullnode","websocket","faucet","localnetConnection","devnetConnection","testnetConnection","mainnetConnection","fromB648","is6","mask","BCS2","fromB647","is4","any5","array12","integer","literal7","object14","optional7","string14","union7","assert","define3","unknown","record5","superstructCreate","TRANSACTION_TYPE","Symbol","VECTOR_REGEX","STRUCT_REGEX","TypeTagSerializer","parseFromStr","normalizeAddress","vectorMatch","structMatch","parseStructTypeArgs","tok","word","nestedAngleBrackets","char","tok2","tagToString","tag","option","TransactionBlockInput","TransactionArgumentTypes","resultIndex","TransactionArgument","ObjectTransactionArgument","PureTransactionArgument","MoveCallTransaction","target","validator","TransferObjectsTransaction","SplitCoinsTransaction","amounts","MergeCoinsTransaction","destination","sources","MakeMoveVecTransaction","PublishTransaction","UpgradePolicy","UpgradePolicy2","UpgradeTransaction","ticket","TransactionTypes","TransactionType","getTransactionType","find","Transactions","_ref3","dep","_ref4","_ref5","array13","boolean12","integer2","object15","string15","union8","BCS3","ARGUMENT_INNER","VECTOR2","OPTION","CALL_ARG","TYPE_TAG","OBJECT_ARG","PROGRAMMABLE_TX_BLOCK","PROGRAMMABLE_CALL_INNER","TRANSACTION_INNER","COMPRESSED_SIGNATURE","PUBLIC_KEY","MULTISIG_PUBLIC_KEY","MULTISIG_PK_MAP","MULTISIG","ENUM_KIND","TRANSACTION","ARGUMENT","PROGRAMMABLE_CALL","registerFixedArray","registerStructType","registerEnumType","GasCoin","U16","typeMap","invariant","enumType","getTypeInterface","_encodeRaw","_decodeRaw","encodeProgrammableTx","pkg","fun","decodeProgrammableTx","bcs2","encode2","piece","decode2","PureCallArg","ObjectCallArg","BuilderCallArg","Inputs","maxSize","Infinity","ObjectRef","_ref6","_ref7","getIdFromCallArg","getSharedObjectInput","isSharedObjectInput","isMutableSharedObjectInput","STD_ASCII_MODULE_NAME","STD_ASCII_STRUCT_NAME","STD_UTF8_MODULE_NAME","STD_UTF8_STRUCT_NAME","STD_OPTION_MODULE_NAME","STD_OPTION_STRUCT_NAME","RESOLVED_SUI_ID","RESOLVED_ASCII_STR","RESOLVED_UTF8_STR","RESOLVED_STD_OPTION","isSameStruct","isTxContext","param","expectType","typeName","argVal","allowedTypes","getPureSerializationType","innerType","optionToVec","toB58","array14","assert2","define4","integer3","is5","literal8","nullable13","object16","optional8","string16","union9","blake2b7","hashTypedData","typeTag","typeTagBytes","charCodeAt","dataWithTag","SuiAddress3","StringEncodedBigint","GasConfig","SerializedTransactionDataBuilder","gasConfig","prepareSuiAddress","TransactionBlockDataBuilder","clone","fromKindBytes","programmableTx","serialized","restore","fromBytes","rawData","transactionData","getDigestFromBytes","hash","build","maxSizeBytes","overrides","onlyTransactionKind","getDigest","snapshot","DefaultOfflineLimits","maxPureArgumentSize","maxTxGas","maxGasObjects","maxTxSizeBytes","createTransactionResult","baseResult","nestedResults","nestedResultFor","Proxy","property","Reflect","iterator","expectProvider","provider","TRANSACTION_BRAND","for","LIMITS","GAS_SAFE_OVERHEAD","MAX_OBJECTS_PER_FETCH","chunk","Math","ceil","_blockData","_input","input_fn","_getConfig","getConfig_fn","_validate","validate_fn","_prepareGasPayment","prepareGasPayment_fn","_prepareGasPrice","prepareGasPrice_fn","_prepareTransactions","prepareTransactions_fn","_prepare","prepare_fn","_TransactionBlock","blockData","fromKind","parse","setSender","setSenderIfNotSet","setExpiration","setGasPrice","String","setGasBudget","setGasOwner","setGasPayment","payments","gas","inserted","objectRef","sharedObjectRef","pure","add","splitCoins","mergeCoins","publish","upgrade","moveCall","transferObjects","makeMoveVec","serialize","TransactionBlock","_ref8","protocolConfig","limits","attribute","gasOwner","getCoins","paymentCoins","matchingInput","getReferenceGasPrice","moveModulesToResolve","objectsToResolve","needsResolution","transactionType","entries","_ref9","keySchema","wellKnownEncoding","encodeInput","arrayItem","Promise","all","moduleName","functionName","normalized","getNormalizedMoveFunction","hasTxContext","inputValue","serType","structVal","dedupedIds","Set","_ref10","objectChunks","chunk2","multiGetObjects","ids","flat","objectsById","invalidObjects","_ref11","_ref12","_ref13","object18","getProtocolConfig","dryRunResult","dryRunTransactionBlock","transactionBlock","safeOverhead","baseComputationCostWithOverhead","gasBudget","number13","object17","string17","NetworkMetrics","currentTps","tps30Days","currentCheckpoint","currentEpoch","totalAddresses","totalObjects","totalPackages","AddressMetrics","cumulativeAddresses","cumulativeActiveAddresses","dailyActiveAddresses","DEFAULT_OPTIONS","socketOptions","versionCacheTimeoutInSeconds","JsonRpcProvider","opts","wsClient","websocketClient","getRpcApiVersion","rpcApiVersion","cacheExpiry","Date","now","info","console","warn","cursor","limit","getAllCoins","getAllBalances","getCoinMetadata","getTotalSupply","getMoveFunctionArgTypes","getNormalizedMoveModulesByPackage","getNormalizedMoveModule","getNormalizedMoveStruct","getOwnedObjects","getObject","tryGetPastObject","hasDuplicates","queryTransactionBlocks","order","getTransactionBlock","multiGetTransactionBlocks","digests","d","executeTransactionBlock","requestType","getTotalTransactionBlocks","getStakes","getStakesByIds","stakedSuiIds","getLatestSuiSystemState","queryEvents","query","subscribeEvent","subscribeTransaction","devInspectTransactionBlock","devInspectTxBytes","getDynamicFields","parentId","getDynamicFieldObject","getLatestCheckpointSequenceNumber","getCheckpoint","getCheckpoints","descendingOrder","getCommitteeInfo","getNetworkMetrics","getAddressMetrics","getEpochs","getMoveCallMetrics","getCurrentEpoch","getValidatorsApy","getChainIdentifier","resolveNameServiceAddress","resolveNameServiceNames","waitForTransactionBlock","_ref14","signal","timeout","pollInterval","timeoutSignal","AbortSignal","timeoutPromise","reject","reason","aborted","throwIfAborted","race","resolve","blake2b8","fromB649","toB6410","AppId","AppId2","IntentVersion","IntentVersion2","IntentScope","IntentScope3","intentWithScope","scope","messageWithIntent","intent","intentMessage","SignerWithProvider","getAddress","signMessage","messageBytes","prepareTransactionBlock","signTransactionBlock","transactionBlockBytes","signAndExecuteTransactionBlock","getTransactionBlockDigest","dryRunTxBytes","getGasCostEstimation","txEffects","gasEstimation","RawSigner","pubkey","connect","ELLIPSIS","formatAddress","formatDigest","fromB6410","nacl3","secp256k12","sha2563","blake2b9","verifyMessage","Signature","fromCompact","SUI_SYSTEM_STATE_OBJECT_ID","SUI_SYSTEM_MODULE_NAME","ADD_STAKE_FUN_NAME","ADD_STAKE_LOCKED_COIN_FUN_NAME","WITHDRAW_STAKE_FUN_NAME","SuiSystemStateUtil","newRequestAddStakeTxn","coinObjects","newRequestWithdrawlStakeTxn","stake","stakedCoinId","toB6411","is7","assert3"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/ed25519-keypair.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/keypair.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/secp256k1-keypair.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/secp256k1-publickey.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/common.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/objects.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/events.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/transactions.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/option.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/framework/framework.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/sui-bcs.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/faucet.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/normalized.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/validator.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/coin.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/epochs.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/subscriptions.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/name-service.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/checkpoints.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/ed25519-publickey.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/signature.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/secp256r1-publickey.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/publickey.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/mnemonics.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/utils/ed25519-hd-key.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/secp256r1-keypair.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/multisig.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/rpc/client.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/version.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/utils/errors.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/dynamic_fields.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/rpc/websocket-client.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/rpc/faucet-client.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/providers/json-rpc-provider.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/rpc/connection.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/builder/TransactionBlock.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/builder/Transactions.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/builder/utils.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/signers/txn-data-serializers/type-tag-serializer.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/builder/Inputs.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/builder/bcs.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/builder/serializer.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/builder/TransactionBlockData.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/cryptography/hash.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/types/metrics.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/signers/raw-signer.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/signers/signer-with-provider.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/utils/intent.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/utils/format.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/utils/verify.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/framework/sui-system-state.ts","/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/index.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport nacl from 'tweetnacl';\nimport { ExportedKeypair, Keypair, PRIVATE_KEY_SIZE } from './keypair';\nimport { Ed25519PublicKey } from './ed25519-publickey';\nimport { isValidHardenedPath, mnemonicToSeedHex } from './mnemonics';\nimport { derivePath } from '../utils/ed25519-hd-key';\nimport { toB64 } from '@mysten/bcs';\nimport { SignatureScheme } from './signature';\n\nexport const DEFAULT_ED25519_DERIVATION_PATH = \"m/44'/784'/0'/0'/0'\";\n\n/**\n * Ed25519 Keypair data. The publickey is the 32-byte public key and\n * the secretkey is 64-byte, where the first 32 bytes is the secret\n * key and the last 32 bytes is the public key.\n */\nexport interface Ed25519KeypairData {\n  publicKey: Uint8Array;\n  secretKey: Uint8Array;\n}\n\n/**\n * An Ed25519 Keypair used for signing transactions.\n */\nexport class Ed25519Keypair implements Keypair {\n  private keypair: Ed25519KeypairData;\n\n  /**\n   * Create a new Ed25519 keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param keypair Ed25519 keypair\n   */\n  constructor(keypair?: Ed25519KeypairData) {\n    if (keypair) {\n      this.keypair = keypair;\n    } else {\n      this.keypair = nacl.sign.keyPair();\n    }\n  }\n\n  /**\n   * Get the key scheme of the keypair ED25519\n   */\n  getKeyScheme(): SignatureScheme {\n    return 'ED25519';\n  }\n\n  /**\n   * Generate a new random Ed25519 keypair\n   */\n  static generate(): Ed25519Keypair {\n    return new Ed25519Keypair(nacl.sign.keyPair());\n  }\n\n  /**\n   * Create a Ed25519 keypair from a raw secret key byte array, also known as seed.\n   * This is NOT the private scalar which is result of hashing and bit clamping of\n   * the raw secret key.\n   *\n   * The sui.keystore key is a list of Base64 encoded `flag || privkey`. To import\n   * a key from sui.keystore to typescript, decode from base64 and remove the first\n   * flag byte after checking it is indeed the Ed25519 scheme flag 0x00 (See more\n   * on flag for signature scheme: https://github.com/MystenLabs/sui/blob/818406c5abdf7de1b80915a0519071eec3a5b1c7/crates/sui-types/src/crypto.rs#L1650):\n   * ```\n   * import { Ed25519Keypair, fromB64 } from '@mysten/sui.js';\n   * const raw = fromB64(t[1]);\n   * if (raw[0] !== 0 || raw.length !== PRIVATE_KEY_SIZE + 1) {\n   *   throw new Error('invalid key');\n   * }\n   * const imported = Ed25519Keypair.fromSecretKey(raw.slice(1))\n   * ```\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options: skip secret key validation\n   */\n  static fromSecretKey(\n    secretKey: Uint8Array,\n    options?: { skipValidation?: boolean },\n  ): Ed25519Keypair {\n    const secretKeyLength = secretKey.length;\n    if (secretKeyLength !== PRIVATE_KEY_SIZE) {\n      throw new Error(\n        `Wrong secretKey size. Expected ${PRIVATE_KEY_SIZE} bytes, got ${secretKeyLength}.`,\n      );\n    }\n    const keypair = nacl.sign.keyPair.fromSeed(secretKey);\n    if (!options || !options.skipValidation) {\n      const encoder = new TextEncoder();\n      const signData = encoder.encode('sui validation');\n      const signature = nacl.sign.detached(signData, keypair.secretKey);\n      if (!nacl.sign.detached.verify(signData, signature, keypair.publicKey)) {\n        throw new Error('provided secretKey is invalid');\n      }\n    }\n    return new Ed25519Keypair(keypair);\n  }\n\n  /**\n   * The public key for this Ed25519 keypair\n   */\n  getPublicKey(): Ed25519PublicKey {\n    return new Ed25519PublicKey(this.keypair.publicKey);\n  }\n\n  /**\n   * Return the signature for the provided data using Ed25519.\n   */\n  signData(data: Uint8Array): Uint8Array {\n    return nacl.sign.detached(data, this.keypair.secretKey);\n  }\n\n  /**\n   * Derive Ed25519 keypair from mnemonics and path. The mnemonics must be normalized\n   * and validated against the english wordlist.\n   *\n   * If path is none, it will default to m/44'/784'/0'/0'/0', otherwise the path must\n   * be compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.\n   */\n  static deriveKeypair(mnemonics: string, path?: string): Ed25519Keypair {\n    if (path == null) {\n      path = DEFAULT_ED25519_DERIVATION_PATH;\n    }\n    if (!isValidHardenedPath(path)) {\n      throw new Error('Invalid derivation path');\n    }\n    const { key } = derivePath(path, mnemonicToSeedHex(mnemonics));\n\n    return Ed25519Keypair.fromSecretKey(key);\n  }\n\n  /**\n   * This returns an exported keypair object, the private key field is the pure 32-byte seed.\n   */\n  export(): ExportedKeypair {\n    return {\n      schema: 'ED25519',\n      privateKey: toB64(this.keypair.secretKey.slice(0, PRIVATE_KEY_SIZE)),\n    };\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64 } from '@mysten/bcs';\nimport { Ed25519Keypair } from './ed25519-keypair';\nimport { PublicKey } from './publickey';\nimport { Secp256k1Keypair } from './secp256k1-keypair';\nimport { SignatureScheme } from './signature';\n\nexport const PRIVATE_KEY_SIZE = 32;\nexport const LEGACY_PRIVATE_KEY_SIZE = 64;\n\nexport type ExportedKeypair = {\n  schema: SignatureScheme;\n  privateKey: string;\n};\n\n/**\n * A keypair used for signing transactions.\n */\nexport interface Keypair {\n  /**\n   * The public key for this keypair\n   */\n  getPublicKey(): PublicKey;\n\n  /**\n   * Return the signature for the data\n   */\n  signData(data: Uint8Array): Uint8Array;\n\n  /**\n   * Get the key scheme of the keypair: Secp256k1 or ED25519\n   */\n  getKeyScheme(): SignatureScheme;\n\n  export(): ExportedKeypair;\n}\n\nexport function fromExportedKeypair(keypair: ExportedKeypair): Keypair {\n  const secretKey = fromB64(keypair.privateKey);\n  switch (keypair.schema) {\n    case 'ED25519':\n      let pureSecretKey = secretKey;\n      if (secretKey.length === LEGACY_PRIVATE_KEY_SIZE) {\n        // This is a legacy secret key, we need to strip the public key bytes and only read the first 32 bytes\n        pureSecretKey = secretKey.slice(0, PRIVATE_KEY_SIZE);\n      }\n      return Ed25519Keypair.fromSecretKey(pureSecretKey);\n    case 'Secp256k1':\n      return Secp256k1Keypair.fromSecretKey(secretKey);\n    default:\n      throw new Error(`Invalid keypair schema ${keypair.schema}`);\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ExportedKeypair, Keypair } from './keypair';\nimport { PublicKey } from './publickey';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { Secp256k1PublicKey } from './secp256k1-publickey';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { isValidBIP32Path, mnemonicToSeed } from './mnemonics';\nimport { HDKey } from '@scure/bip32';\nimport { toB64 } from '@mysten/bcs';\nimport { SignatureScheme } from './signature';\nimport { bytesToHex } from '@noble/hashes/utils';\nimport { blake2b } from '@noble/hashes/blake2b';\n\nexport const DEFAULT_SECP256K1_DERIVATION_PATH = \"m/54'/784'/0'/0/0\";\n\n/**\n * Secp256k1 Keypair data\n */\nexport interface Secp256k1KeypairData {\n  publicKey: Uint8Array;\n  secretKey: Uint8Array;\n}\n\n/**\n * An Secp256k1 Keypair used for signing transactions.\n */\nexport class Secp256k1Keypair implements Keypair {\n  private keypair: Secp256k1KeypairData;\n\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Secp256k1Keypair} is provided.\n   *\n   * @param keypair secp256k1 keypair\n   */\n  constructor(keypair?: Secp256k1KeypairData) {\n    if (keypair) {\n      this.keypair = keypair;\n    } else {\n      const secretKey: Uint8Array = secp256k1.utils.randomPrivateKey();\n      const publicKey: Uint8Array = secp256k1.getPublicKey(secretKey, true);\n\n      this.keypair = { publicKey, secretKey };\n    }\n  }\n\n  /**\n   * Get the key scheme of the keypair Secp256k1\n   */\n  getKeyScheme(): SignatureScheme {\n    return 'Secp256k1';\n  }\n\n  /**\n   * Generate a new random keypair\n   */\n  static generate(): Secp256k1Keypair {\n    return new Secp256k1Keypair();\n  }\n\n  /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options: skip secret key validation\n   */\n\n  static fromSecretKey(\n    secretKey: Uint8Array,\n    options?: { skipValidation?: boolean },\n  ): Secp256k1Keypair {\n    const publicKey: Uint8Array = secp256k1.getPublicKey(secretKey, true);\n    if (!options || !options.skipValidation) {\n      const encoder = new TextEncoder();\n      const signData = encoder.encode('sui validation');\n      const msgHash = bytesToHex(blake2b(signData, { dkLen: 32 }));\n      const signature = secp256k1.sign(msgHash, secretKey);\n      if (!secp256k1.verify(signature, msgHash, publicKey, { lowS: true })) {\n        throw new Error('Provided secretKey is invalid');\n      }\n    }\n    return new Secp256k1Keypair({ publicKey, secretKey });\n  }\n\n  /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   */\n  static fromSeed(seed: Uint8Array): Secp256k1Keypair {\n    let publicKey = secp256k1.getPublicKey(seed, true);\n    return new Secp256k1Keypair({ publicKey, secretKey: seed });\n  }\n\n  /**\n   * The public key for this keypair\n   */\n  getPublicKey(): PublicKey {\n    return new Secp256k1PublicKey(this.keypair.publicKey);\n  }\n\n  /**\n   * Return the signature for the provided data.\n   */\n  signData(data: Uint8Array): Uint8Array {\n    const msgHash = sha256(data);\n    const sig = secp256k1.sign(msgHash, this.keypair.secretKey, {\n      lowS: true,\n    });\n    return sig.toCompactRawBytes();\n  }\n\n  /**\n   * Derive Secp256k1 keypair from mnemonics and path. The mnemonics must be normalized\n   * and validated against the english wordlist.\n   *\n   * If path is none, it will default to m/54'/784'/0'/0/0, otherwise the path must\n   * be compliant to BIP-32 in form m/54'/784'/{account_index}'/{change_index}/{address_index}.\n   */\n  static deriveKeypair(mnemonics: string, path?: string): Secp256k1Keypair {\n    if (path == null) {\n      path = DEFAULT_SECP256K1_DERIVATION_PATH;\n    }\n    if (!isValidBIP32Path(path)) {\n      throw new Error('Invalid derivation path');\n    }\n    const key = HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(path);\n    if (key.publicKey == null || key.privateKey == null) {\n      throw new Error('Invalid key');\n    }\n    return new Secp256k1Keypair({\n      publicKey: key.publicKey,\n      secretKey: key.privateKey,\n    });\n  }\n\n  export(): ExportedKeypair {\n    return {\n      schema: 'Secp256k1',\n      privateKey: toB64(this.keypair.secretKey),\n    };\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../types';\nimport { bytesEqual, PublicKey, PublicKeyInitData } from './publickey';\nimport { SIGNATURE_SCHEME_TO_FLAG } from './signature';\n\nconst SECP256K1_PUBLIC_KEY_SIZE = 33;\n\n/**\n * A Secp256k1 public key\n */\nexport class Secp256k1PublicKey implements PublicKey {\n  static SIZE = SECP256K1_PUBLIC_KEY_SIZE;\n  private data: Uint8Array;\n\n  /**\n   * Create a new Secp256k1PublicKey object\n   * @param value secp256k1 public key as buffer or base-64 encoded string\n   */\n  constructor(value: PublicKeyInitData) {\n    if (typeof value === 'string') {\n      this.data = fromB64(value);\n    } else if (value instanceof Uint8Array) {\n      this.data = value;\n    } else {\n      this.data = Uint8Array.from(value);\n    }\n\n    if (this.data.length !== SECP256K1_PUBLIC_KEY_SIZE) {\n      throw new Error(\n        `Invalid public key input. Expected ${SECP256K1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n      );\n    }\n  }\n\n  /**\n   * Checks if two Secp256k1 public keys are equal\n   */\n  equals(publicKey: Secp256k1PublicKey): boolean {\n    return bytesEqual(this.toBytes(), publicKey.toBytes());\n  }\n\n  /**\n   * Return the base-64 representation of the Secp256k1 public key\n   */\n  toBase64(): string {\n    return toB64(this.toBytes());\n  }\n\n  /**\n   * Return the byte array representation of the Secp256k1 public key\n   */\n  toBytes(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Return the base-64 representation of the Secp256k1 public key\n   */\n  toString(): string {\n    return this.toBase64();\n  }\n\n  /**\n   * Return the Sui address associated with this Secp256k1 public key\n   */\n  toSuiAddress(): string {\n    let tmp = new Uint8Array(SECP256K1_PUBLIC_KEY_SIZE + 1);\n    tmp.set([SIGNATURE_SCHEME_TO_FLAG['Secp256k1']]);\n    tmp.set(this.toBytes(), 1);\n    // Each hex char represents half a byte, hence hex address doubles the length\n    return normalizeSuiAddress(\n      bytesToHex(blake2b(tmp, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2),\n    );\n  }\n\n  /**\n   * Return the Sui address associated with this Secp256k1 public key\n   */\n  flag(): number {\n    return SIGNATURE_SCHEME_TO_FLAG['Secp256k1'];\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  boolean,\n  define,\n  Infer,\n  literal,\n  nullable,\n  number,\n  object,\n  record,\n  string,\n  union,\n} from 'superstruct';\nimport { CallArg } from './sui-bcs';\nimport { fromB58 } from '@mysten/bcs';\n\nexport const TransactionDigest = string();\nexport type TransactionDigest = Infer<typeof TransactionDigest>;\n\nexport const TransactionEffectsDigest = string();\nexport type TransactionEffectsDigest = Infer<typeof TransactionEffectsDigest>;\n\nexport const TransactionEventDigest = string();\nexport type TransactionEventDigest = Infer<typeof TransactionEventDigest>;\n\nexport const ObjectId = string();\nexport type ObjectId = Infer<typeof ObjectId>;\n\nexport const SuiAddress = string();\nexport type SuiAddress = Infer<typeof SuiAddress>;\n\nexport const SequenceNumber = string();\nexport type SequenceNumber = Infer<typeof SequenceNumber>;\n\nexport const ObjectOwner = union([\n  object({\n    AddressOwner: SuiAddress,\n  }),\n  object({\n    ObjectOwner: SuiAddress,\n  }),\n  object({\n    Shared: object({\n      initial_shared_version: number(),\n    }),\n  }),\n  literal('Immutable'),\n]);\nexport type ObjectOwner = Infer<typeof ObjectOwner>;\n\nexport type SuiJsonValue =\n  | boolean\n  | number\n  | string\n  | CallArg\n  | Array<SuiJsonValue>;\nexport const SuiJsonValue = define<SuiJsonValue>('SuiJsonValue', () => true);\n\nconst ProtocolConfigValue = union([\n  object({ u32: string() }),\n  object({ u64: string() }),\n  object({ f64: string() }),\n]);\ntype ProtocolConfigValue = Infer<typeof ProtocolConfigValue>;\n\nexport const ProtocolConfig = object({\n  attributes: record(string(), nullable(ProtocolConfigValue)),\n  featureFlags: record(string(), boolean()),\n  maxSupportedProtocolVersion: string(),\n  minSupportedProtocolVersion: string(),\n  protocolVersion: string(),\n});\nexport type ProtocolConfig = Infer<typeof ProtocolConfig>;\n\n// source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L171\nconst TX_DIGEST_LENGTH = 32;\n\n/** Returns whether the tx digest is valid based on the serialization format */\nexport function isValidTransactionDigest(\n  value: string,\n): value is TransactionDigest {\n  try {\n    const buffer = fromB58(value);\n    return buffer.length === TX_DIGEST_LENGTH;\n  } catch (e) {\n    return false;\n  }\n}\n\n// TODO - can we automatically sync this with rust length definition?\n// Source of truth is\n// https://github.com/MystenLabs/sui/blob/acb2b97ae21f47600e05b0d28127d88d0725561d/crates/sui-types/src/base_types.rs#L67\n// which uses the Move account address length\n// https://github.com/move-language/move/blob/67ec40dc50c66c34fd73512fcc412f3b68d67235/language/move-core/types/src/account_address.rs#L23 .\n\nexport const SUI_ADDRESS_LENGTH = 32;\nexport function isValidSuiAddress(value: string): value is SuiAddress {\n  return isHex(value) && getHexByteLength(value) === SUI_ADDRESS_LENGTH;\n}\n\nexport function isValidSuiObjectId(value: string): boolean {\n  return isValidSuiAddress(value);\n}\n\ntype StructTag = {\n  address: string;\n  module: string;\n  name: string;\n  typeParams: (string | StructTag)[];\n};\n\nfunction parseTypeTag(type: string): string | StructTag {\n  if (!type.includes('::')) return type;\n\n  return parseStructTag(type);\n}\n\nexport function parseStructTag(type: string): StructTag {\n  const [address, module] = type.split('::');\n\n  const rest = type.slice(address.length + module.length + 4);\n  const name = rest.includes('<') ? rest.slice(0, rest.indexOf('<')) : rest;\n  const typeParams = rest.includes('<')\n    ? rest\n        .slice(rest.indexOf('<') + 1, rest.lastIndexOf('>'))\n        .split(',')\n        .map((typeParam) => parseTypeTag(typeParam.trim()))\n    : [];\n\n  return {\n    address: normalizeSuiAddress(address),\n    module,\n    name,\n    typeParams,\n  };\n}\n\nexport function normalizeStructTag(type: string | StructTag): string {\n  const { address, module, name, typeParams } =\n    typeof type === 'string' ? parseStructTag(type) : type;\n\n  const formattedTypeParams =\n    typeParams.length > 0\n      ? `<${typeParams\n          .map((typeParam) =>\n            typeof typeParam === 'string'\n              ? typeParam\n              : normalizeStructTag(typeParam),\n          )\n          .join(',')}>`\n      : '';\n\n  return `${address}::${module}::${name}${formattedTypeParams}`;\n}\n\n/**\n * Perform the following operations:\n * 1. Make the address lower case\n * 2. Prepend `0x` if the string does not start with `0x`.\n * 3. Add more zeros if the length of the address(excluding `0x`) is less than `SUI_ADDRESS_LENGTH`\n *\n * WARNING: if the address value itself starts with `0x`, e.g., `0x0x`, the default behavior\n * is to treat the first `0x` not as part of the address. The default behavior can be overridden by\n * setting `forceAdd0x` to true\n *\n */\nexport function normalizeSuiAddress(\n  value: string,\n  forceAdd0x: boolean = false,\n): SuiAddress {\n  let address = value.toLowerCase();\n  if (!forceAdd0x && address.startsWith('0x')) {\n    address = address.slice(2);\n  }\n  return `0x${address.padStart(SUI_ADDRESS_LENGTH * 2, '0')}`;\n}\n\nexport function normalizeSuiObjectId(\n  value: string,\n  forceAdd0x: boolean = false,\n): ObjectId {\n  return normalizeSuiAddress(value, forceAdd0x);\n}\n\nfunction isHex(value: string): boolean {\n  return /^(0x|0X)?[a-fA-F0-9]+$/.test(value) && value.length % 2 === 0;\n}\n\nfunction getHexByteLength(value: string): number {\n  return /^(0x|0X)/.test(value) ? (value.length - 2) / 2 : value.length / 2;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  any,\n  array,\n  assign,\n  boolean,\n  Infer,\n  literal,\n  number,\n  object,\n  optional,\n  record,\n  string,\n  union,\n  is,\n  nullable,\n  tuple,\n} from 'superstruct';\nimport {\n  ObjectId,\n  ObjectOwner,\n  SequenceNumber,\n  TransactionDigest,\n} from './common';\nimport { OwnedObjectRef } from './transactions';\n\nexport const ObjectType = union([string(), literal('package')]);\nexport type ObjectType = Infer<typeof ObjectType>;\n\nexport const SuiObjectRef = object({\n  /** Base64 string representing the object digest */\n  digest: TransactionDigest,\n  /** Hex code as string representing the object id */\n  objectId: string(),\n  /** Object version */\n  version: union([number(), string()]),\n});\nexport type SuiObjectRef = Infer<typeof SuiObjectRef>;\n\nexport const SuiGasData = object({\n  payment: array(SuiObjectRef),\n  /** Gas Object's owner */\n  owner: string(),\n  price: string(),\n  budget: string(),\n});\nexport type SuiGasData = Infer<typeof SuiGasData>;\n\nexport const SuiObjectInfo = assign(\n  SuiObjectRef,\n  object({\n    type: string(),\n    owner: ObjectOwner,\n    previousTransaction: TransactionDigest,\n  }),\n);\nexport type SuiObjectInfo = Infer<typeof SuiObjectInfo>;\n\nexport const ObjectContentFields = record(string(), any());\nexport type ObjectContentFields = Infer<typeof ObjectContentFields>;\n\nexport const MovePackageContent = record(string(), string());\nexport type MovePackageContent = Infer<typeof MovePackageContent>;\n\nexport const SuiMoveObject = object({\n  /** Move type (e.g., \"0x2::coin::Coin<0x2::sui::SUI>\") */\n  type: string(),\n  /** Fields and values stored inside the Move object */\n  fields: ObjectContentFields,\n  hasPublicTransfer: boolean(),\n});\nexport type SuiMoveObject = Infer<typeof SuiMoveObject>;\n\nexport const SuiMovePackage = object({\n  /** A mapping from module name to disassembled Move bytecode */\n  disassembled: MovePackageContent,\n});\nexport type SuiMovePackage = Infer<typeof SuiMovePackage>;\n\nexport const SuiParsedData = union([\n  assign(SuiMoveObject, object({ dataType: literal('moveObject') })),\n  assign(SuiMovePackage, object({ dataType: literal('package') })),\n]);\nexport type SuiParsedData = Infer<typeof SuiParsedData>;\n\nexport const SuiRawMoveObject = object({\n  /** Move type (e.g., \"0x2::coin::Coin<0x2::sui::SUI>\") */\n  type: string(),\n  hasPublicTransfer: boolean(),\n  version: number(),\n  bcsBytes: string(),\n});\nexport type SuiRawMoveObject = Infer<typeof SuiRawMoveObject>;\n\nexport const SuiRawMovePackage = object({\n  id: ObjectId,\n  /** A mapping from module name to Move bytecode enocded in base64*/\n  moduleMap: record(string(), string()),\n});\nexport type SuiRawMovePackage = Infer<typeof SuiRawMovePackage>;\n\n// TODO(chris): consolidate SuiRawParsedData and SuiRawObject using generics\nexport const SuiRawData = union([\n  assign(SuiRawMoveObject, object({ dataType: literal('moveObject') })),\n  assign(SuiRawMovePackage, object({ dataType: literal('package') })),\n]);\nexport type SuiRawData = Infer<typeof SuiRawData>;\n\nexport const SUI_DECIMALS = 9;\n\nexport const MIST_PER_SUI = BigInt(1000000000);\n\nexport const ObjectDigest = string();\nexport type ObjectDigest = Infer<typeof ObjectDigest>;\nexport const SuiObjectResponseError = object({\n  code: string(),\n  error: optional(string()),\n  object_id: optional(ObjectId),\n  parent_object_id: optional(ObjectId),\n  version: optional(number()),\n  digest: optional(ObjectDigest),\n});\nexport type SuiObjectResponseError = Infer<typeof SuiObjectResponseError>;\nexport const DisplayFieldsResponse = object({\n  data: nullable(record(string(), string())),\n  error: nullable(SuiObjectResponseError),\n});\nexport type DisplayFieldsResponse = Infer<typeof DisplayFieldsResponse>;\n// TODO: remove after all envs support the new DisplayFieldsResponse;\nexport const DisplayFieldsBackwardCompatibleResponse = union([\n  DisplayFieldsResponse,\n  optional(record(string(), string())),\n]);\nexport type DisplayFieldsBackwardCompatibleResponse = Infer<\n  typeof DisplayFieldsBackwardCompatibleResponse\n>;\n\nexport const SuiObjectData = object({\n  objectId: ObjectId,\n  version: SequenceNumber,\n  digest: ObjectDigest,\n  /**\n   * Type of the object, default to be undefined unless SuiObjectDataOptions.showType is set to true\n   */\n  type: optional(string()),\n  /**\n   * Move object content or package content, default to be undefined unless SuiObjectDataOptions.showContent is set to true\n   */\n  content: optional(SuiParsedData),\n  /**\n   * Move object content or package content in BCS bytes, default to be undefined unless SuiObjectDataOptions.showBcs is set to true\n   */\n  bcs: optional(SuiRawData),\n  /**\n   * The owner of this object. Default to be undefined unless SuiObjectDataOptions.showOwner is set to true\n   */\n  owner: optional(ObjectOwner),\n  /**\n   * The digest of the transaction that created or last mutated this object.\n   * Default to be undefined unless SuiObjectDataOptions.showPreviousTransaction is set to true\n   */\n  previousTransaction: optional(TransactionDigest),\n  /**\n   * The amount of SUI we would rebate if this object gets deleted.\n   * This number is re-calculated each time the object is mutated based on\n   * the present storage gas price.\n   * Default to be undefined unless SuiObjectDataOptions.showStorageRebate is set to true\n   */\n  storageRebate: optional(string()),\n  /**\n   * Display metadata for this object, default to be undefined unless SuiObjectDataOptions.showDisplay is set to true\n   * This can also be None if the struct type does not have Display defined\n   * See more details in https://forums.sui.io/t/nft-object-display-proposal/4872\n   */\n  display: optional(DisplayFieldsBackwardCompatibleResponse),\n});\nexport type SuiObjectData = Infer<typeof SuiObjectData>;\n\n/**\n * Config for fetching object data\n */\nexport const SuiObjectDataOptions = object({\n  /* Whether to fetch the object type, default to be true */\n  showType: optional(boolean()),\n  /* Whether to fetch the object content, default to be false */\n  showContent: optional(boolean()),\n  /* Whether to fetch the object content in BCS bytes, default to be false */\n  showBcs: optional(boolean()),\n  /* Whether to fetch the object owner, default to be false */\n  showOwner: optional(boolean()),\n  /* Whether to fetch the previous transaction digest, default to be false */\n  showPreviousTransaction: optional(boolean()),\n  /* Whether to fetch the storage rebate, default to be false */\n  showStorageRebate: optional(boolean()),\n  /* Whether to fetch the display metadata, default to be false */\n  showDisplay: optional(boolean()),\n});\nexport type SuiObjectDataOptions = Infer<typeof SuiObjectDataOptions>;\n\nexport const ObjectStatus = union([\n  literal('Exists'),\n  literal('notExists'),\n  literal('Deleted'),\n]);\nexport type ObjectStatus = Infer<typeof ObjectStatus>;\n\nexport const GetOwnedObjectsResponse = array(SuiObjectInfo);\nexport type GetOwnedObjectsResponse = Infer<typeof GetOwnedObjectsResponse>;\n\nexport const SuiObjectResponse = object({\n  data: optional(SuiObjectData),\n  error: optional(SuiObjectResponseError),\n});\nexport type SuiObjectResponse = Infer<typeof SuiObjectResponse>;\n\nexport type Order = 'ascending' | 'descending';\n\n/* -------------------------------------------------------------------------- */\n/*                              Helper functions                              */\n/* -------------------------------------------------------------------------- */\n\n/* -------------------------- SuiObjectResponse ------------------------- */\n\nexport function getSuiObjectData(\n  resp: SuiObjectResponse,\n): SuiObjectData | undefined {\n  return resp.data;\n}\n\nexport function getObjectDeletedResponse(\n  resp: SuiObjectResponse,\n): SuiObjectRef | undefined {\n  if (\n    resp.error &&\n    'object_id' in resp.error &&\n    'version' in resp.error &&\n    'digest' in resp.error\n  ) {\n    const error = resp.error as SuiObjectResponseError;\n    return {\n      objectId: error.object_id,\n      version: error.version,\n      digest: error.digest,\n    } as SuiObjectRef;\n  }\n\n  return undefined;\n}\n\nexport function getObjectNotExistsResponse(\n  resp: SuiObjectResponse,\n): ObjectId | undefined {\n  if (\n    resp.error &&\n    'object_id' in resp.error &&\n    !('version' in resp.error) &&\n    !('digest' in resp.error)\n  ) {\n    return (resp.error as SuiObjectResponseError).object_id as ObjectId;\n  }\n\n  return undefined;\n}\n\nexport function getObjectReference(\n  resp: SuiObjectResponse | OwnedObjectRef,\n): SuiObjectRef | undefined {\n  if ('reference' in resp) {\n    return resp.reference;\n  }\n  const exists = getSuiObjectData(resp);\n  if (exists) {\n    return {\n      objectId: exists.objectId,\n      version: exists.version,\n      digest: exists.digest,\n    };\n  }\n  return getObjectDeletedResponse(resp);\n}\n\n/* ------------------------------ SuiObjectRef ------------------------------ */\n\nexport function getObjectId(\n  data: SuiObjectResponse | SuiObjectRef | OwnedObjectRef,\n): ObjectId {\n  if ('objectId' in data) {\n    return data.objectId;\n  }\n  return (\n    getObjectReference(data)?.objectId ??\n    getObjectNotExistsResponse(data as SuiObjectResponse)!\n  );\n}\n\nexport function getObjectVersion(\n  data: SuiObjectResponse | SuiObjectRef | SuiObjectData,\n): string | number | undefined {\n  if ('version' in data) {\n    return data.version;\n  }\n  return getObjectReference(data)?.version;\n}\n\n/* -------------------------------- SuiObject ------------------------------- */\n\nexport function isSuiObjectResponse(\n  resp: SuiObjectResponse | SuiObjectData,\n): resp is SuiObjectResponse {\n  return (resp as SuiObjectResponse).data !== undefined;\n}\n\n/**\n * Deriving the object type from the object response\n * @returns 'package' if the object is a package, move object type(e.g., 0x2::coin::Coin<0x2::sui::SUI>)\n * if the object is a move object\n */\nexport function getObjectType(\n  resp: SuiObjectResponse | SuiObjectData,\n): ObjectType | undefined {\n  const data = isSuiObjectResponse(resp) ? resp.data : resp;\n\n  if (!data?.type && 'data' in resp) {\n    if (data?.content?.dataType === 'package') {\n      return 'package';\n    }\n    return getMoveObjectType(resp);\n  }\n  return data?.type;\n}\n\nexport function getObjectPreviousTransactionDigest(\n  resp: SuiObjectResponse,\n): TransactionDigest | undefined {\n  return getSuiObjectData(resp)?.previousTransaction;\n}\n\nexport function getObjectOwner(\n  resp: SuiObjectResponse | ObjectOwner,\n): ObjectOwner | undefined {\n  if (is(resp, ObjectOwner)) {\n    return resp;\n  }\n  return getSuiObjectData(resp)?.owner;\n}\n\nexport function getObjectDisplay(\n  resp: SuiObjectResponse,\n): DisplayFieldsResponse {\n  const display = getSuiObjectData(resp)?.display;\n  if (!display) {\n    return { data: null, error: null };\n  }\n  if (is(display, DisplayFieldsResponse)) {\n    return display;\n  }\n  return {\n    data: display,\n    error: null,\n  };\n}\n\nexport function getSharedObjectInitialVersion(\n  resp: SuiObjectResponse | ObjectOwner,\n): number | undefined {\n  const owner = getObjectOwner(resp);\n  if (typeof owner === 'object' && 'Shared' in owner) {\n    return owner.Shared.initial_shared_version;\n  } else {\n    return undefined;\n  }\n}\n\nexport function isSharedObject(resp: SuiObjectResponse | ObjectOwner): boolean {\n  const owner = getObjectOwner(resp);\n  return typeof owner === 'object' && 'Shared' in owner;\n}\n\nexport function isImmutableObject(\n  resp: SuiObjectResponse | ObjectOwner,\n): boolean {\n  const owner = getObjectOwner(resp);\n  return owner === 'Immutable';\n}\n\nexport function getMoveObjectType(resp: SuiObjectResponse): string | undefined {\n  return getMoveObject(resp)?.type;\n}\n\nexport function getObjectFields(\n  resp: SuiObjectResponse | SuiMoveObject | SuiObjectData,\n): ObjectContentFields | undefined {\n  if ('fields' in resp) {\n    return resp.fields;\n  }\n  return getMoveObject(resp)?.fields;\n}\n\nexport interface SuiObjectDataWithContent extends SuiObjectData {\n  content: SuiParsedData;\n}\n\nfunction isSuiObjectDataWithContent(\n  data: SuiObjectData,\n): data is SuiObjectDataWithContent {\n  return data.content !== undefined;\n}\n\nexport function getMoveObject(\n  data: SuiObjectResponse | SuiObjectData,\n): SuiMoveObject | undefined {\n  const suiObject =\n    'data' in data ? getSuiObjectData(data) : (data as SuiObjectData);\n\n  if (\n    !suiObject ||\n    !isSuiObjectDataWithContent(suiObject) ||\n    suiObject.content.dataType !== 'moveObject'\n  ) {\n    return undefined;\n  }\n\n  return suiObject.content as SuiMoveObject;\n}\n\nexport function hasPublicTransfer(\n  data: SuiObjectResponse | SuiObjectData,\n): boolean {\n  return getMoveObject(data)?.hasPublicTransfer ?? false;\n}\n\nexport function getMovePackageContent(\n  data: SuiObjectResponse | SuiMovePackage,\n): MovePackageContent | undefined {\n  if ('disassembled' in data) {\n    return data.disassembled;\n  }\n  const suiObject = getSuiObjectData(data);\n  if (suiObject?.content?.dataType !== 'package') {\n    return undefined;\n  }\n  return (suiObject.content as SuiMovePackage).disassembled;\n}\n\nexport const CheckpointedObjectId = object({\n  objectId: ObjectId,\n  atCheckpoint: optional(number()),\n});\nexport type CheckpointedObjectId = Infer<typeof CheckpointedObjectId>;\n\nexport const PaginatedObjectsResponse = object({\n  data: array(SuiObjectResponse),\n  // TODO: remove union after 0.30.0 is released\n  nextCursor: union([nullable(ObjectId), nullable(CheckpointedObjectId)]),\n  hasNextPage: boolean(),\n});\nexport type PaginatedObjectsResponse = Infer<typeof PaginatedObjectsResponse>;\n\n// mirrors sui_json_rpc_types:: SuiObjectDataFilter\nexport type SuiObjectDataFilter =\n  | { MatchAll: SuiObjectDataFilter[] }\n  | { MatchAny: SuiObjectDataFilter[] }\n  | { MatchNone: SuiObjectDataFilter[] }\n  | { Package: ObjectId }\n  | { MoveModule: { package: ObjectId; module: string } }\n  | { StructType: string }\n  | { AddressOwner: string }\n  | { ObjectOwner: string }\n  | { ObjectId: string }\n  | { ObjectIds: string[] }\n  | { Version: string };\n\nexport type SuiObjectResponseQuery = {\n  filter?: SuiObjectDataFilter;\n  options?: SuiObjectDataOptions;\n};\n\nexport const ObjectRead = union([\n  object({\n    details: SuiObjectData,\n    status: literal('VersionFound'),\n  }),\n  object({\n    details: ObjectId,\n    status: literal('ObjectNotExists'),\n  }),\n  object({\n    details: SuiObjectRef,\n    status: literal('ObjectDeleted'),\n  }),\n  object({\n    details: tuple([ObjectId, number()]),\n    status: literal('VersionNotFound'),\n  }),\n  object({\n    details: object({\n      asked_version: number(),\n      latest_version: number(),\n      object_id: ObjectId,\n    }),\n    status: literal('VersionTooHigh'),\n  }),\n]);\nexport type ObjectRead = Infer<typeof ObjectRead>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  object,\n  string,\n  Infer,\n  array,\n  record,\n  any,\n  optional,\n  boolean,\n  nullable,\n} from 'superstruct';\nimport {\n  ObjectId,\n  SuiAddress,\n  TransactionDigest,\n  SuiJsonValue,\n  SequenceNumber,\n} from './common';\n\nexport const EventId = object({\n  txDigest: TransactionDigest,\n  eventSeq: SequenceNumber,\n});\n\n// event types mirror those in \"sui-json-rpc-types/src/sui_event.rs\"\n\nexport const SuiEvent = object({\n  id: EventId,\n  // Move package where this event was emitted.\n  packageId: ObjectId,\n  // Move module where this event was emitted.\n  transactionModule: string(),\n  // Sender's Sui address.\n  sender: SuiAddress,\n  // Move event type.\n  type: string(),\n  // Parsed json value of the event\n  parsedJson: optional(record(string(), any())),\n  // Base 58 encoded bcs bytes of the move event\n  bcs: optional(string()),\n  timestampMs: optional(string()),\n});\n\nexport type SuiEvent = Infer<typeof SuiEvent>;\n\nexport type MoveEventField = {\n  path: string;\n  value: SuiJsonValue;\n};\n\n/**\n * Sequential event ID, ie (transaction seq number, event seq number).\n * 1) Serves as a unique event ID for each fullnode\n * 2) Also serves to sequence events for the purposes of pagination and querying.\n *    A higher id is an event seen later by that fullnode.\n * This ID is the \"cursor\" for event querying.\n */\nexport type EventId = Infer<typeof EventId>;\n\n// mirrors sui_json_rpc_types::SuiEventFilter\nexport type SuiEventFilter =\n  | { Package: ObjectId }\n  | { MoveModule: { package: ObjectId; module: string } }\n  | { MoveEventType: string }\n  | { MoveEventField: MoveEventField }\n  | { Transaction: TransactionDigest }\n  | {\n      TimeRange: {\n        // left endpoint of time interval, milliseconds since epoch, inclusive\n        start_time: number;\n        // right endpoint of time interval, milliseconds since epoch, exclusive\n        end_time: number;\n      };\n    }\n  | { Sender: SuiAddress }\n  | { All: SuiEventFilter[] }\n  | { Any: SuiEventFilter[] }\n  | { And: [SuiEventFilter, SuiEventFilter] }\n  | { Or: [SuiEventFilter, SuiEventFilter] };\n\nexport const PaginatedEvents = object({\n  data: array(SuiEvent),\n  nextCursor: nullable(EventId),\n  hasNextPage: boolean(),\n});\nexport type PaginatedEvents = Infer<typeof PaginatedEvents>;\n\n/* ------------------------------- EventData ------------------------------ */\n\nexport function getEventSender(event: SuiEvent): SuiAddress {\n  return event.sender;\n}\n\nexport function getEventPackage(event: SuiEvent): ObjectId {\n  return event.packageId;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  is,\n  array,\n  Infer,\n  literal,\n  number,\n  object,\n  optional,\n  string,\n  union,\n  boolean,\n  tuple,\n  assign,\n  nullable,\n} from 'superstruct';\n\nimport {\n  ObjectId,\n  ObjectOwner,\n  SequenceNumber,\n  SuiAddress,\n  SuiJsonValue,\n  TransactionDigest,\n  TransactionEventDigest,\n} from './common';\nimport { SuiEvent } from './events';\nimport {\n  ObjectDigest,\n  SuiGasData,\n  SuiMovePackage,\n  SuiObjectRef,\n} from './objects';\n\nexport const EpochId = string();\n\nexport const SuiChangeEpoch = object({\n  epoch: EpochId,\n  storage_charge: string(),\n  computation_charge: string(),\n  storage_rebate: string(),\n  epoch_start_timestamp_ms: optional(string()),\n});\nexport type SuiChangeEpoch = Infer<typeof SuiChangeEpoch>;\n\nexport const SuiConsensusCommitPrologue = object({\n  epoch: EpochId,\n  round: string(),\n  commit_timestamp_ms: string(),\n});\nexport type SuiConsensusCommitPrologue = Infer<\n  typeof SuiConsensusCommitPrologue\n>;\n\nexport const Genesis = object({\n  objects: array(ObjectId),\n});\nexport type Genesis = Infer<typeof Genesis>;\n\nexport const SuiArgument = union([\n  literal('GasCoin'),\n  object({ Input: number() }),\n  object({ Result: number() }),\n  object({ NestedResult: tuple([number(), number()]) }),\n]);\nexport type SuiArgument = Infer<typeof SuiArgument>;\n\nexport const MoveCallSuiTransaction = object({\n  arguments: optional(array(SuiArgument)),\n  type_arguments: optional(array(string())),\n  package: ObjectId,\n  module: string(),\n  function: string(),\n});\nexport type MoveCallSuiTransaction = Infer<typeof MoveCallSuiTransaction>;\n\nexport const SuiTransaction = union([\n  object({ MoveCall: MoveCallSuiTransaction }),\n  object({ TransferObjects: tuple([array(SuiArgument), SuiArgument]) }),\n  object({ SplitCoins: tuple([SuiArgument, array(SuiArgument)]) }),\n  object({ MergeCoins: tuple([SuiArgument, array(SuiArgument)]) }),\n  object({\n    Publish: union([\n      // TODO: Remove this after 0.34 is released:\n      tuple([SuiMovePackage, array(ObjectId)]),\n      array(ObjectId),\n    ]),\n  }),\n  object({\n    Upgrade: union([\n      // TODO: Remove this after 0.34 is released:\n      tuple([SuiMovePackage, array(ObjectId), ObjectId, SuiArgument]),\n      tuple([array(ObjectId), ObjectId, SuiArgument]),\n    ]),\n  }),\n  object({ MakeMoveVec: tuple([nullable(string()), array(SuiArgument)]) }),\n]);\n\nexport const SuiCallArg = union([\n  object({\n    type: literal('pure'),\n    valueType: nullable(string()),\n    value: SuiJsonValue,\n  }),\n  object({\n    type: literal('object'),\n    objectType: literal('immOrOwnedObject'),\n    objectId: ObjectId,\n    version: SequenceNumber,\n    digest: ObjectDigest,\n  }),\n  object({\n    type: literal('object'),\n    objectType: literal('sharedObject'),\n    objectId: ObjectId,\n    initialSharedVersion: SequenceNumber,\n    mutable: boolean(),\n  }),\n]);\nexport type SuiCallArg = Infer<typeof SuiCallArg>;\n\nexport const ProgrammableTransaction = object({\n  transactions: array(SuiTransaction),\n  inputs: array(SuiCallArg),\n});\nexport type ProgrammableTransaction = Infer<typeof ProgrammableTransaction>;\nexport type SuiTransaction = Infer<typeof SuiTransaction>;\n\n/**\n * 1. WaitForEffectsCert: waits for TransactionEffectsCert and then returns to the client.\n *    This mode is a proxy for transaction finality.\n * 2. WaitForLocalExecution: waits for TransactionEffectsCert and makes sure the node\n *    executed the transaction locally before returning to the client. The local execution\n *    makes sure this node is aware of this transaction when the client fires subsequent queries.\n *    However, if the node fails to execute the transaction locally in a timely manner,\n *    a bool type in the response is set to false to indicate the case.\n */\nexport type ExecuteTransactionRequestType =\n  | 'WaitForEffectsCert'\n  | 'WaitForLocalExecution';\n\nexport type TransactionKindName =\n  | 'ChangeEpoch'\n  | 'ConsensusCommitPrologue'\n  | 'Genesis'\n  | 'ProgrammableTransaction';\n\nexport const SuiTransactionBlockKind = union([\n  assign(SuiChangeEpoch, object({ kind: literal('ChangeEpoch') })),\n  assign(\n    SuiConsensusCommitPrologue,\n    object({\n      kind: literal('ConsensusCommitPrologue'),\n    }),\n  ),\n  assign(Genesis, object({ kind: literal('Genesis') })),\n  assign(\n    ProgrammableTransaction,\n    object({ kind: literal('ProgrammableTransaction') }),\n  ),\n]);\nexport type SuiTransactionBlockKind = Infer<typeof SuiTransactionBlockKind>;\n\nexport const SuiTransactionBlockData = object({\n  // Eventually this will become union(literal('v1'), literal('v2'), ...)\n  messageVersion: literal('v1'),\n  transaction: SuiTransactionBlockKind,\n  sender: SuiAddress,\n  gasData: SuiGasData,\n});\nexport type SuiTransactionBlockData = Infer<typeof SuiTransactionBlockData>;\n\nexport const AuthoritySignature = string();\nexport const GenericAuthoritySignature = union([\n  AuthoritySignature,\n  array(AuthoritySignature),\n]);\n\nexport const AuthorityQuorumSignInfo = object({\n  epoch: EpochId,\n  signature: GenericAuthoritySignature,\n  signers_map: array(number()),\n});\nexport type AuthorityQuorumSignInfo = Infer<typeof AuthorityQuorumSignInfo>;\n\nexport const GasCostSummary = object({\n  computationCost: string(),\n  storageCost: string(),\n  storageRebate: string(),\n  nonRefundableStorageFee: string(),\n});\nexport type GasCostSummary = Infer<typeof GasCostSummary>;\n\nexport const ExecutionStatusType = union([\n  literal('success'),\n  literal('failure'),\n]);\nexport type ExecutionStatusType = Infer<typeof ExecutionStatusType>;\n\nexport const ExecutionStatus = object({\n  status: ExecutionStatusType,\n  error: optional(string()),\n});\nexport type ExecutionStatus = Infer<typeof ExecutionStatus>;\n\nexport const OwnedObjectRef = object({\n  owner: ObjectOwner,\n  reference: SuiObjectRef,\n});\nexport type OwnedObjectRef = Infer<typeof OwnedObjectRef>;\nexport const TransactionEffectsModifiedAtVersions = object({\n  objectId: ObjectId,\n  sequenceNumber: SequenceNumber,\n});\n\nexport const TransactionEffects = object({\n  // Eventually this will become union(literal('v1'), literal('v2'), ...)\n  messageVersion: literal('v1'),\n\n  /** The status of the execution */\n  status: ExecutionStatus,\n  /** The epoch when this transaction was executed */\n  executedEpoch: EpochId,\n  /** The version that every modified (mutated or deleted) object had before it was modified by this transaction. **/\n  modifiedAtVersions: optional(array(TransactionEffectsModifiedAtVersions)),\n  gasUsed: GasCostSummary,\n  /** The object references of the shared objects used in this transaction. Empty if no shared objects were used. */\n  sharedObjects: optional(array(SuiObjectRef)),\n  /** The transaction digest */\n  transactionDigest: TransactionDigest,\n  /** ObjectRef and owner of new objects created */\n  created: optional(array(OwnedObjectRef)),\n  /** ObjectRef and owner of mutated objects, including gas object */\n  mutated: optional(array(OwnedObjectRef)),\n  /**\n   * ObjectRef and owner of objects that are unwrapped in this transaction.\n   * Unwrapped objects are objects that were wrapped into other objects in the past,\n   * and just got extracted out.\n   */\n  unwrapped: optional(array(OwnedObjectRef)),\n  /** Object Refs of objects now deleted (the old refs) */\n  deleted: optional(array(SuiObjectRef)),\n  /** Object Refs of objects now deleted (the old refs) */\n  unwrappedThenDeleted: optional(array(SuiObjectRef)),\n  /** Object refs of objects now wrapped in other objects */\n  wrapped: optional(array(SuiObjectRef)),\n  /**\n   * The updated gas object reference. Have a dedicated field for convenient access.\n   * It's also included in mutated.\n   */\n  gasObject: OwnedObjectRef,\n  /** The events emitted during execution. Note that only successful transactions emit events */\n  eventsDigest: optional(TransactionEventDigest),\n  /** The set of transaction digests this transaction depends on */\n  dependencies: optional(array(TransactionDigest)),\n});\nexport type TransactionEffects = Infer<typeof TransactionEffects>;\n\nexport const TransactionEvents = array(SuiEvent);\nexport type TransactionEvents = Infer<typeof TransactionEvents>;\n\nconst ReturnValueType = tuple([array(number()), string()]);\nconst MutableReferenceOutputType = tuple([\n  SuiArgument,\n  array(number()),\n  string(),\n]);\nconst ExecutionResultType = object({\n  mutableReferenceOutputs: optional(array(MutableReferenceOutputType)),\n  returnValues: optional(array(ReturnValueType)),\n});\n\nexport const DevInspectResults = object({\n  effects: TransactionEffects,\n  events: TransactionEvents,\n  results: optional(array(ExecutionResultType)),\n  error: optional(string()),\n});\nexport type DevInspectResults = Infer<typeof DevInspectResults>;\n\nexport type SuiTransactionBlockResponseQuery = {\n  filter?: TransactionFilter;\n  options?: SuiTransactionBlockResponseOptions;\n};\n\nexport type TransactionFilter =\n  | { Checkpoint: string }\n  | { FromAndToAddress: { from: string; to: string } }\n  | { TransactionKind: string }\n  | {\n      MoveFunction: {\n        package: ObjectId;\n        module: string | null;\n        function: string | null;\n      };\n    }\n  | { InputObject: ObjectId }\n  | { ChangedObject: ObjectId }\n  | { FromAddress: SuiAddress }\n  | { ToAddress: SuiAddress };\n\nexport type EmptySignInfo = object;\nexport type AuthorityName = Infer<typeof AuthorityName>;\nexport const AuthorityName = string();\n\nexport const SuiTransactionBlock = object({\n  data: SuiTransactionBlockData,\n  txSignatures: array(string()),\n});\nexport type SuiTransactionBlock = Infer<typeof SuiTransactionBlock>;\n\nexport const SuiObjectChangePublished = object({\n  type: literal('published'),\n  packageId: ObjectId,\n  version: SequenceNumber,\n  digest: ObjectDigest,\n  modules: array(string()),\n});\nexport type SuiObjectChangePublished = Infer<typeof SuiObjectChangePublished>;\n\nexport const SuiObjectChangeTransferred = object({\n  type: literal('transferred'),\n  sender: SuiAddress,\n  recipient: ObjectOwner,\n  objectType: string(),\n  objectId: ObjectId,\n  version: SequenceNumber,\n  digest: ObjectDigest,\n});\nexport type SuiObjectChangeTransferred = Infer<\n  typeof SuiObjectChangeTransferred\n>;\n\nexport const SuiObjectChangeMutated = object({\n  type: literal('mutated'),\n  sender: SuiAddress,\n  owner: ObjectOwner,\n  objectType: string(),\n  objectId: ObjectId,\n  version: SequenceNumber,\n  previousVersion: SequenceNumber,\n  digest: ObjectDigest,\n});\nexport type SuiObjectChangeMutated = Infer<typeof SuiObjectChangeMutated>;\n\nexport const SuiObjectChangeDeleted = object({\n  type: literal('deleted'),\n  sender: SuiAddress,\n  objectType: string(),\n  objectId: ObjectId,\n  version: SequenceNumber,\n});\nexport type SuiObjectChangeDeleted = Infer<typeof SuiObjectChangeDeleted>;\n\nexport const SuiObjectChangeWrapped = object({\n  type: literal('wrapped'),\n  sender: SuiAddress,\n  objectType: string(),\n  objectId: ObjectId,\n  version: SequenceNumber,\n});\nexport type SuiObjectChangeWrapped = Infer<typeof SuiObjectChangeWrapped>;\n\nexport const SuiObjectChangeCreated = object({\n  type: literal('created'),\n  sender: SuiAddress,\n  owner: ObjectOwner,\n  objectType: string(),\n  objectId: ObjectId,\n  version: SequenceNumber,\n  digest: ObjectDigest,\n});\nexport type SuiObjectChangeCreated = Infer<typeof SuiObjectChangeCreated>;\n\nexport const SuiObjectChange = union([\n  SuiObjectChangePublished,\n  SuiObjectChangeTransferred,\n  SuiObjectChangeMutated,\n  SuiObjectChangeDeleted,\n  SuiObjectChangeWrapped,\n  SuiObjectChangeCreated,\n]);\nexport type SuiObjectChange = Infer<typeof SuiObjectChange>;\n\nexport const BalanceChange = object({\n  owner: ObjectOwner,\n  coinType: string(),\n  /* Coin balance change(positive means receive, negative means send) */\n  amount: string(),\n});\n\nexport const SuiTransactionBlockResponse = object({\n  digest: TransactionDigest,\n  transaction: optional(SuiTransactionBlock),\n  effects: optional(TransactionEffects),\n  events: optional(TransactionEvents),\n  timestampMs: optional(string()),\n  checkpoint: optional(string()),\n  confirmedLocalExecution: optional(boolean()),\n  objectChanges: optional(array(SuiObjectChange)),\n  balanceChanges: optional(array(BalanceChange)),\n  /* Errors that occurred in fetching/serializing the transaction. */\n  errors: optional(array(string())),\n});\nexport type SuiTransactionBlockResponse = Infer<\n  typeof SuiTransactionBlockResponse\n>;\n\nexport const SuiTransactionBlockResponseOptions = object({\n  /* Whether to show transaction input data. Default to be false. */\n  showInput: optional(boolean()),\n  /* Whether to show transaction effects. Default to be false. */\n  showEffects: optional(boolean()),\n  /* Whether to show transaction events. Default to be false. */\n  showEvents: optional(boolean()),\n  /* Whether to show object changes. Default to be false. */\n  showObjectChanges: optional(boolean()),\n  /* Whether to show coin balance changes. Default to be false. */\n  showBalanceChanges: optional(boolean()),\n});\n\nexport type SuiTransactionBlockResponseOptions = Infer<\n  typeof SuiTransactionBlockResponseOptions\n>;\n\nexport const PaginatedTransactionResponse = object({\n  data: array(SuiTransactionBlockResponse),\n  nextCursor: nullable(TransactionDigest),\n  hasNextPage: boolean(),\n});\nexport type PaginatedTransactionResponse = Infer<\n  typeof PaginatedTransactionResponse\n>;\nexport const DryRunTransactionBlockResponse = object({\n  effects: TransactionEffects,\n  events: TransactionEvents,\n  objectChanges: array(SuiObjectChange),\n  balanceChanges: array(BalanceChange),\n  // TODO: Remove optional when this is rolled out to all networks:\n  input: optional(SuiTransactionBlockData),\n});\nexport type DryRunTransactionBlockResponse = Infer<\n  typeof DryRunTransactionBlockResponse\n>;\n\n/* -------------------------------------------------------------------------- */\n/*                              Helper functions                              */\n/* -------------------------------------------------------------------------- */\n\nexport function getTransaction(\n  tx: SuiTransactionBlockResponse,\n): SuiTransactionBlock | undefined {\n  return tx.transaction;\n}\n\nexport function getTransactionDigest(\n  tx: SuiTransactionBlockResponse,\n): TransactionDigest {\n  return tx.digest;\n}\n\nexport function getTransactionSignature(\n  tx: SuiTransactionBlockResponse,\n): string[] | undefined {\n  return tx.transaction?.txSignatures;\n}\n\n/* ----------------------------- TransactionData ---------------------------- */\n\nexport function getTransactionSender(\n  tx: SuiTransactionBlockResponse,\n): SuiAddress | undefined {\n  return tx.transaction?.data.sender;\n}\n\nexport function getGasData(\n  tx: SuiTransactionBlockResponse,\n): SuiGasData | undefined {\n  return tx.transaction?.data.gasData;\n}\n\nexport function getTransactionGasObject(\n  tx: SuiTransactionBlockResponse,\n): SuiObjectRef[] | undefined {\n  return getGasData(tx)?.payment;\n}\n\nexport function getTransactionGasPrice(tx: SuiTransactionBlockResponse) {\n  return getGasData(tx)?.price;\n}\n\nexport function getTransactionGasBudget(tx: SuiTransactionBlockResponse) {\n  return getGasData(tx)?.budget;\n}\n\nexport function getChangeEpochTransaction(\n  data: SuiTransactionBlockKind,\n): SuiChangeEpoch | undefined {\n  return data.kind === 'ChangeEpoch' ? data : undefined;\n}\n\nexport function getConsensusCommitPrologueTransaction(\n  data: SuiTransactionBlockKind,\n): SuiConsensusCommitPrologue | undefined {\n  return data.kind === 'ConsensusCommitPrologue' ? data : undefined;\n}\n\nexport function getTransactionKind(\n  data: SuiTransactionBlockResponse,\n): SuiTransactionBlockKind | undefined {\n  return data.transaction?.data.transaction;\n}\n\nexport function getTransactionKindName(\n  data: SuiTransactionBlockKind,\n): TransactionKindName {\n  return data.kind;\n}\n\nexport function getProgrammableTransaction(\n  data: SuiTransactionBlockKind,\n): ProgrammableTransaction | undefined {\n  return data.kind === 'ProgrammableTransaction' ? data : undefined;\n}\n\n/* ----------------------------- ExecutionStatus ---------------------------- */\n\nexport function getExecutionStatusType(\n  data: SuiTransactionBlockResponse,\n): ExecutionStatusType | undefined {\n  return getExecutionStatus(data)?.status;\n}\n\nexport function getExecutionStatus(\n  data: SuiTransactionBlockResponse,\n): ExecutionStatus | undefined {\n  return getTransactionEffects(data)?.status;\n}\n\nexport function getExecutionStatusError(\n  data: SuiTransactionBlockResponse,\n): string | undefined {\n  return getExecutionStatus(data)?.error;\n}\n\nexport function getExecutionStatusGasSummary(\n  data: SuiTransactionBlockResponse | TransactionEffects,\n): GasCostSummary | undefined {\n  if (is(data, TransactionEffects)) {\n    return data.gasUsed;\n  }\n  return getTransactionEffects(data)?.gasUsed;\n}\n\nexport function getTotalGasUsed(\n  data: SuiTransactionBlockResponse | TransactionEffects,\n): bigint | undefined {\n  const gasSummary = getExecutionStatusGasSummary(data);\n  return gasSummary\n    ? BigInt(gasSummary.computationCost) +\n        BigInt(gasSummary.storageCost) -\n        BigInt(gasSummary.storageRebate)\n    : undefined;\n}\n\nexport function getTotalGasUsedUpperBound(\n  data: SuiTransactionBlockResponse | TransactionEffects,\n): bigint | undefined {\n  const gasSummary = getExecutionStatusGasSummary(data);\n  return gasSummary\n    ? BigInt(gasSummary.computationCost) + BigInt(gasSummary.storageCost)\n    : undefined;\n}\n\nexport function getTransactionEffects(\n  data: SuiTransactionBlockResponse,\n): TransactionEffects | undefined {\n  return data.effects;\n}\n\n/* ---------------------------- Transaction Effects --------------------------- */\n\nexport function getEvents(\n  data: SuiTransactionBlockResponse,\n): SuiEvent[] | undefined {\n  return data.events;\n}\n\nexport function getCreatedObjects(\n  data: SuiTransactionBlockResponse,\n): OwnedObjectRef[] | undefined {\n  return getTransactionEffects(data)?.created;\n}\n\n/* --------------------------- TransactionResponse -------------------------- */\n\nexport function getTimestampFromTransactionResponse(\n  data: SuiTransactionBlockResponse,\n): string | undefined {\n  return data.timestampMs ?? undefined;\n}\n\n/**\n * Get the newly created coin refs after a split.\n */\nexport function getNewlyCreatedCoinRefsAfterSplit(\n  data: SuiTransactionBlockResponse,\n): SuiObjectRef[] | undefined {\n  return getTransactionEffects(data)?.created?.map((c) => c.reference);\n}\n\nexport function getObjectChanges(\n  data: SuiTransactionBlockResponse,\n): SuiObjectChange[] | undefined {\n  return data.objectChanges;\n}\n\nexport function getPublishedObjectChanges(\n  data: SuiTransactionBlockResponse,\n): SuiObjectChangePublished[] {\n  return (\n    (data.objectChanges?.filter((a) =>\n      is(a, SuiObjectChangePublished),\n    ) as SuiObjectChangePublished[]) ?? []\n  );\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nexport type Option<T> =\n  | T\n  | {\n      fields: {\n        vec: '';\n      };\n      type: string;\n    };\n\nexport function getOption<T>(option: Option<T>): T | undefined {\n  if (\n    typeof option === 'object' &&\n    option !== null &&\n    'type' in option &&\n    option.type.startsWith('0x1::option::Option<')\n  ) {\n    return undefined;\n  }\n  return option as T;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  getObjectFields,\n  SuiObjectResponse,\n  SuiMoveObject,\n  SuiObjectInfo,\n  SuiObjectData,\n  getObjectId,\n  getObjectType,\n} from '../types/objects';\nimport { normalizeSuiObjectId, ObjectId, SuiAddress } from '../types/common';\n\nimport { getOption, Option } from '../types/option';\nimport { CoinStruct } from '../types/coin';\nimport { StructTag } from '../types/sui-bcs';\nimport { Infer, nullable, number, object, string } from 'superstruct';\n\nexport const SUI_SYSTEM_ADDRESS = '0x3';\nexport const SUI_FRAMEWORK_ADDRESS = '0x2';\nexport const MOVE_STDLIB_ADDRESS = '0x1';\nexport const OBJECT_MODULE_NAME = 'object';\nexport const UID_STRUCT_NAME = 'UID';\nexport const ID_STRUCT_NAME = 'ID';\nexport const SUI_TYPE_ARG = `${SUI_FRAMEWORK_ADDRESS}::sui::SUI`;\nexport const VALIDATORS_EVENTS_QUERY =\n  '0x3::validator_set::ValidatorEpochInfoEventV2';\n\nexport const SUI_CLOCK_OBJECT_ID = normalizeSuiObjectId('0x6');\n\n// `sui::pay` module is used for Coin management (split, join, join_and_transfer etc);\nexport const PAY_MODULE_NAME = 'pay';\nexport const PAY_SPLIT_COIN_VEC_FUNC_NAME = 'split_vec';\nexport const PAY_JOIN_COIN_FUNC_NAME = 'join';\nexport const COIN_TYPE_ARG_REGEX = /^0x2::coin::Coin<(.+)>$/;\n\ntype ObjectData = ObjectDataFull | SuiObjectInfo;\ntype ObjectDataFull = SuiObjectResponse | SuiMoveObject;\n\nexport function isObjectDataFull(\n  resp: ObjectData | ObjectDataFull,\n): resp is SuiObjectResponse {\n  return !!(resp as SuiObjectResponse).data || !!(resp as SuiMoveObject).type;\n}\n\nexport const CoinMetadataStruct = object({\n  decimals: number(),\n  name: string(),\n  symbol: string(),\n  description: string(),\n  iconUrl: nullable(string()),\n  id: nullable(ObjectId),\n});\n\nexport type CoinMetadata = Infer<typeof CoinMetadataStruct>;\n\n/**\n * Utility class for 0x2::coin\n * as defined in https://github.com/MystenLabs/sui/blob/ca9046fd8b1a9e8634a4b74b0e7dabdc7ea54475/sui_programmability/framework/sources/Coin.move#L4\n */\nexport class Coin {\n  static isCoin(data: ObjectData): boolean {\n    return Coin.getType(data)?.match(COIN_TYPE_ARG_REGEX) != null;\n  }\n\n  static getCoinType(type: string) {\n    const [, res] = type.match(COIN_TYPE_ARG_REGEX) ?? [];\n    return res || null;\n  }\n\n  static getCoinTypeArg(obj: ObjectData) {\n    const type = Coin.getType(obj);\n    return type ? Coin.getCoinType(type) : null;\n  }\n\n  static isSUI(obj: ObjectData) {\n    const arg = Coin.getCoinTypeArg(obj);\n    return arg ? Coin.getCoinSymbol(arg) === 'SUI' : false;\n  }\n\n  static getCoinSymbol(coinTypeArg: string) {\n    return coinTypeArg.substring(coinTypeArg.lastIndexOf(':') + 1);\n  }\n\n  static getCoinStructTag(coinTypeArg: string): StructTag {\n    return {\n      address: normalizeSuiObjectId(coinTypeArg.split('::')[0]),\n      module: coinTypeArg.split('::')[1],\n      name: coinTypeArg.split('::')[2],\n      typeParams: [],\n    };\n  }\n\n  public static getID(obj: ObjectData): ObjectId {\n    if ('fields' in obj) {\n      return obj.fields.id.id;\n    }\n    return getObjectId(obj);\n  }\n\n  static totalBalance(coins: CoinStruct[]): bigint {\n    return coins.reduce(\n      (partialSum, c) => partialSum + Coin.getBalanceFromCoinStruct(c),\n      BigInt(0),\n    );\n  }\n\n  /**\n   * Sort coin by balance in an ascending order\n   */\n  static sortByBalance(coins: CoinStruct[]): CoinStruct[] {\n    return [...coins].sort((a, b) =>\n      Coin.getBalanceFromCoinStruct(a) < Coin.getBalanceFromCoinStruct(b)\n        ? -1\n        : Coin.getBalanceFromCoinStruct(a) > Coin.getBalanceFromCoinStruct(b)\n        ? 1\n        : 0,\n    );\n  }\n\n  static getBalanceFromCoinStruct(coin: CoinStruct): bigint {\n    return BigInt(coin.balance);\n  }\n\n  static getBalance(data: ObjectDataFull): bigint | undefined {\n    if (!Coin.isCoin(data)) {\n      return undefined;\n    }\n    const balance = getObjectFields(data)?.balance;\n    return BigInt(balance);\n  }\n\n  private static getType(data: ObjectData): string | undefined {\n    if (isObjectDataFull(data)) {\n      return getObjectType(data);\n    }\n    return data.type;\n  }\n}\n\nexport type DelegationData = SuiMoveObject & {\n  dataType: 'moveObject';\n  type: '0x2::delegation::Delegation';\n  fields: {\n    active_delegation: Option<number>;\n    delegate_amount: number;\n    next_reward_unclaimed_epoch: number;\n    validator_address: SuiAddress;\n    info: {\n      id: string;\n      version: number;\n    };\n    // TODO (jian): clean up after 0.34\n    coin_locked_until_epoch: Option<SuiMoveObject>;\n    ending_epoch: Option<number>;\n  };\n};\n\nexport type DelegationSuiObject = Omit<SuiObjectData, 'data'> & {\n  data: DelegationData;\n};\n\n// Class for delegation.move\n// see https://github.com/MystenLabs/fastnft/blob/161aa27fe7eb8ecf2866ec9eb192e768f25da768/crates/sui-framework/sources/governance/delegation.move\nexport class Delegation {\n  public static readonly SUI_OBJECT_TYPE = '0x2::delegation::Delegation';\n  private suiObject: DelegationSuiObject;\n\n  public static isDelegationSuiObject(\n    obj: SuiObjectData,\n  ): obj is DelegationSuiObject {\n    return 'type' in obj && obj.type === Delegation.SUI_OBJECT_TYPE;\n  }\n\n  constructor(obj: DelegationSuiObject) {\n    this.suiObject = obj;\n  }\n\n  public nextRewardUnclaimedEpoch() {\n    return this.suiObject.data.fields.next_reward_unclaimed_epoch;\n  }\n\n  public activeDelegation() {\n    return BigInt(getOption(this.suiObject.data.fields.active_delegation) || 0);\n  }\n\n  public delegateAmount() {\n    return this.suiObject.data.fields.delegate_amount;\n  }\n\n  public endingEpoch() {\n    return getOption(this.suiObject.data.fields.ending_epoch);\n  }\n\n  public validatorAddress() {\n    return this.suiObject.data.fields.validator_address;\n  }\n\n  public isActive() {\n    return this.activeDelegation() > 0 && !this.endingEpoch();\n  }\n\n  public hasUnclaimedRewards(epoch: number) {\n    return (\n      this.nextRewardUnclaimedEpoch() <= epoch &&\n      (this.isActive() || (this.endingEpoch() || 0) > epoch)\n    );\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  BCS,\n  EnumTypeDefinition,\n  getSuiMoveConfig,\n  StructTypeDefinition,\n} from '@mysten/bcs';\nimport { SuiObjectRef } from './objects';\n\n/**\n * A reference to a shared object.\n */\nexport type SharedObjectRef = {\n  /** Hex code as string representing the object id */\n  objectId: string;\n\n  /** The version the object was shared at */\n  initialSharedVersion: number | string;\n\n  /** Whether reference is mutable */\n  mutable: boolean;\n};\n\n/**\n * An object argument.\n */\nexport type ObjectArg =\n  | { ImmOrOwned: SuiObjectRef }\n  | { Shared: SharedObjectRef };\n\n/**\n * A pure argument.\n */\nexport type PureArg = { Pure: ArrayLike<number> };\n\nexport function isPureArg(arg: any): arg is PureArg {\n  return (arg as PureArg).Pure !== undefined;\n}\n\n/**\n * An argument for the transaction. It is a 'meant' enum which expects to have\n * one of the optional properties. If not, the BCS error will be thrown while\n * attempting to form a transaction.\n *\n * Example:\n * ```js\n * let arg1: CallArg = { Object: { Shared: {\n *   objectId: '5460cf92b5e3e7067aaace60d88324095fd22944',\n *   initialSharedVersion: 1,\n *   mutable: true,\n * } } };\n * let arg2: CallArg = { Pure: bcs.ser(BCS.STRING, 100000).toBytes() };\n * let arg3: CallArg = { Object: { ImmOrOwned: {\n *   objectId: '4047d2e25211d87922b6650233bd0503a6734279',\n *   version: 1,\n *   digest: 'bCiANCht4O9MEUhuYjdRCqRPZjr2rJ8MfqNiwyhmRgA='\n * } } };\n * ```\n *\n * For `Pure` arguments BCS is required. You must encode the values with BCS according\n * to the type required by the called function. Pure accepts only serialized values\n */\nexport type CallArg = PureArg | { Object: ObjectArg };\n\n/**\n * Kind of a TypeTag which is represented by a Move type identifier.\n */\nexport type StructTag = {\n  address: string;\n  module: string;\n  name: string;\n  typeParams: TypeTag[];\n};\n\n/**\n * Sui TypeTag object. A decoupled `0x...::module::Type<???>` parameter.\n */\nexport type TypeTag =\n  | { bool: null }\n  | { u8: null }\n  | { u64: null }\n  | { u128: null }\n  | { address: null }\n  | { signer: null }\n  | { vector: TypeTag }\n  | { struct: StructTag }\n  | { u16: null }\n  | { u32: null }\n  | { u256: null };\n\n// ========== TransactionData ===========\n\n/**\n * The GasData to be used in the transaction.\n */\nexport type GasData = {\n  payment: SuiObjectRef[];\n  owner: string; // Gas Object's owner\n  price: number;\n  budget: number;\n};\n\n/**\n * TransactionExpiration\n *\n * Indications the expiration time for a transaction.\n */\nexport type TransactionExpiration = { None: null } | { Epoch: number };\n\n// Move name of the Vector type.\nconst VECTOR = 'vector';\n\n// Imported to explicitly tell typescript that types match\ntype TypeSchema = {\n  structs?: { [key: string]: StructTypeDefinition };\n  enums?: { [key: string]: EnumTypeDefinition };\n  aliases?: { [key: string]: string };\n};\n\nconst TransactionDataV1 = {\n  kind: 'TransactionKind',\n  sender: BCS.ADDRESS,\n  gasData: 'GasData',\n  expiration: 'TransactionExpiration',\n};\n\nconst BCS_SPEC: TypeSchema = {\n  enums: {\n    'Option<T>': {\n      None: null,\n      Some: 'T',\n    },\n    ObjectArg: {\n      ImmOrOwned: 'SuiObjectRef',\n      Shared: 'SharedObjectRef',\n    },\n    CallArg: {\n      Pure: [VECTOR, BCS.U8],\n      Object: 'ObjectArg',\n      ObjVec: [VECTOR, 'ObjectArg'],\n    },\n    TypeTag: {\n      bool: null,\n      u8: null,\n      u64: null,\n      u128: null,\n      address: null,\n      signer: null,\n      vector: 'TypeTag',\n      struct: 'StructTag',\n      u16: null,\n      u32: null,\n      u256: null,\n    },\n    TransactionKind: {\n      // can not be called from sui.js; dummy placement\n      // to set the enum counter right for ProgrammableTransact\n      ProgrammableTransaction: 'ProgrammableTransaction',\n      ChangeEpoch: null,\n      Genesis: null,\n      ConsensusCommitPrologue: null,\n    },\n    TransactionExpiration: {\n      None: null,\n      Epoch: BCS.U64,\n    },\n    TransactionData: {\n      V1: 'TransactionDataV1',\n    },\n  },\n  structs: {\n    SuiObjectRef: {\n      objectId: BCS.ADDRESS,\n      version: BCS.U64,\n      digest: 'ObjectDigest',\n    },\n    SharedObjectRef: {\n      objectId: BCS.ADDRESS,\n      initialSharedVersion: BCS.U64,\n      mutable: BCS.BOOL,\n    },\n    StructTag: {\n      address: BCS.ADDRESS,\n      module: BCS.STRING,\n      name: BCS.STRING,\n      typeParams: [VECTOR, 'TypeTag'],\n    },\n    GasData: {\n      payment: [VECTOR, 'SuiObjectRef'],\n      owner: BCS.ADDRESS,\n      price: BCS.U64,\n      budget: BCS.U64,\n    },\n    // Signed transaction data needed to generate transaction digest.\n    SenderSignedData: {\n      data: 'TransactionData',\n      txSignatures: [VECTOR, [VECTOR, BCS.U8]],\n    },\n    TransactionDataV1,\n  },\n  aliases: {\n    ObjectDigest: BCS.BASE58,\n  },\n};\n\nconst bcs = new BCS({ ...getSuiMoveConfig(), types: BCS_SPEC });\n\nbcs.registerType(\n  'utf8string',\n  (writer, str) => {\n    const bytes = Array.from(new TextEncoder().encode(str));\n    return writer.writeVec(bytes, (writer, el) => writer.write8(el));\n  },\n  (reader) => {\n    let bytes = reader.readVec((reader) => reader.read8());\n    return new TextDecoder().decode(new Uint8Array(bytes));\n  },\n);\n\nexport { bcs };\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { array, nullable, number, object, Infer, string } from 'superstruct';\nimport { TransactionDigest, ObjectId } from './common';\n\nexport const FaucetCoinInfo = object({\n  amount: number(),\n  id: ObjectId,\n  transferTxDigest: TransactionDigest,\n});\n\nexport type FaucetCoinInfo = Infer<typeof FaucetCoinInfo>;\n\nexport const FaucetResponse = object({\n  transferredGasObjects: array(FaucetCoinInfo),\n  error: nullable(string()),\n});\n\nexport type FaucetResponse = Infer<typeof FaucetResponse>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  array,\n  Infer,\n  object,\n  string,\n  union,\n  boolean,\n  define,\n  number,\n  literal,\n  record,\n  is,\n  tuple,\n} from 'superstruct';\n\nexport type SuiMoveFunctionArgTypesResponse = Infer<\n  typeof SuiMoveFunctionArgType\n>[];\n\nexport const SuiMoveFunctionArgType = union([\n  string(),\n  object({ Object: string() }),\n]);\n\nexport const SuiMoveFunctionArgTypes = array(SuiMoveFunctionArgType);\nexport type SuiMoveFunctionArgTypes = Infer<typeof SuiMoveFunctionArgTypes>;\n\nexport const SuiMoveModuleId = object({\n  address: string(),\n  name: string(),\n});\nexport type SuiMoveModuleId = Infer<typeof SuiMoveModuleId>;\n\nexport const SuiMoveVisibility = union([\n  literal('Private'),\n  literal('Public'),\n  literal('Friend'),\n]);\nexport type SuiMoveVisibility = Infer<typeof SuiMoveVisibility>;\n\nexport const SuiMoveAbilitySet = object({\n  abilities: array(string()),\n});\nexport type SuiMoveAbilitySet = Infer<typeof SuiMoveAbilitySet>;\n\nexport const SuiMoveStructTypeParameter = object({\n  constraints: SuiMoveAbilitySet,\n  isPhantom: boolean(),\n});\nexport type SuiMoveStructTypeParameter = Infer<\n  typeof SuiMoveStructTypeParameter\n>;\n\nexport const SuiMoveNormalizedTypeParameterType = object({\n  TypeParameter: number(),\n});\nexport type SuiMoveNormalizedTypeParameterType = Infer<\n  typeof SuiMoveNormalizedTypeParameterType\n>;\n\nexport type SuiMoveNormalizedType =\n  | string\n  | SuiMoveNormalizedTypeParameterType\n  | { Reference: SuiMoveNormalizedType }\n  | { MutableReference: SuiMoveNormalizedType }\n  | { Vector: SuiMoveNormalizedType }\n  | SuiMoveNormalizedStructType;\n\nexport const MoveCallMetric = tuple([\n  object({\n    module: string(),\n    package: string(),\n    function: string(),\n  }),\n  string(),\n]);\n\nexport type MoveCallMetric = Infer<typeof MoveCallMetric>;\n\nexport const MoveCallMetrics = object({\n  rank3Days: array(MoveCallMetric),\n  rank7Days: array(MoveCallMetric),\n  rank30Days: array(MoveCallMetric),\n});\n\nexport type MoveCallMetrics = Infer<typeof MoveCallMetrics>;\n\nfunction isSuiMoveNormalizedType(\n  value: unknown,\n): value is SuiMoveNormalizedType {\n  if (!value) return false;\n  if (typeof value === 'string') return true;\n  if (is(value, SuiMoveNormalizedTypeParameterType)) return true;\n  if (isSuiMoveNormalizedStructType(value)) return true;\n  if (typeof value !== 'object') return false;\n\n  const valueProperties = value as Record<string, unknown>;\n  if (is(valueProperties.Reference, SuiMoveNormalizedType)) return true;\n  if (is(valueProperties.MutableReference, SuiMoveNormalizedType)) return true;\n  if (is(valueProperties.Vector, SuiMoveNormalizedType)) return true;\n  return false;\n}\n\nexport const SuiMoveNormalizedType = define<SuiMoveNormalizedType>(\n  'SuiMoveNormalizedType',\n  isSuiMoveNormalizedType,\n);\n\nexport type SuiMoveNormalizedStructType = {\n  Struct: {\n    address: string;\n    module: string;\n    name: string;\n    typeArguments: SuiMoveNormalizedType[];\n  };\n};\n\nfunction isSuiMoveNormalizedStructType(\n  value: unknown,\n): value is SuiMoveNormalizedStructType {\n  if (!value || typeof value !== 'object') return false;\n\n  const valueProperties = value as Record<string, unknown>;\n  if (!valueProperties.Struct || typeof valueProperties.Struct !== 'object')\n    return false;\n\n  const structProperties = valueProperties.Struct as Record<string, unknown>;\n  if (\n    typeof structProperties.address !== 'string' ||\n    typeof structProperties.module !== 'string' ||\n    typeof structProperties.name !== 'string' ||\n    !Array.isArray(structProperties.typeArguments) ||\n    !structProperties.typeArguments.every((value) =>\n      isSuiMoveNormalizedType(value),\n    )\n  ) {\n    return false;\n  }\n\n  return true;\n}\n\n// NOTE: This type is recursive, so we need to manually implement it:\nexport const SuiMoveNormalizedStructType = define<SuiMoveNormalizedStructType>(\n  'SuiMoveNormalizedStructType',\n  isSuiMoveNormalizedStructType,\n);\n\nexport const SuiMoveNormalizedFunction = object({\n  visibility: SuiMoveVisibility,\n  isEntry: boolean(),\n  typeParameters: array(SuiMoveAbilitySet),\n  parameters: array(SuiMoveNormalizedType),\n  return: array(SuiMoveNormalizedType),\n});\nexport type SuiMoveNormalizedFunction = Infer<typeof SuiMoveNormalizedFunction>;\n\nexport const SuiMoveNormalizedField = object({\n  name: string(),\n  type: SuiMoveNormalizedType,\n});\nexport type SuiMoveNormalizedField = Infer<typeof SuiMoveNormalizedField>;\n\nexport const SuiMoveNormalizedStruct = object({\n  abilities: SuiMoveAbilitySet,\n  typeParameters: array(SuiMoveStructTypeParameter),\n  fields: array(SuiMoveNormalizedField),\n});\nexport type SuiMoveNormalizedStruct = Infer<typeof SuiMoveNormalizedStruct>;\n\nexport const SuiMoveNormalizedModule = object({\n  fileFormatVersion: number(),\n  address: string(),\n  name: string(),\n  friends: array(SuiMoveModuleId),\n  structs: record(string(), SuiMoveNormalizedStruct),\n  exposedFunctions: record(string(), SuiMoveNormalizedFunction),\n});\nexport type SuiMoveNormalizedModule = Infer<typeof SuiMoveNormalizedModule>;\n\nexport const SuiMoveNormalizedModules = record(\n  string(),\n  SuiMoveNormalizedModule,\n);\nexport type SuiMoveNormalizedModules = Infer<typeof SuiMoveNormalizedModules>;\n\nexport function extractMutableReference(\n  normalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n  return typeof normalizedType === 'object' &&\n    'MutableReference' in normalizedType\n    ? normalizedType.MutableReference\n    : undefined;\n}\n\nexport function extractReference(\n  normalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedType | undefined {\n  return typeof normalizedType === 'object' && 'Reference' in normalizedType\n    ? normalizedType.Reference\n    : undefined;\n}\n\nexport function extractStructTag(\n  normalizedType: SuiMoveNormalizedType,\n): SuiMoveNormalizedStructType | undefined {\n  if (typeof normalizedType === 'object' && 'Struct' in normalizedType) {\n    return normalizedType;\n  }\n\n  const ref = extractReference(normalizedType);\n  const mutRef = extractMutableReference(normalizedType);\n\n  if (typeof ref === 'object' && 'Struct' in ref) {\n    return ref;\n  }\n\n  if (typeof mutRef === 'object' && 'Struct' in mutRef) {\n    return mutRef;\n  }\n  return undefined;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  array,\n  boolean,\n  literal,\n  number,\n  object,\n  string,\n  union,\n  Infer,\n  nullable,\n  tuple,\n  optional,\n} from 'superstruct';\nimport { ObjectId, SuiAddress } from './common';\nimport { AuthorityName, EpochId } from './transactions';\n\n/* -------------- Types for the SuiSystemState Rust definition -------------- */\n\nexport type DelegatedStake = Infer<typeof DelegatedStake>;\nexport type CommitteeInfo = Infer<typeof CommitteeInfo>;\nexport type StakeObject = Infer<typeof StakeObject>;\n\n// APY Response\nexport const Apy = object({\n  apy: number(),\n  address: SuiAddress,\n});\n\nexport const ValidatorsApy = object({\n  epoch: string(),\n  apys: array(Apy),\n});\n\nexport type ValidatorsApy = Infer<typeof ValidatorsApy>;\n\n// Staking\nexport const Balance = object({\n  value: number(),\n});\n\nexport const StakeObject = object({\n  stakedSuiId: ObjectId,\n  stakeRequestEpoch: EpochId,\n  stakeActiveEpoch: EpochId,\n  principal: string(),\n  status: union([literal('Active'), literal('Pending'), literal('Unstaked')]),\n  estimatedReward: optional(string()),\n});\n\nexport const DelegatedStake = object({\n  validatorAddress: SuiAddress,\n  stakingPool: ObjectId,\n  stakes: array(StakeObject),\n});\n\nexport const StakeSubsidyFields = object({\n  balance: object({ value: number() }),\n  distribution_counter: number(),\n  current_distribution_amount: number(),\n  stake_subsidy_period_length: number(),\n  stake_subsidy_decrease_rate: number(),\n});\n\nexport const StakeSubsidy = object({\n  type: string(),\n  fields: StakeSubsidyFields,\n});\n\nexport const SuiSupplyFields = object({\n  value: number(),\n});\n\nexport const ContentsFields = object({\n  id: string(),\n  size: number(),\n  head: object({ vec: array() }),\n  tail: object({ vec: array() }),\n});\n\nexport const ContentsFieldsWithdraw = object({\n  id: string(),\n  size: number(),\n});\n\nexport const Contents = object({\n  type: string(),\n  fields: ContentsFields,\n});\n\nexport const DelegationStakingPoolFields = object({\n  exchangeRates: object({\n    id: string(),\n    size: number(),\n  }),\n  id: string(),\n  pendingStake: number(),\n  pendingPoolTokenWithdraw: number(),\n  pendingTotalSuiWithdraw: number(),\n  poolTokenBalance: number(),\n  rewardsPool: object({ value: number() }),\n  activationEpoch: object({ vec: array() }),\n  deactivationEpoch: object({ vec: array() }),\n  suiBalance: number(),\n});\n\nexport const DelegationStakingPool = object({\n  type: string(),\n  fields: DelegationStakingPoolFields,\n});\n\nexport const Validators = array(tuple([AuthorityName, string()]));\n\nexport const CommitteeInfo = object({\n  epoch: EpochId,\n  /** Array of (validator public key, stake unit) tuple */\n  validators: Validators,\n});\n\nexport const SuiValidatorSummary = object({\n  suiAddress: SuiAddress,\n  protocolPubkeyBytes: string(),\n  networkPubkeyBytes: string(),\n  workerPubkeyBytes: string(),\n  proofOfPossessionBytes: string(),\n  operationCapId: string(),\n  name: string(),\n  description: string(),\n  imageUrl: string(),\n  projectUrl: string(),\n  p2pAddress: string(),\n  netAddress: string(),\n  primaryAddress: string(),\n  workerAddress: string(),\n  nextEpochProtocolPubkeyBytes: nullable(string()),\n  nextEpochProofOfPossession: nullable(string()),\n  nextEpochNetworkPubkeyBytes: nullable(string()),\n  nextEpochWorkerPubkeyBytes: nullable(string()),\n  nextEpochNetAddress: nullable(string()),\n  nextEpochP2pAddress: nullable(string()),\n  nextEpochPrimaryAddress: nullable(string()),\n  nextEpochWorkerAddress: nullable(string()),\n  votingPower: string(),\n  gasPrice: string(),\n  commissionRate: string(),\n  nextEpochStake: string(),\n  nextEpochGasPrice: string(),\n  nextEpochCommissionRate: string(),\n  stakingPoolId: string(),\n  stakingPoolActivationEpoch: nullable(string()),\n  stakingPoolDeactivationEpoch: nullable(string()),\n  stakingPoolSuiBalance: string(),\n  rewardsPool: string(),\n  poolTokenBalance: string(),\n  pendingStake: string(),\n  pendingPoolTokenWithdraw: string(),\n  pendingTotalSuiWithdraw: string(),\n  exchangeRatesId: string(),\n  exchangeRatesSize: string(),\n});\n\nexport type SuiValidatorSummary = Infer<typeof SuiValidatorSummary>;\n\nexport const SuiSystemStateSummary = object({\n  epoch: string(),\n  protocolVersion: string(),\n  systemStateVersion: string(),\n  storageFundTotalObjectStorageRebates: string(),\n  storageFundNonRefundableBalance: string(),\n  referenceGasPrice: string(),\n  safeMode: boolean(),\n  safeModeStorageRewards: string(),\n  safeModeComputationRewards: string(),\n  safeModeStorageRebates: string(),\n  safeModeNonRefundableStorageFee: string(),\n  epochStartTimestampMs: string(),\n  epochDurationMs: string(),\n  stakeSubsidyStartEpoch: string(),\n  maxValidatorCount: string(),\n  minValidatorJoiningStake: string(),\n  validatorLowStakeThreshold: string(),\n  validatorVeryLowStakeThreshold: string(),\n  validatorLowStakeGracePeriod: string(),\n  stakeSubsidyBalance: string(),\n  stakeSubsidyDistributionCounter: string(),\n  stakeSubsidyCurrentDistributionAmount: string(),\n  stakeSubsidyPeriodLength: string(),\n  stakeSubsidyDecreaseRate: number(),\n  totalStake: string(),\n  activeValidators: array(SuiValidatorSummary),\n  pendingActiveValidatorsId: string(),\n  pendingActiveValidatorsSize: string(),\n  pendingRemovals: array(string()),\n  stakingPoolMappingsId: string(),\n  stakingPoolMappingsSize: string(),\n  inactivePoolsId: string(),\n  inactivePoolsSize: string(),\n  validatorCandidatesId: string(),\n  validatorCandidatesSize: string(),\n  atRiskValidators: array(tuple([SuiAddress, string()])),\n  validatorReportRecords: array(tuple([SuiAddress, array(SuiAddress)])),\n});\n\nexport type SuiSystemStateSummary = Infer<typeof SuiSystemStateSummary>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  array,\n  boolean,\n  Infer,\n  nullable,\n  number,\n  object,\n  optional,\n  string,\n} from 'superstruct';\nimport { ObjectId, TransactionDigest } from './common';\n\nexport const CoinStruct = object({\n  coinType: string(),\n  // TODO(chris): rename this to objectId\n  coinObjectId: ObjectId,\n  version: string(),\n  digest: TransactionDigest,\n  balance: string(),\n  // TODO (jian): remove this when we move to 0.34\n  lockedUntilEpoch: optional(nullable(number())),\n  previousTransaction: TransactionDigest,\n});\n\nexport type CoinStruct = Infer<typeof CoinStruct>;\n\nexport const PaginatedCoins = object({\n  data: array(CoinStruct),\n  nextCursor: nullable(ObjectId),\n  hasNextPage: boolean(),\n});\n\nexport type PaginatedCoins = Infer<typeof PaginatedCoins>;\n\nexport const CoinBalance = object({\n  coinType: string(),\n  coinObjectCount: number(),\n  totalBalance: string(),\n  lockedBalance: object({\n    epochId: optional(number()),\n    number: optional(number()),\n  }),\n});\n\nexport type CoinBalance = Infer<typeof CoinBalance>;\n\nexport const CoinSupply = object({\n  value: string(),\n});\n\nexport type CoinSupply = Infer<typeof CoinSupply>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport {\n  array,\n  boolean,\n  Infer,\n  nullable,\n  number,\n  object,\n  string,\n} from 'superstruct';\nimport { SuiValidatorSummary } from './validator';\n\nexport const EndOfEpochInfo = object({\n  lastCheckpointId: string(),\n  epochEndTimestamp: string(),\n  protocolVersion: string(),\n  referenceGasPrice: string(),\n  totalStake: string(),\n  storageFundReinvestment: string(),\n  storageCharge: string(),\n  storageRebate: string(),\n  storageFundBalance: string(),\n  stakeSubsidyAmount: string(),\n  totalGasFees: string(),\n  totalStakeRewardsDistributed: string(),\n  leftoverStorageFundInflow: string(),\n});\n\nexport type EndOfEpochInfo = Infer<typeof EndOfEpochInfo>;\n\nexport const EpochInfo = object({\n  epoch: string(),\n  validators: array(SuiValidatorSummary),\n  epochTotalTransactions: string(),\n  firstCheckpointId: string(),\n  epochStartTimestamp: string(),\n  endOfEpochInfo: nullable(EndOfEpochInfo),\n  referenceGasPrice: nullable(number()),\n});\n\nexport type EpochInfo = Infer<typeof EpochInfo>;\n\nexport const EpochPage = object({\n  data: array(EpochInfo),\n  nextCursor: nullable(string()),\n  hasNextPage: boolean(),\n});\n\nexport type EpochPage = Infer<typeof EpochPage>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Infer, number } from 'superstruct';\n\nexport const SubscriptionId = number();\nexport type SubscriptionId = Infer<typeof SubscriptionId>;\n\nexport type Unsubscribe = () => Promise<boolean>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Infer, array, boolean, nullable, object, string } from 'superstruct';\nimport { ObjectId } from './common';\n\nexport const ResolvedNameServiceNames = object({\n  data: array(string()),\n  hasNextPage: boolean(),\n  nextCursor: nullable(ObjectId),\n});\nexport type ResolvedNameServiceNames = Infer<typeof ResolvedNameServiceNames>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  array,\n  Infer,\n  number,\n  object,\n  string,\n  tuple,\n  boolean,\n  optional,\n  any,\n  nullable,\n} from 'superstruct';\n\nimport { TransactionDigest, TransactionEffectsDigest } from './common';\n\nexport const GasCostSummary = object({\n  computationCost: string(),\n  storageCost: string(),\n  storageRebate: string(),\n  nonRefundableStorageFee: string(),\n});\nexport type GasCostSummary = Infer<typeof GasCostSummary>;\n\nexport const CheckPointContentsDigest = string();\nexport type CheckPointContentsDigest = Infer<typeof CheckPointContentsDigest>;\n\nexport const CheckpointDigest = string();\nexport type CheckpointDigest = Infer<typeof CheckpointDigest>;\n\nexport const ECMHLiveObjectSetDigest = object({\n  digest: array(number()),\n});\nexport type ECMHLiveObjectSetDigest = Infer<typeof ECMHLiveObjectSetDigest>;\n\nexport const CheckpointCommitment = any();\nexport type CheckpointCommitment = Infer<typeof CheckpointCommitment>;\n\nexport const ValidatorSignature = string();\nexport type ValidatorSignature = Infer<typeof ValidatorSignature>;\n\nexport const EndOfEpochData = object({\n  nextEpochCommittee: array(tuple([string(), string()])),\n  nextEpochProtocolVersion: string(),\n  epochCommitments: array(CheckpointCommitment),\n});\nexport type EndOfEpochData = Infer<typeof EndOfEpochData>;\n\nexport const ExecutionDigests = object({\n  transaction: TransactionDigest,\n  effects: TransactionEffectsDigest,\n});\n\nexport const Checkpoint = object({\n  epoch: string(),\n  sequenceNumber: string(),\n  digest: CheckpointDigest,\n  networkTotalTransactions: string(),\n  previousDigest: optional(CheckpointDigest),\n  epochRollingGasCostSummary: GasCostSummary,\n  timestampMs: string(),\n  endOfEpochData: optional(EndOfEpochData),\n  // TODO(jian): remove optional after 0.30.0 is released\n  validatorSignature: optional(ValidatorSignature),\n  transactions: array(TransactionDigest),\n  checkpointCommitments: array(CheckpointCommitment),\n});\nexport type Checkpoint = Infer<typeof Checkpoint>;\n\nexport const CheckpointPage = object({\n  data: array(Checkpoint),\n  nextCursor: nullable(string()),\n  hasNextPage: boolean(),\n});\nexport type CheckpointPage = Infer<typeof CheckpointPage>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { fromB64, toB64 } from '@mysten/bcs';\nimport { bytesEqual, PublicKeyInitData } from './publickey';\nimport { SIGNATURE_SCHEME_TO_FLAG } from './signature';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../types';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nconst PUBLIC_KEY_SIZE = 32;\n\n/**\n * An Ed25519 public key\n */\nexport class Ed25519PublicKey {\n  static SIZE = PUBLIC_KEY_SIZE;\n  private data: Uint8Array;\n\n  /**\n   * Create a new Ed25519PublicKey object\n   * @param value ed25519 public key as buffer or base-64 encoded string\n   */\n  constructor(value: PublicKeyInitData) {\n    if (typeof value === 'string') {\n      this.data = fromB64(value);\n    } else if (value instanceof Uint8Array) {\n      this.data = value;\n    } else {\n      this.data = Uint8Array.from(value);\n    }\n\n    if (this.data.length !== PUBLIC_KEY_SIZE) {\n      throw new Error(\n        `Invalid public key input. Expected ${PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n      );\n    }\n  }\n\n  /**\n   * Checks if two Ed25519 public keys are equal\n   */\n  equals(publicKey: Ed25519PublicKey): boolean {\n    return bytesEqual(this.toBytes(), publicKey.toBytes());\n  }\n\n  /**\n   * Return the base-64 representation of the Ed25519 public key\n   */\n  toBase64(): string {\n    return toB64(this.toBytes());\n  }\n\n  /**\n   * Return the byte array representation of the Ed25519 public key\n   */\n  toBytes(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Return the base-64 representation of the Ed25519 public key\n   */\n  toString(): string {\n    return this.toBase64();\n  }\n\n  /**\n   * Return the Sui address associated with this Ed25519 public key\n   */\n  toSuiAddress(): string {\n    let tmp = new Uint8Array(PUBLIC_KEY_SIZE + 1);\n    tmp.set([SIGNATURE_SCHEME_TO_FLAG['ED25519']]);\n    tmp.set(this.toBytes(), 1);\n    // Each hex char represents half a byte, hence hex address doubles the length\n    return normalizeSuiAddress(\n      bytesToHex(blake2b(tmp, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2),\n    );\n  }\n\n  /**\n   * Return the Sui address associated with this Ed25519 public key\n   */\n  flag(): number {\n    return SIGNATURE_SCHEME_TO_FLAG['ED25519'];\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@mysten/bcs';\nimport { Ed25519PublicKey } from './ed25519-publickey';\nimport { PublicKey } from './publickey';\nimport { Secp256k1PublicKey } from './secp256k1-publickey';\nimport { Secp256r1PublicKey } from './secp256r1-publickey';\n\n/**\n * A keypair used for signing transactions.\n */\nexport type SignatureScheme =\n  | 'ED25519'\n  | 'Secp256k1'\n  | 'Secp256r1'\n  | 'MultiSig';\n\n/**\n * Pair of signature and corresponding public key\n */\nexport type SignaturePubkeyPair = {\n  signatureScheme: SignatureScheme;\n  /** Base64-encoded signature */\n  signature: Uint8Array;\n  /** Base64-encoded public key */\n  pubKey: PublicKey;\n};\n\n/**\n * (`flag || signature || pubkey` bytes, as base-64 encoded string).\n * Signature is committed to the intent message of the transaction data, as base-64 encoded string.\n */\nexport type SerializedSignature = string;\n\nexport const SIGNATURE_SCHEME_TO_FLAG = {\n  ED25519: 0x00,\n  Secp256k1: 0x01,\n  Secp256r1: 0x02,\n  MultiSig: 0x03,\n};\n\nexport const SIGNATURE_FLAG_TO_SCHEME = {\n  0x00: 'ED25519',\n  0x01: 'Secp256k1',\n  0x02: 'Secp256r1',\n  0x03: 'MultiSig',\n} as const;\nexport type SignatureFlag = keyof typeof SIGNATURE_FLAG_TO_SCHEME;\n\nexport function toSerializedSignature({\n  signature,\n  signatureScheme,\n  pubKey,\n}: SignaturePubkeyPair): SerializedSignature {\n  const serializedSignature = new Uint8Array(\n    1 + signature.length + pubKey.toBytes().length,\n  );\n  serializedSignature.set([SIGNATURE_SCHEME_TO_FLAG[signatureScheme]]);\n  serializedSignature.set(signature, 1);\n  serializedSignature.set(pubKey.toBytes(), 1 + signature.length);\n  return toB64(serializedSignature);\n}\n\nexport function fromSerializedSignature(\n  serializedSignature: SerializedSignature,\n): SignaturePubkeyPair {\n  const bytes = fromB64(serializedSignature);\n  const signatureScheme =\n    SIGNATURE_FLAG_TO_SCHEME[bytes[0] as keyof typeof SIGNATURE_FLAG_TO_SCHEME];\n\n  if (signatureScheme === 'MultiSig') {\n    // TODO(joyqvq): add multisig parsing support\n    throw new Error('MultiSig is not supported');\n  }\n\n  const SIGNATURE_SCHEME_TO_PUBLIC_KEY = {\n    ED25519: Ed25519PublicKey,\n    Secp256k1: Secp256k1PublicKey,\n    Secp256r1: Secp256r1PublicKey,\n  };\n\n  const PublicKey = SIGNATURE_SCHEME_TO_PUBLIC_KEY[signatureScheme];\n\n  const signature = bytes.slice(1, bytes.length - PublicKey.SIZE);\n  const pubkeyBytes = bytes.slice(1 + signature.length);\n  const pubKey = new PublicKey(pubkeyBytes);\n\n  return {\n    signatureScheme,\n    signature,\n    pubKey,\n  };\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@mysten/bcs';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\nimport { normalizeSuiAddress, SUI_ADDRESS_LENGTH } from '../types';\nimport { bytesEqual, PublicKey, PublicKeyInitData } from './publickey';\nimport { SIGNATURE_SCHEME_TO_FLAG } from './signature';\n\nconst SECP256R1_PUBLIC_KEY_SIZE = 33;\n\n/**\n * A Secp256r1 public key\n */\nexport class Secp256r1PublicKey implements PublicKey {\n  static SIZE = SECP256R1_PUBLIC_KEY_SIZE;\n  private data: Uint8Array;\n\n  /**\n   * Create a new Secp256r1PublicKey object\n   * @param value secp256r1 public key as buffer or base-64 encoded string\n   */\n  constructor(value: PublicKeyInitData) {\n    if (typeof value === 'string') {\n      this.data = fromB64(value);\n    } else if (value instanceof Uint8Array) {\n      this.data = value;\n    } else {\n      this.data = Uint8Array.from(value);\n    }\n\n    if (this.data.length !== SECP256R1_PUBLIC_KEY_SIZE) {\n      throw new Error(\n        `Invalid public key input. Expected ${SECP256R1_PUBLIC_KEY_SIZE} bytes, got ${this.data.length}`,\n      );\n    }\n  }\n\n  /**\n   * Checks if two Secp256r1 public keys are equal\n   */\n  equals(publicKey: Secp256r1PublicKey): boolean {\n    return bytesEqual(this.toBytes(), publicKey.toBytes());\n  }\n\n  /**\n   * Return the base-64 representation of the Secp256r1 public key\n   */\n  toBase64(): string {\n    return toB64(this.toBytes());\n  }\n\n  /**\n   * Return the byte array representation of the Secp256r1 public key\n   */\n  toBytes(): Uint8Array {\n    return this.data;\n  }\n\n  /**\n   * Return the base-64 representation of the Secp256r1 public key\n   */\n  toString(): string {\n    return this.toBase64();\n  }\n\n  /**\n   * Return the Sui address associated with this Secp256r1 public key\n   */\n  toSuiAddress(): string {\n    let tmp = new Uint8Array(SECP256R1_PUBLIC_KEY_SIZE + 1);\n    tmp.set([SIGNATURE_SCHEME_TO_FLAG['Secp256r1']]);\n    tmp.set(this.toBytes(), 1);\n    // Each hex char represents half a byte, hence hex address doubles the length\n    return normalizeSuiAddress(\n      bytesToHex(blake2b(tmp, { dkLen: 32 })).slice(0, SUI_ADDRESS_LENGTH * 2),\n    );\n  }\n\n  /**\n   * Return the Sui address associated with this Secp256r1 public key\n   */\n  flag(): number {\n    return SIGNATURE_SCHEME_TO_FLAG['Secp256r1'];\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Ed25519PublicKey } from './ed25519-publickey';\nimport { Secp256k1PublicKey } from './secp256k1-publickey';\nimport { SignatureScheme } from './signature';\n\n/**\n * Value to be converted into public key.\n */\nexport type PublicKeyInitData = string | Uint8Array | Iterable<number>;\n\nexport function bytesEqual(a: Uint8Array, b: Uint8Array) {\n  if (a === b) return true;\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * A public key\n */\nexport interface PublicKey {\n  /**\n   * Checks if two public keys are equal\n   */\n  equals(publicKey: PublicKey): boolean;\n\n  /**\n   * Return the base-64 representation of the public key\n   */\n  toBase64(): string;\n\n  /**\n   * Return the byte array representation of the public key\n   */\n  toBytes(): Uint8Array;\n\n  /**\n   * Return the base-64 representation of the public key\n   */\n  toString(): string;\n\n  /**\n   * Return the Sui address associated with this public key\n   */\n  toSuiAddress(): string;\n\n  /**\n   * Return signature scheme flag of the public key\n   */\n  flag(): number;\n}\n\nexport function publicKeyFromSerialized(\n  schema: SignatureScheme,\n  pubKey: string,\n): PublicKey {\n  if (schema === 'ED25519') {\n    return new Ed25519PublicKey(pubKey);\n  }\n  if (schema === 'Secp256k1') {\n    return new Secp256k1PublicKey(pubKey);\n  }\n  throw new Error('Unknown public key schema');\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nimport { toHEX } from '@mysten/bcs';\nimport { mnemonicToSeedSync as bip39MnemonicToSeedSync } from '@scure/bip39';\n\n/**\n * Parse and validate a path that is compliant to SLIP-0010 in form m/44'/784'/{account_index}'/{change_index}'/{address_index}'.\n *\n * @param path path string (e.g. `m/44'/784'/0'/0'/0'`).\n */\nexport function isValidHardenedPath(path: string): boolean {\n  if (\n    !new RegExp(\"^m\\\\/44'\\\\/784'\\\\/[0-9]+'\\\\/[0-9]+'\\\\/[0-9]+'+$\").test(path)\n  ) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Parse and validate a path that is compliant to BIP-32 in form m/54'/784'/{account_index}'/{change_index}/{address_index}\n * for Secp256k1 and m/74'/784'/{account_index}'/{change_index}/{address_index} for Secp256r1.\n *\n * Note that the purpose for Secp256k1 is registered as 54, to differentiate from Ed25519 with purpose 44.\n *\n * @param path path string (e.g. `m/54'/784'/0'/0/0`).\n */\nexport function isValidBIP32Path(path: string): boolean {\n  if (\n    !new RegExp(\"^m\\\\/(54|74)'\\\\/784'\\\\/[0-9]+'\\\\/[0-9]+\\\\/[0-9]+$\").test(path)\n  ) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Uses KDF to derive 64 bytes of key data from mnemonic with empty password.\n *\n * @param mnemonics 12 words string split by spaces.\n */\nexport function mnemonicToSeed(mnemonics: string): Uint8Array {\n  return bip39MnemonicToSeedSync(mnemonics, '');\n}\n\n/**\n * Derive the seed in hex format from a 12-word mnemonic string.\n *\n * @param mnemonics 12 words string split by spaces.\n */\nexport function mnemonicToSeedHex(mnemonics: string): string {\n  return toHEX(mnemonicToSeed(mnemonics));\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This is adapted from https://github.com/alepop/ed25519-hd-key replacing create-hmac\n// with @noble/hashes to be browser compatible.\n\nimport { sha512 } from '@noble/hashes/sha512';\nimport { hmac } from '@noble/hashes/hmac';\nimport nacl from 'tweetnacl';\nimport { fromHEX } from '@mysten/bcs';\n\ntype Hex = string;\ntype Path = string;\n\ntype Keys = {\n  key: Uint8Array;\n  chainCode: Uint8Array;\n};\n\nconst ED25519_CURVE = 'ed25519 seed';\nconst HARDENED_OFFSET = 0x80000000;\n\nexport const pathRegex = new RegExp(\"^m(\\\\/[0-9]+')+$\");\n\nexport const replaceDerive = (val: string): string => val.replace(\"'\", '');\n\nexport const getMasterKeyFromSeed = (seed: Hex): Keys => {\n  const h = hmac.create(sha512, ED25519_CURVE);\n  const I = h.update(fromHEX(seed)).digest();\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR,\n  };\n};\n\nconst CKDPriv = ({ key, chainCode }: Keys, index: number): Keys => {\n  const indexBuffer = new ArrayBuffer(4);\n  const cv = new DataView(indexBuffer);\n  cv.setUint32(0, index);\n\n  const data = new Uint8Array(1 + key.length + indexBuffer.byteLength);\n  data.set(new Uint8Array(1).fill(0));\n  data.set(key, 1);\n  data.set(\n    new Uint8Array(indexBuffer, 0, indexBuffer.byteLength),\n    key.length + 1,\n  );\n\n  const I = hmac.create(sha512, chainCode).update(data).digest();\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return {\n    key: IL,\n    chainCode: IR,\n  };\n};\n\nexport const getPublicKey = (\n  privateKey: Uint8Array,\n  withZeroByte = true,\n): Uint8Array => {\n  const keyPair = nacl.sign.keyPair.fromSeed(privateKey);\n  const signPk = keyPair.secretKey.subarray(32);\n  const newArr = new Uint8Array(signPk.length + 1);\n  newArr.set([0]);\n  newArr.set(signPk, 1);\n  return withZeroByte ? newArr : signPk;\n};\n\nexport const isValidPath = (path: string): boolean => {\n  if (!pathRegex.test(path)) {\n    return false;\n  }\n  return !path\n    .split('/')\n    .slice(1)\n    .map(replaceDerive)\n    .some(isNaN as any /* ts T_T*/);\n};\n\nexport const derivePath = (\n  path: Path,\n  seed: Hex,\n  offset = HARDENED_OFFSET,\n): Keys => {\n  if (!isValidPath(path)) {\n    throw new Error('Invalid derivation path');\n  }\n\n  const { key, chainCode } = getMasterKeyFromSeed(seed);\n  const segments = path\n    .split('/')\n    .slice(1)\n    .map(replaceDerive)\n    .map((el) => parseInt(el, 10));\n\n  return segments.reduce(\n    (parentKeys, segment) => CKDPriv(parentKeys, segment + offset),\n    { key, chainCode },\n  );\n};\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport type { ExportedKeypair, Keypair } from './keypair';\nimport { PublicKey } from './publickey';\nimport { sha256 } from '@noble/hashes/sha256';\nimport { Secp256r1PublicKey } from './secp256r1-publickey';\nimport { secp256r1 } from '@noble/curves/p256';\nimport { isValidBIP32Path, mnemonicToSeed } from './mnemonics';\nimport { HDKey } from '@scure/bip32';\nimport { toB64 } from '@mysten/bcs';\nimport { SignatureScheme } from './signature';\nimport { bytesToHex } from '@noble/hashes/utils';\nimport { blake2b } from '@noble/hashes/blake2b';\n\nexport const DEFAULT_SECP256R1_DERIVATION_PATH = \"m/74'/784'/0'/0/0\";\n\n/**\n * Secp256r1 Keypair data\n */\nexport interface Secp256r1KeypairData {\n  publicKey: Uint8Array;\n  secretKey: Uint8Array;\n}\n\n/**\n * An Secp256r1 Keypair used for signing transactions.\n */\nexport class Secp256r1Keypair implements Keypair {\n  private keypair: Secp256r1KeypairData;\n\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Secp256r1Keypair} is provided.\n   *\n   * @param keypair Secp256r1 keypair\n   */\n  constructor(keypair?: Secp256r1KeypairData) {\n    if (keypair) {\n      this.keypair = keypair;\n    } else {\n      const secretKey: Uint8Array = secp256r1.utils.randomPrivateKey();\n      const publicKey: Uint8Array = secp256r1.getPublicKey(secretKey, true);\n\n      this.keypair = { publicKey, secretKey };\n    }\n  }\n\n  /**\n   * Get the key scheme of the keypair Secp256r1\n   */\n  getKeyScheme(): SignatureScheme {\n    return 'Secp256r1';\n  }\n\n  /**\n   * Generate a new random keypair\n   */\n  static generate(): Secp256r1Keypair {\n    return new Secp256r1Keypair();\n  }\n\n  /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options: skip secret key validation\n   */\n\n  static fromSecretKey(\n    secretKey: Uint8Array,\n    options?: { skipValidation?: boolean },\n  ): Secp256r1Keypair {\n    const publicKey: Uint8Array = secp256r1.getPublicKey(secretKey, true);\n    if (!options || !options.skipValidation) {\n      const encoder = new TextEncoder();\n      const signData = encoder.encode('sui validation');\n      const msgHash = bytesToHex(blake2b(signData, { dkLen: 32 }));\n      const signature = secp256r1.sign(msgHash, secretKey, { lowS: true });\n      if (!secp256r1.verify(signature, msgHash, publicKey, { lowS: true })) {\n        throw new Error('Provided secretKey is invalid');\n      }\n    }\n    return new Secp256r1Keypair({ publicKey, secretKey });\n  }\n\n  /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   */\n  static fromSeed(seed: Uint8Array): Secp256r1Keypair {\n    let publicKey = secp256r1.getPublicKey(seed, true);\n    return new Secp256r1Keypair({ publicKey, secretKey: seed });\n  }\n\n  /**\n   * The public key for this keypair\n   */\n  getPublicKey(): PublicKey {\n    return new Secp256r1PublicKey(this.keypair.publicKey);\n  }\n\n  /**\n   * Return the signature for the provided data.\n   */\n  signData(data: Uint8Array): Uint8Array {\n    const msgHash = sha256(data);\n    const sig = secp256r1.sign(msgHash, this.keypair.secretKey, {\n      lowS: true,\n    });\n    return sig.toCompactRawBytes();\n  }\n\n  /**\n   * Derive Secp256r1 keypair from mnemonics and path. The mnemonics must be normalized\n   * and validated against the english wordlist.\n   *\n   * If path is none, it will default to m/74'/784'/0'/0/0, otherwise the path must\n   * be compliant to BIP-32 in form m/74'/784'/{account_index}'/{change_index}/{address_index}.\n   */\n  static deriveKeypair(mnemonics: string, path?: string): Secp256r1Keypair {\n    if (path == null) {\n      path = DEFAULT_SECP256R1_DERIVATION_PATH;\n    }\n    if (!isValidBIP32Path(path)) {\n      throw new Error('Invalid derivation path');\n    }\n    // We use HDKey which is hardcoded to use Secp256k1 but since we only need the 32 bytes for the private key it's okay to use here as well.\n    const privateKey = HDKey.fromMasterSeed(mnemonicToSeed(mnemonics)).derive(\n      path,\n    ).privateKey;\n    return Secp256r1Keypair.fromSecretKey(privateKey!);\n  }\n\n  export(): ExportedKeypair {\n    return {\n      schema: 'Secp256r1',\n      privateKey: toB64(this.keypair.secretKey),\n    };\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB64 } from '@mysten/bcs';\nimport {\n  SIGNATURE_SCHEME_TO_FLAG,\n  SerializedSignature,\n  SignaturePubkeyPair,\n  SignatureScheme,\n  fromSerializedSignature,\n} from './signature';\nimport { PublicKey } from './publickey';\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { bytesToHex } from '@noble/hashes/utils';\n\nimport { normalizeSuiAddress } from '../types';\nimport {\n  Ed25519PublicKey,\n  Secp256k1PublicKey,\n  Secp256r1PublicKey,\n  builder,\n  fromB64,\n} from '..';\n\nexport type PubkeyWeightPair = {\n  pubKey: PublicKey;\n  weight: number;\n};\n\nexport type CompressedSignature =\n  | { ED25519: number[] }\n  | { Secp256k1: number[] }\n  | { Secp256r1: number[] };\n\nexport type PublicKeyEnum =\n  | { ED25519: number[] }\n  | { Secp256k1: number[] }\n  | { Secp256r1: number[] };\n\nexport type PubkeyEnumWeightPair = {\n  pubKey: PublicKeyEnum;\n  weight: number;\n};\n\nexport type MultiSigPublicKey = {\n  pk_map: PubkeyEnumWeightPair[];\n  threshold: number;\n};\n\nexport type MultiSig = {\n  sigs: CompressedSignature[];\n  bitmap: number;\n  multisig_pk: MultiSigPublicKey;\n};\n\nexport const MAX_SIGNER_IN_MULTISIG = 10;\n\n/// Derives a multisig address from a list of pk and weights and threshold.\n// It is the 32-byte Blake2b hash of the serializd bytes of `flag_MultiSig || threshold || flag_1 || pk_1 || weight_1\n/// || ... || flag_n || pk_n || weight_n`\nexport function toMultiSigAddress(\n  pks: PubkeyWeightPair[],\n  threshold: number,\n): string {\n  if (pks.length > MAX_SIGNER_IN_MULTISIG) {\n    throw new Error(\n      `Max number of signers in a multisig is ${MAX_SIGNER_IN_MULTISIG}`,\n    );\n  }\n  // max length = 1 flag byte + (max pk size + max weight size (u8)) * max signer size + 2 threshold bytes (u16)\n  let maxLength = 1 + (64 + 1) * MAX_SIGNER_IN_MULTISIG + 2;\n  let tmp = new Uint8Array(maxLength);\n  tmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n\n  let arr = to_uint8array(threshold);\n  tmp.set(arr, 1);\n  let i = 3;\n  for (const pk of pks) {\n    tmp.set([pk.pubKey.flag()], i);\n    tmp.set(pk.pubKey.toBytes(), i + 1);\n    tmp.set([pk.weight], i + 1 + pk.pubKey.toBytes().length);\n    i += pk.pubKey.toBytes().length + 2;\n  }\n  return normalizeSuiAddress(\n    bytesToHex(blake2b(tmp.slice(0, i), { dkLen: 32 })),\n  );\n}\n\n/// Combine a list of serialized sigs, a list of pk weight pairs\n/// and threshold into a single multisig. `sigs` are required to\n/// be in the same order as `pks`. e.g. for [pk1, pk2, pk3, pk4, pk5],\n/// [sig1, sig2, sig5] is valid, but [sig2, sig1, sig5] is invalid.\nexport function combinePartialSigs(\n  sigs: SerializedSignature[],\n  pks: PubkeyWeightPair[],\n  threshold: number,\n): SerializedSignature {\n  let multisig_pk: MultiSigPublicKey = {\n    pk_map: pks.map((x) => toPkWeightPair(x)),\n    threshold: threshold,\n  };\n\n  let bitmap = 0;\n  let compressed_sigs: CompressedSignature[] = new Array(sigs.length);\n  for (let i = 0; i < sigs.length; i++) {\n    let parsed = fromSerializedSignature(sigs[i]);\n    let bytes = Array.from(parsed.signature.map((x) => Number(x)));\n    if (parsed.signatureScheme === 'ED25519') {\n      compressed_sigs[i] = { ED25519: bytes };\n    } else if (parsed.signatureScheme === 'Secp256k1') {\n      compressed_sigs[i] = { Secp256k1: bytes };\n    } else if (parsed.signatureScheme === 'Secp256r1') {\n      compressed_sigs[i] = { Secp256r1: bytes };\n    }\n    for (let j = 0; j < pks.length; j++) {\n      if (parsed.pubKey.equals(pks[j].pubKey)) {\n        bitmap |= 1 << j;\n        break;\n      }\n    }\n  }\n  let multisig: MultiSig = {\n    sigs: compressed_sigs,\n    bitmap,\n    multisig_pk,\n  };\n\n  const bytes = builder.ser('MultiSig', multisig).toBytes();\n  let tmp = new Uint8Array(bytes.length + 1);\n  tmp.set([SIGNATURE_SCHEME_TO_FLAG['MultiSig']]);\n  tmp.set(bytes, 1);\n  return toB64(tmp);\n}\n\nexport function decodeMultiSig(signature: string): SignaturePubkeyPair[] {\n  const parsed = fromB64(signature);\n  if (parsed.length < 1 || parsed[0] !== SIGNATURE_SCHEME_TO_FLAG['MultiSig']) {\n    throw new Error('Invalid MultiSig flag');\n  }\n  const multisig: MultiSig = builder.de('MultiSig', parsed.slice(1));\n  let res: SignaturePubkeyPair[] = new Array(multisig.sigs.length);\n  for (let i = 0; i < multisig.sigs.length; i++) {\n    let s: CompressedSignature = multisig.sigs[i];\n    let pk_index = as_indices(multisig.bitmap).at(i);\n    let pk_bytes = Object.values(\n      multisig.multisig_pk.pk_map[pk_index as number].pubKey,\n    )[0];\n    const scheme = Object.keys(s)[0] as SignatureScheme;\n\n    if (scheme === 'MultiSig') {\n      throw new Error('MultiSig is not supported inside MultiSig');\n    }\n\n    const SIGNATURE_SCHEME_TO_PUBLIC_KEY = {\n      ED25519: Ed25519PublicKey,\n      Secp256k1: Secp256k1PublicKey,\n      Secp256r1: Secp256r1PublicKey,\n    };\n\n    const PublicKey = SIGNATURE_SCHEME_TO_PUBLIC_KEY[scheme];\n\n    res[i] = {\n      signatureScheme: scheme,\n      signature: Uint8Array.from(Object.values(s)[0]),\n      pubKey: new PublicKey(pk_bytes),\n    };\n  }\n  return res;\n}\n\nfunction toPkWeightPair(pair: PubkeyWeightPair): PubkeyEnumWeightPair {\n  let pk_bytes = Array.from(pair.pubKey.toBytes().map((x) => Number(x)));\n  switch (pair.pubKey.flag()) {\n    case SIGNATURE_SCHEME_TO_FLAG['Secp256k1']:\n      return {\n        pubKey: {\n          Secp256k1: pk_bytes,\n        },\n        weight: pair.weight,\n      };\n    case SIGNATURE_SCHEME_TO_FLAG['Secp256r1']:\n      return {\n        pubKey: {\n          Secp256r1: pk_bytes,\n        },\n        weight: pair.weight,\n      };\n    case SIGNATURE_SCHEME_TO_FLAG['ED25519']:\n      return {\n        pubKey: {\n          ED25519: pk_bytes,\n        },\n        weight: pair.weight,\n      };\n    default:\n      throw new Error('Unsupported signature scheme');\n  }\n}\n\n/// Convert u16 to Uint8Array of length 2 in little endian.\nfunction to_uint8array(threshold: number): Uint8Array {\n  if (threshold < 0 || threshold > 65535) {\n    throw new Error('Invalid threshold');\n  }\n  let arr = new Uint8Array(2);\n  arr[0] = threshold & 0xff;\n  arr[1] = threshold >> 8;\n  return arr;\n}\n\nfunction as_indices(bitmap: number): Uint8Array {\n  if (bitmap < 0 || bitmap > 1024) {\n    throw new Error('Invalid bitmap');\n  }\n  let res: number[] = [];\n  for (let i = 0; i < 10; i++) {\n    if ((bitmap & (1 << i)) !== 0) {\n      res.push(i);\n    }\n  }\n  return Uint8Array.from(res);\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { RequestManager, HTTPTransport, Client } from '@open-rpc/client-js';\nimport { Struct, validate } from 'superstruct';\nimport { PACKAGE_VERSION, TARGETED_RPC_VERSION } from '../version';\nimport { RPCValidationError } from '../utils/errors';\n\n/**\n * An object defining headers to be passed to the RPC server\n */\nexport type HttpHeaders = { [header: string]: string };\n\nexport class JsonRpcClient {\n  private rpcClient: Client;\n\n  constructor(url: string, httpHeaders?: HttpHeaders) {\n    const transport = new HTTPTransport(url, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Client-Sdk-Type': 'typescript',\n        'Client-Sdk-Version': PACKAGE_VERSION,\n        'Client-Target-Api-Version': TARGETED_RPC_VERSION,\n        ...httpHeaders,\n      },\n    });\n\n    this.rpcClient = new Client(new RequestManager([transport]));\n  }\n\n  async requestWithType<T>(\n    method: string,\n    args: any[],\n    struct: Struct<T>,\n  ): Promise<T> {\n    const req = { method, args };\n\n    const response = await this.request(method, args);\n\n    if (process.env.NODE_ENV === 'test') {\n      const [err] = validate(response, struct);\n      if (err) {\n        throw new RPCValidationError({\n          req,\n          result: response,\n          cause: err,\n        });\n      }\n    }\n\n    return response;\n  }\n\n  async request(method: string, params: any[]): Promise<any> {\n    return await this.rpcClient.request({ method, params });\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// This file is generated by genversion.mjs. Do not edit it directly.\n\nexport const PACKAGE_VERSION = '0.36.0';\nexport const TARGETED_RPC_VERSION = '1.4.0';\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\ninterface RPCErrorRequest {\n  method: string;\n  args: any[];\n}\n\nexport class RPCValidationError extends Error {\n  req: RPCErrorRequest;\n  result?: unknown;\n\n  constructor(options: {\n    req: RPCErrorRequest;\n    result?: unknown;\n    cause?: Error;\n  }) {\n    super(\n      'RPC Validation Error: The response returned from RPC server does not match the TypeScript definition. This is likely because the SDK version is not compatible with the RPC server.',\n      { cause: options.cause },\n    );\n\n    this.req = options.req;\n    this.result = options.result;\n    this.message = this.toString();\n  }\n\n  toString() {\n    let str = super.toString();\n    if (this.cause) {\n      str += `\\nCause: ${this.cause}`;\n    }\n    if (this.result) {\n      str += `\\nReponse Received: ${JSON.stringify(this.result, null, 2)}`;\n    }\n    return str;\n  }\n}\n\nexport class FaucetRateLimitError extends Error {}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  any,\n  array,\n  boolean,\n  Infer,\n  literal,\n  nullable,\n  number,\n  object,\n  string,\n  union,\n} from 'superstruct';\nimport { ObjectId } from './common';\n\nexport const DynamicFieldType = union([\n  literal('DynamicField'),\n  literal('DynamicObject'),\n]);\nexport type DynamicFieldType = Infer<typeof DynamicFieldType>;\n\nexport const DynamicFieldName = object({\n  type: string(),\n  value: any(),\n});\nexport type DynamicFieldName = Infer<typeof DynamicFieldName>;\n\nexport const DynamicFieldInfo = object({\n  name: DynamicFieldName,\n  bcsName: string(),\n  type: DynamicFieldType,\n  objectType: string(),\n  objectId: ObjectId,\n  version: number(),\n  digest: string(),\n});\nexport type DynamicFieldInfo = Infer<typeof DynamicFieldInfo>;\n\nexport const DynamicFieldPage = object({\n  data: array(DynamicFieldInfo),\n  nextCursor: nullable(ObjectId),\n  hasNextPage: boolean(),\n});\nexport type DynamicFieldPage = Infer<typeof DynamicFieldPage>;\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { SubscriptionId } from '../types';\nimport {\n  RequestManager,\n  Client,\n  WebSocketTransport,\n} from '@open-rpc/client-js';\n\nexport const getWebsocketUrl = (httpUrl: string, port?: number): string => {\n  const url = new URL(httpUrl);\n  url.protocol = url.protocol.replace('http', 'ws');\n  if (port) {\n    url.port = port.toString();\n  }\n  return url.toString();\n};\n\ntype NotificationMessageParams = {\n  subscription: SubscriptionId;\n  result: object;\n};\n\ntype SubscriptionRequest<T = any> = {\n  id?: number;\n  method: string;\n  unsubscribe: string;\n  params: any[];\n  onMessage: (event: T) => void;\n};\n\n/**\n * Configuration options for the websocket connection\n */\nexport type WebsocketClientOptions = {\n  /**\n   * Milliseconds before timing out while calling an RPC method\n   */\n  callTimeout: number;\n  /**\n   * Milliseconds between attempts to connect\n   */\n  reconnectTimeout: number;\n  /**\n   * Maximum number of times to try connecting before giving up\n   */\n  maxReconnects: number;\n};\n\nexport const DEFAULT_CLIENT_OPTIONS: WebsocketClientOptions = {\n  callTimeout: 30000,\n  reconnectTimeout: 3000,\n  maxReconnects: 5,\n};\n\nexport class WebsocketClient {\n  #client: Client | null;\n  #subscriptions: Map<SubscriptionId, SubscriptionRequest & { id: number }>;\n  #disconnects: number;\n\n  constructor(\n    public endpoint: string,\n    public options: WebsocketClientOptions = DEFAULT_CLIENT_OPTIONS,\n  ) {\n    if (this.endpoint.startsWith('http')) {\n      this.endpoint = getWebsocketUrl(this.endpoint);\n    }\n\n    this.#client = null;\n    this.#subscriptions = new Map();\n    this.#disconnects = 0;\n  }\n\n  #setupClient() {\n    if (this.#client) {\n      return this.#client;\n    }\n\n    const transport = new WebSocketTransport(this.endpoint);\n    const requestManager = new RequestManager([transport]);\n    this.#client = new Client(requestManager);\n\n    transport.connection.addEventListener('open', () => {\n      this.#disconnects = 0;\n    });\n\n    transport.connection.addEventListener('close', () => {\n      this.#disconnects++;\n      if (this.#disconnects <= this.options.maxReconnects) {\n        setTimeout(() => {\n          this.#reconnect();\n        }, this.options.reconnectTimeout);\n      }\n    });\n\n    this.#client.onNotification((data) => {\n      const params = data.params as NotificationMessageParams;\n\n      this.#subscriptions.forEach((subscription) => {\n        if (\n          subscription.method === data.method &&\n          params.subscription === subscription.id\n        ) {\n          subscription.onMessage(params.result);\n        }\n      });\n    });\n\n    return this.#client;\n  }\n\n  #reconnect() {\n    this.#client?.close();\n    this.#client = null;\n\n    this.#subscriptions.forEach((subscription) => this.request(subscription));\n  }\n\n  async request<T>(input: SubscriptionRequest<T>) {\n    const client = this.#setupClient();\n    const id = await client.request(\n      { method: input.method, params: input.params },\n      this.options.callTimeout,\n    );\n\n    // If an input ID is provided, this is a reconnect and we need to use that ID instead:\n    this.#subscriptions.set(input.id || id, {\n      ...input,\n      // Always set the latest actual subscription ID:\n      id,\n    });\n\n    return async () => {\n      const client = this.#setupClient();\n      // NOTE: Due to reconnects, the inner subscription ID could have actually changed:\n      const subscription = this.#subscriptions.get(id);\n      if (!subscription) return false;\n\n      this.#subscriptions.delete(id);\n\n      return client.request(\n        { method: input.unsubscribe, params: [subscription.id] },\n        this.options.callTimeout,\n      );\n    };\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { FaucetResponse, SuiAddress } from '../types';\nimport { FaucetRateLimitError } from '../utils/errors';\nimport { HttpHeaders } from './client';\n\nexport async function requestSuiFromFaucet(\n  endpoint: string,\n  recipient: SuiAddress,\n  httpHeaders?: HttpHeaders,\n): Promise<FaucetResponse> {\n  const res = await fetch(endpoint, {\n    method: 'POST',\n    body: JSON.stringify({\n      FixedAmountRequest: {\n        recipient,\n      },\n    }),\n    headers: {\n      'Content-Type': 'application/json',\n      ...(httpHeaders || {}),\n    },\n  });\n\n  if (res.status === 429) {\n    throw new FaucetRateLimitError(\n      `Too many requests from this client have been sent to the faucet. Please retry later`,\n    );\n  }\n  let parsed;\n  try {\n    parsed = await res.json();\n  } catch (e) {\n    throw new Error(\n      `Encountered error when parsing response from faucet, error: ${e}, status ${res.status}, response ${res}`,\n    );\n  }\n  if (parsed.error) {\n    throw new Error(`Faucet returns error: ${parsed.error}`);\n  }\n  return parsed;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { HttpHeaders, JsonRpcClient } from '../rpc/client';\nimport {\n  ExecuteTransactionRequestType,\n  ObjectId,\n  PaginatedTransactionResponse,\n  SuiAddress,\n  SuiEventFilter,\n  SuiMoveFunctionArgTypes,\n  SuiMoveNormalizedFunction,\n  SuiMoveNormalizedModule,\n  SuiMoveNormalizedModules,\n  SuiMoveNormalizedStruct,\n  SuiTransactionBlockResponse,\n  TransactionDigest,\n  SuiTransactionBlockResponseQuery,\n  PaginatedEvents,\n  FaucetResponse,\n  Order,\n  DevInspectResults,\n  CoinMetadata,\n  isValidTransactionDigest,\n  isValidSuiAddress,\n  isValidSuiObjectId,\n  normalizeSuiAddress,\n  normalizeSuiObjectId,\n  CoinMetadataStruct,\n  PaginatedCoins,\n  SuiObjectResponse,\n  DelegatedStake,\n  CoinBalance,\n  CoinSupply,\n  CheckpointDigest,\n  Checkpoint,\n  CommitteeInfo,\n  DryRunTransactionBlockResponse,\n  SuiObjectDataOptions,\n  SuiSystemStateSummary,\n  SuiTransactionBlockResponseOptions,\n  SuiEvent,\n  PaginatedObjectsResponse,\n  SuiObjectResponseQuery,\n  ValidatorsApy,\n  MoveCallMetrics,\n  ObjectRead,\n  TransactionFilter,\n  TransactionEffects,\n  Unsubscribe,\n  ResolvedNameServiceNames,\n  ProtocolConfig,\n} from '../types';\nimport { DynamicFieldName, DynamicFieldPage } from '../types/dynamic_fields';\nimport {\n  DEFAULT_CLIENT_OPTIONS,\n  WebsocketClient,\n  WebsocketClientOptions,\n} from '../rpc/websocket-client';\nimport { requestSuiFromFaucet } from '../rpc/faucet-client';\nimport { any, array, string, nullable } from 'superstruct';\nimport { fromB58, toB64, toHEX } from '@mysten/bcs';\nimport { SerializedSignature } from '../cryptography/signature';\nimport { Connection, devnetConnection } from '../rpc/connection';\nimport { TransactionBlock } from '../builder';\nimport { CheckpointPage } from '../types/checkpoints';\nimport { NetworkMetrics, AddressMetrics } from '../types/metrics';\nimport { EpochInfo, EpochPage } from '../types/epochs';\n\nexport interface PaginationArguments<Cursor> {\n  /** Optional paging cursor */\n  cursor?: Cursor;\n  /** Maximum item returned per page */\n  limit?: number | null;\n}\n\nexport interface OrderArguments {\n  order?: Order | null;\n}\n\n/**\n * Configuration options for the JsonRpcProvider. If the value of a field is not provided,\n * value in `DEFAULT_OPTIONS` for that field will be used\n */\nexport type RpcProviderOptions = {\n  /**\n   * Configuration options for the websocket connection\n   * TODO: Move to connection.\n   */\n  socketOptions?: WebsocketClientOptions;\n  /**\n   * Cache timeout in seconds for the RPC API Version\n   */\n  versionCacheTimeoutInSeconds?: number;\n\n  /** Allow defining a custom RPC client to use */\n  rpcClient?: JsonRpcClient;\n\n  /** Allow defining a custom websocket client to use */\n  websocketClient?: WebsocketClient;\n};\n\nconst DEFAULT_OPTIONS: RpcProviderOptions = {\n  socketOptions: DEFAULT_CLIENT_OPTIONS,\n  versionCacheTimeoutInSeconds: 600,\n};\n\nexport class JsonRpcProvider {\n  public connection: Connection;\n  protected client: JsonRpcClient;\n  protected wsClient: WebsocketClient;\n  private rpcApiVersion: string | undefined;\n  private cacheExpiry: number | undefined;\n  /**\n   * Establish a connection to a Sui RPC endpoint\n   *\n   * @param connection The `Connection` object containing configuration for the network.\n   * @param options configuration options for the provider\n   */\n  constructor(\n    // TODO: Probably remove the default endpoint here:\n    connection: Connection = devnetConnection,\n    public options: RpcProviderOptions = DEFAULT_OPTIONS,\n  ) {\n    this.connection = connection;\n\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    this.options = opts;\n    // TODO: add header for websocket request\n    this.client = opts.rpcClient ?? new JsonRpcClient(this.connection.fullnode);\n\n    this.wsClient =\n      opts.websocketClient ??\n      new WebsocketClient(this.connection.websocket, opts.socketOptions);\n  }\n\n  async getRpcApiVersion(): Promise<string | undefined> {\n    if (\n      this.rpcApiVersion &&\n      this.cacheExpiry &&\n      this.cacheExpiry <= Date.now()\n    ) {\n      return this.rpcApiVersion;\n    }\n\n    try {\n      const resp = await this.client.requestWithType('rpc.discover', [], any());\n      this.rpcApiVersion = resp.info.version;\n      this.cacheExpiry =\n        // Date.now() is in milliseconds, but the timeout is in seconds\n        Date.now() + (this.options.versionCacheTimeoutInSeconds ?? 0) * 1000;\n      return this.rpcApiVersion;\n    } catch (err) {\n      console.warn('Error fetching version number of the RPC API', err);\n    }\n    return undefined;\n  }\n\n  async requestSuiFromFaucet(\n    recipient: SuiAddress,\n    httpHeaders?: HttpHeaders,\n  ): Promise<FaucetResponse> {\n    if (!this.connection.faucet) {\n      throw new Error('Faucet URL is not specified');\n    }\n    return requestSuiFromFaucet(this.connection.faucet, recipient, httpHeaders);\n  }\n\n  /**\n   * Get all Coin<`coin_type`> objects owned by an address.\n   */\n  async getCoins(\n    input: {\n      owner: SuiAddress;\n      coinType?: string | null;\n    } & PaginationArguments<PaginatedCoins['nextCursor']>,\n  ): Promise<PaginatedCoins> {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error('Invalid Sui address');\n    }\n\n    return await this.client.requestWithType(\n      'suix_getCoins',\n      [input.owner, input.coinType, input.cursor, input.limit],\n      PaginatedCoins,\n    );\n  }\n\n  /**\n   * Get all Coin objects owned by an address.\n   */\n  async getAllCoins(\n    input: {\n      owner: SuiAddress;\n    } & PaginationArguments<PaginatedCoins['nextCursor']>,\n  ): Promise<PaginatedCoins> {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error('Invalid Sui address');\n    }\n\n    return await this.client.requestWithType(\n      'suix_getAllCoins',\n      [input.owner, input.cursor, input.limit],\n      PaginatedCoins,\n    );\n  }\n\n  /**\n   * Get the total coin balance for one coin type, owned by the address owner.\n   */\n  async getBalance(input: {\n    owner: SuiAddress;\n    /** optional fully qualified type names for the coin (e.g., 0x168da5bf1f48dafc111b0a488fa454aca95e0b5e::usdc::USDC), default to 0x2::sui::SUI if not specified. */\n    coinType?: string | null;\n  }): Promise<CoinBalance> {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error('Invalid Sui address');\n    }\n    return await this.client.requestWithType(\n      'suix_getBalance',\n      [input.owner, input.coinType],\n      CoinBalance,\n    );\n  }\n\n  /**\n   * Get the total coin balance for all coin types, owned by the address owner.\n   */\n  async getAllBalances(input: { owner: SuiAddress }): Promise<CoinBalance[]> {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error('Invalid Sui address');\n    }\n    return await this.client.requestWithType(\n      'suix_getAllBalances',\n      [input.owner],\n      array(CoinBalance),\n    );\n  }\n\n  /**\n   * Fetch CoinMetadata for a given coin type\n   */\n  async getCoinMetadata(input: {\n    coinType: string;\n  }): Promise<CoinMetadata | null> {\n    return await this.client.requestWithType(\n      'suix_getCoinMetadata',\n      [input.coinType],\n      CoinMetadataStruct,\n    );\n  }\n\n  /**\n   *  Fetch total supply for a coin\n   */\n  async getTotalSupply(input: { coinType: string }): Promise<CoinSupply> {\n    return await this.client.requestWithType(\n      'suix_getTotalSupply',\n      [input.coinType],\n      CoinSupply,\n    );\n  }\n\n  /**\n   * Invoke any RPC method\n   * @param method the method to be invoked\n   * @param args the arguments to be passed to the RPC request\n   */\n  async call(method: string, params: any[]): Promise<any> {\n    return await this.client.request(method, params);\n  }\n\n  /**\n   * Get Move function argument types like read, write and full access\n   */\n  async getMoveFunctionArgTypes(input: {\n    package: string;\n    module: string;\n    function: string;\n  }): Promise<SuiMoveFunctionArgTypes> {\n    return await this.client.requestWithType(\n      'sui_getMoveFunctionArgTypes',\n      [input.package, input.module, input.function],\n      SuiMoveFunctionArgTypes,\n    );\n  }\n\n  /**\n   * Get a map from module name to\n   * structured representations of Move modules\n   */\n  async getNormalizedMoveModulesByPackage(input: {\n    package: string;\n  }): Promise<SuiMoveNormalizedModules> {\n    return await this.client.requestWithType(\n      'sui_getNormalizedMoveModulesByPackage',\n      [input.package],\n      SuiMoveNormalizedModules,\n    );\n  }\n\n  /**\n   * Get a structured representation of Move module\n   */\n  async getNormalizedMoveModule(input: {\n    package: string;\n    module: string;\n  }): Promise<SuiMoveNormalizedModule> {\n    return await this.client.requestWithType(\n      'sui_getNormalizedMoveModule',\n      [input.package, input.module],\n      SuiMoveNormalizedModule,\n    );\n  }\n\n  /**\n   * Get a structured representation of Move function\n   */\n  async getNormalizedMoveFunction(input: {\n    package: string;\n    module: string;\n    function: string;\n  }): Promise<SuiMoveNormalizedFunction> {\n    return await this.client.requestWithType(\n      'sui_getNormalizedMoveFunction',\n      [input.package, input.module, input.function],\n      SuiMoveNormalizedFunction,\n    );\n  }\n\n  /**\n   * Get a structured representation of Move struct\n   */\n  async getNormalizedMoveStruct(input: {\n    package: string;\n    module: string;\n    struct: string;\n  }): Promise<SuiMoveNormalizedStruct> {\n    return await this.client.requestWithType(\n      'sui_getNormalizedMoveStruct',\n      [input.package, input.module, input.struct],\n      SuiMoveNormalizedStruct,\n    );\n  }\n\n  /**\n   * Get all objects owned by an address\n   */\n  async getOwnedObjects(\n    input: {\n      owner: SuiAddress;\n    } & PaginationArguments<PaginatedObjectsResponse['nextCursor']> &\n      SuiObjectResponseQuery,\n  ): Promise<PaginatedObjectsResponse> {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error('Invalid Sui address');\n    }\n\n    return await this.client.requestWithType(\n      'suix_getOwnedObjects',\n      [\n        input.owner,\n        {\n          filter: input.filter,\n          options: input.options,\n        } as SuiObjectResponseQuery,\n        input.cursor,\n        input.limit,\n      ],\n      PaginatedObjectsResponse,\n    );\n  }\n\n  /**\n   * Get details about an object\n   */\n  async getObject(input: {\n    id: ObjectId;\n    options?: SuiObjectDataOptions;\n  }): Promise<SuiObjectResponse> {\n    if (!input.id || !isValidSuiObjectId(normalizeSuiObjectId(input.id))) {\n      throw new Error('Invalid Sui Object id');\n    }\n    return await this.client.requestWithType(\n      'sui_getObject',\n      [input.id, input.options],\n      SuiObjectResponse,\n    );\n  }\n\n  async tryGetPastObject(input: {\n    id: ObjectId;\n    version: number;\n    options?: SuiObjectDataOptions;\n  }): Promise<ObjectRead> {\n    return await this.client.requestWithType(\n      'sui_tryGetPastObject',\n      [input.id, input.version, input.options],\n      ObjectRead,\n    );\n  }\n\n  /**\n   * Batch get details about a list of objects. If any of the object ids are duplicates the call will fail\n   */\n  async multiGetObjects(input: {\n    ids: ObjectId[];\n    options?: SuiObjectDataOptions;\n  }): Promise<SuiObjectResponse[]> {\n    input.ids.forEach((id) => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(`Invalid Sui Object id ${id}`);\n      }\n    });\n    const hasDuplicates = input.ids.length !== new Set(input.ids).size;\n    if (hasDuplicates) {\n      throw new Error(`Duplicate object ids in batch call ${input.ids}`);\n    }\n\n    return await this.client.requestWithType(\n      'sui_multiGetObjects',\n      [input.ids, input.options],\n      array(SuiObjectResponse),\n    );\n  }\n\n  /**\n   * Get transaction blocks for a given query criteria\n   */\n  async queryTransactionBlocks(\n    input: SuiTransactionBlockResponseQuery &\n      PaginationArguments<PaginatedTransactionResponse['nextCursor']> &\n      OrderArguments,\n  ): Promise<PaginatedTransactionResponse> {\n    return await this.client.requestWithType(\n      'suix_queryTransactionBlocks',\n      [\n        {\n          filter: input.filter,\n          options: input.options,\n        } as SuiTransactionBlockResponseQuery,\n        input.cursor,\n        input.limit,\n        (input.order || 'descending') === 'descending',\n      ],\n      PaginatedTransactionResponse,\n    );\n  }\n\n  async getTransactionBlock(input: {\n    digest: TransactionDigest;\n    options?: SuiTransactionBlockResponseOptions;\n  }): Promise<SuiTransactionBlockResponse> {\n    if (!isValidTransactionDigest(input.digest)) {\n      throw new Error('Invalid Transaction digest');\n    }\n    return await this.client.requestWithType(\n      'sui_getTransactionBlock',\n      [input.digest, input.options],\n      SuiTransactionBlockResponse,\n    );\n  }\n\n  async multiGetTransactionBlocks(input: {\n    digests: TransactionDigest[];\n    options?: SuiTransactionBlockResponseOptions;\n  }): Promise<SuiTransactionBlockResponse[]> {\n    input.digests.forEach((d) => {\n      if (!isValidTransactionDigest(d)) {\n        throw new Error(`Invalid Transaction digest ${d}`);\n      }\n    });\n\n    const hasDuplicates = input.digests.length !== new Set(input.digests).size;\n    if (hasDuplicates) {\n      throw new Error(`Duplicate digests in batch call ${input.digests}`);\n    }\n\n    return await this.client.requestWithType(\n      'sui_multiGetTransactionBlocks',\n      [input.digests, input.options],\n      array(SuiTransactionBlockResponse),\n    );\n  }\n\n  async executeTransactionBlock(input: {\n    transactionBlock: Uint8Array | string;\n    signature: SerializedSignature | SerializedSignature[];\n    options?: SuiTransactionBlockResponseOptions;\n    requestType?: ExecuteTransactionRequestType;\n  }): Promise<SuiTransactionBlockResponse> {\n    return await this.client.requestWithType(\n      'sui_executeTransactionBlock',\n      [\n        typeof input.transactionBlock === 'string'\n          ? input.transactionBlock\n          : toB64(input.transactionBlock),\n        Array.isArray(input.signature) ? input.signature : [input.signature],\n        input.options,\n        input.requestType,\n      ],\n      SuiTransactionBlockResponse,\n    );\n  }\n\n  /**\n   * Get total number of transactions\n   */\n\n  async getTotalTransactionBlocks(): Promise<bigint> {\n    const resp = await this.client.requestWithType(\n      'sui_getTotalTransactionBlocks',\n      [],\n      string(),\n    );\n    return BigInt(resp);\n  }\n\n  /**\n   * Getting the reference gas price for the network\n   */\n  async getReferenceGasPrice(): Promise<bigint> {\n    const resp = await this.client.requestWithType(\n      'suix_getReferenceGasPrice',\n      [],\n      string(),\n    );\n    return BigInt(resp);\n  }\n\n  /**\n   * Return the delegated stakes for an address\n   */\n  async getStakes(input: { owner: SuiAddress }): Promise<DelegatedStake[]> {\n    if (!input.owner || !isValidSuiAddress(normalizeSuiAddress(input.owner))) {\n      throw new Error('Invalid Sui address');\n    }\n    return await this.client.requestWithType(\n      'suix_getStakes',\n      [input.owner],\n      array(DelegatedStake),\n    );\n  }\n\n  /**\n   * Return the delegated stakes queried by id.\n   */\n  async getStakesByIds(input: {\n    stakedSuiIds: ObjectId[];\n  }): Promise<DelegatedStake[]> {\n    input.stakedSuiIds.forEach((id) => {\n      if (!id || !isValidSuiObjectId(normalizeSuiObjectId(id))) {\n        throw new Error(`Invalid Sui Stake id ${id}`);\n      }\n    });\n    return await this.client.requestWithType(\n      'suix_getStakesByIds',\n      [input.stakedSuiIds],\n      array(DelegatedStake),\n    );\n  }\n\n  /**\n   * Return the latest system state content.\n   */\n  async getLatestSuiSystemState(): Promise<SuiSystemStateSummary> {\n    return await this.client.requestWithType(\n      'suix_getLatestSuiSystemState',\n      [],\n      SuiSystemStateSummary,\n    );\n  }\n\n  /**\n   * Get events for a given query criteria\n   */\n  async queryEvents(\n    input: {\n      /** the event query criteria. */\n      query: SuiEventFilter;\n    } & PaginationArguments<PaginatedEvents['nextCursor']> &\n      OrderArguments,\n  ): Promise<PaginatedEvents> {\n    return await this.client.requestWithType(\n      'suix_queryEvents',\n      [\n        input.query,\n        input.cursor,\n        input.limit,\n        (input.order || 'descending') === 'descending',\n      ],\n      PaginatedEvents,\n    );\n  }\n\n  /**\n   * Subscribe to get notifications whenever an event matching the filter occurs\n   */\n  async subscribeEvent(input: {\n    /** filter describing the subset of events to follow */\n    filter: SuiEventFilter;\n    /** function to run when we receive a notification of a new event matching the filter */\n    onMessage: (event: SuiEvent) => void;\n  }): Promise<Unsubscribe> {\n    return this.wsClient.request({\n      method: 'suix_subscribeEvent',\n      unsubscribe: 'suix_unsubscribeEvent',\n      params: [input.filter],\n      onMessage: input.onMessage,\n    });\n  }\n\n  async subscribeTransaction(input: {\n    /** filter describing the subset of events to follow */\n    filter: TransactionFilter;\n    /** function to run when we receive a notification of a new event matching the filter */\n    onMessage: (event: TransactionEffects) => void;\n  }): Promise<Unsubscribe> {\n    return this.wsClient.request({\n      method: 'suix_subscribeTransaction',\n      unsubscribe: 'suix_unsubscribeTransaction',\n      params: [input.filter],\n      onMessage: input.onMessage,\n    });\n  }\n\n  /**\n   * Runs the transaction block in dev-inspect mode. Which allows for nearly any\n   * transaction (or Move call) with any arguments. Detailed results are\n   * provided, including both the transaction effects and any return values.\n   */\n  async devInspectTransactionBlock(input: {\n    transactionBlock: TransactionBlock | string | Uint8Array;\n    sender: SuiAddress;\n    /** Default to use the network reference gas price stored in the Sui System State object */\n    gasPrice?: bigint | number | null;\n    /** optional. Default to use the current epoch number stored in the Sui System State object */\n    epoch?: string | null;\n  }): Promise<DevInspectResults> {\n    let devInspectTxBytes;\n    if (TransactionBlock.is(input.transactionBlock)) {\n      input.transactionBlock.setSenderIfNotSet(input.sender);\n      devInspectTxBytes = toB64(\n        await input.transactionBlock.build({\n          provider: this,\n          onlyTransactionKind: true,\n        }),\n      );\n    } else if (typeof input.transactionBlock === 'string') {\n      devInspectTxBytes = input.transactionBlock;\n    } else if (input.transactionBlock instanceof Uint8Array) {\n      devInspectTxBytes = toB64(input.transactionBlock);\n    } else {\n      throw new Error('Unknown transaction block format.');\n    }\n\n    return await this.client.requestWithType(\n      'sui_devInspectTransactionBlock',\n      [input.sender, devInspectTxBytes, input.gasPrice, input.epoch],\n      DevInspectResults,\n    );\n  }\n\n  /**\n   * Dry run a transaction block and return the result.\n   */\n  async dryRunTransactionBlock(input: {\n    transactionBlock: Uint8Array | string;\n  }): Promise<DryRunTransactionBlockResponse> {\n    return await this.client.requestWithType(\n      'sui_dryRunTransactionBlock',\n      [\n        typeof input.transactionBlock === 'string'\n          ? input.transactionBlock\n          : toB64(input.transactionBlock),\n      ],\n      DryRunTransactionBlockResponse,\n    );\n  }\n\n  /**\n   * Return the list of dynamic field objects owned by an object\n   */\n  async getDynamicFields(\n    input: {\n      /** The id of the parent object */\n      parentId: ObjectId;\n    } & PaginationArguments<DynamicFieldPage['nextCursor']>,\n  ): Promise<DynamicFieldPage> {\n    if (\n      !input.parentId ||\n      !isValidSuiObjectId(normalizeSuiObjectId(input.parentId))\n    ) {\n      throw new Error('Invalid Sui Object id');\n    }\n    return await this.client.requestWithType(\n      'suix_getDynamicFields',\n      [input.parentId, input.cursor, input.limit],\n      DynamicFieldPage,\n    );\n  }\n\n  /**\n   * Return the dynamic field object information for a specified object\n   */\n  async getDynamicFieldObject(input: {\n    /** The ID of the quered parent object */\n    parentId: ObjectId;\n    /** The name of the dynamic field */\n    name: string | DynamicFieldName;\n  }): Promise<SuiObjectResponse> {\n    return await this.client.requestWithType(\n      'suix_getDynamicFieldObject',\n      [input.parentId, input.name],\n      SuiObjectResponse,\n    );\n  }\n\n  /**\n   * Get the sequence number of the latest checkpoint that has been executed\n   */\n  async getLatestCheckpointSequenceNumber(): Promise<string> {\n    const resp = await this.client.requestWithType(\n      'sui_getLatestCheckpointSequenceNumber',\n      [],\n      string(),\n    );\n    return String(resp);\n  }\n\n  /**\n   * Returns information about a given checkpoint\n   */\n  async getCheckpoint(input: {\n    /** The checkpoint digest or sequence number */\n    id: CheckpointDigest | string;\n  }): Promise<Checkpoint> {\n    return await this.client.requestWithType(\n      'sui_getCheckpoint',\n      [input.id],\n      Checkpoint,\n    );\n  }\n\n  /**\n   * Returns historical checkpoints paginated\n   */\n  async getCheckpoints(\n    input: {\n      /** query result ordering, default to false (ascending order), oldest record first */\n      descendingOrder: boolean;\n    } & PaginationArguments<CheckpointPage['nextCursor']>,\n  ): Promise<CheckpointPage> {\n    const resp = await this.client.requestWithType(\n      'sui_getCheckpoints',\n      [input.cursor, input?.limit, input.descendingOrder],\n      CheckpointPage,\n    );\n    return resp;\n  }\n\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCommitteeInfo(input?: {\n    /** The epoch of interest. If null, default to the latest epoch */\n    epoch?: string | null;\n  }): Promise<CommitteeInfo> {\n    return await this.client.requestWithType(\n      'suix_getCommitteeInfo',\n      [input?.epoch],\n      CommitteeInfo,\n    );\n  }\n\n  async getNetworkMetrics() {\n    return await this.client.requestWithType(\n      'suix_getNetworkMetrics',\n      [],\n      NetworkMetrics,\n    );\n  }\n\n  async getAddressMetrics() {\n    return await this.client.requestWithType(\n      'suix_getLatestAddressMetrics',\n      [],\n      AddressMetrics,\n    );\n  }\n\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getEpochs(\n    input?: {\n      descendingOrder?: boolean;\n    } & PaginationArguments<EpochPage['nextCursor']>,\n  ): Promise<EpochPage> {\n    return await this.client.requestWithType(\n      'suix_getEpochs',\n      [input?.cursor, input?.limit, input?.descendingOrder],\n      EpochPage,\n    );\n  }\n\n  /**\n   * Returns list of top move calls by usage\n   */\n  async getMoveCallMetrics(): Promise<MoveCallMetrics> {\n    return await this.client.requestWithType(\n      'suix_getMoveCallMetrics',\n      [],\n      MoveCallMetrics,\n    );\n  }\n\n  /**\n   * Return the committee information for the asked epoch\n   */\n  async getCurrentEpoch(): Promise<EpochInfo> {\n    return await this.client.requestWithType(\n      'suix_getCurrentEpoch',\n      [],\n      EpochInfo,\n    );\n  }\n\n  /**\n   * Return the Validators APYs\n   */\n  async getValidatorsApy(): Promise<ValidatorsApy> {\n    return await this.client.requestWithType(\n      'suix_getValidatorsApy',\n      [],\n      ValidatorsApy,\n    );\n  }\n\n  // TODO: Migrate this to `sui_getChainIdentifier` once it is widely available.\n  async getChainIdentifier(): Promise<string> {\n    const checkpoint = await this.getCheckpoint({ id: '0' });\n    const bytes = fromB58(checkpoint.digest);\n    return toHEX(bytes.slice(0, 4));\n  }\n\n  async resolveNameServiceAddress(input: {\n    name: string;\n  }): Promise<SuiAddress | null> {\n    return await this.client.requestWithType(\n      'suix_resolveNameServiceAddress',\n      [input.name],\n      nullable(SuiAddress),\n    );\n  }\n\n  async resolveNameServiceNames(\n    input: {\n      address: string;\n    } & PaginationArguments<ResolvedNameServiceNames['nextCursor']>,\n  ): Promise<ResolvedNameServiceNames> {\n    return await this.client.requestWithType(\n      'suix_resolveNameServiceNames',\n      [input.address],\n      ResolvedNameServiceNames,\n    );\n  }\n\n  async getProtocolConfig(input?: {\n    version?: string;\n  }): Promise<ProtocolConfig> {\n    return await this.client.requestWithType(\n      'sui_getProtocolConfig',\n      [input?.version],\n      ProtocolConfig,\n    );\n  }\n\n  /**\n   * Wait for a transaction block result to be available over the API.\n   * This can be used in conjunction with `executeTransactionBlock` to wait for the transaction to\n   * be available via the API.\n   * This currently polls the `getTransactionBlock` API to check for the transaction.\n   */\n  async waitForTransactionBlock({\n    signal,\n    timeout = 60 * 1000,\n    pollInterval = 2 * 1000,\n    ...input\n  }: {\n    /** An optional abort signal that can be used to cancel */\n    signal?: AbortSignal;\n    /** The amount of time to wait for a transaction block. Defaults to one minute. */\n    timeout?: number;\n    /** The amount of time to wait between checks for the transaction block. Defaults to 2 seconds. */\n    pollInterval?: number;\n  } & Parameters<\n    JsonRpcProvider['getTransactionBlock']\n  >[0]): Promise<SuiTransactionBlockResponse> {\n    const timeoutSignal = AbortSignal.timeout(timeout);\n    const timeoutPromise = new Promise((_, reject) => {\n      timeoutSignal.addEventListener('abort', () =>\n        reject(timeoutSignal.reason),\n      );\n    });\n\n    while (!timeoutSignal.aborted) {\n      signal?.throwIfAborted();\n      try {\n        return await this.getTransactionBlock(input);\n      } catch (e) {\n        // Wait for either the next poll interval, or the timeout.\n        await Promise.race([\n          new Promise((resolve) => setTimeout(resolve, pollInterval)),\n          timeoutPromise,\n        ]);\n      }\n    }\n\n    timeoutSignal.throwIfAborted();\n\n    // This should never happen, because the above case should always throw, but just adding it in the event that something goes horribly wrong.\n    throw new Error('Unexpected error while waiting for transaction block.');\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\ninterface ConnectionOptions {\n  fullnode: string;\n  websocket?: string;\n  faucet?: string;\n}\n\nexport class Connection {\n  #options: ConnectionOptions;\n  constructor(options: ConnectionOptions) {\n    this.#options = options;\n  }\n\n  get fullnode() {\n    return this.#options.fullnode;\n  }\n\n  // TODO: Decide if we should default the websocket URL like this:\n  get websocket() {\n    return this.#options.websocket || this.#options.fullnode;\n  }\n\n  get faucet() {\n    return this.#options.faucet;\n  }\n}\n\n// TODO: Maybe don't have pre-built connections, and instead just have pre-built objects that folks\n// can use with the connection?\nexport const localnetConnection = new Connection({\n  fullnode: 'http://127.0.0.1:9000',\n  faucet: 'http://127.0.0.1:9123/gas',\n});\n\nexport const devnetConnection = new Connection({\n  fullnode: 'https://fullnode.devnet.sui.io:443/',\n  faucet: 'https://faucet.devnet.sui.io/gas',\n});\n\nexport const testnetConnection = new Connection({\n  fullnode: 'https://fullnode.testnet.sui.io:443/',\n  faucet: 'https://faucet.testnet.sui.io/gas',\n});\n\nexport const mainnetConnection = new Connection({\n  fullnode: 'https://fullnode.mainnet.sui.io:443/',\n});\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64 } from '@mysten/bcs';\nimport { is, mask } from 'superstruct';\nimport { JsonRpcProvider } from '../providers/json-rpc-provider';\nimport {\n  extractMutableReference,\n  extractStructTag,\n  getObjectReference,\n  getSharedObjectInitialVersion,\n  normalizeSuiObjectId,\n  ObjectId,\n  SuiMoveNormalizedType,\n  SuiObjectRef,\n  SUI_TYPE_ARG,\n  ProtocolConfig,\n} from '../types';\nimport {\n  Transactions,\n  TransactionArgument,\n  TransactionType,\n  TransactionBlockInput,\n  getTransactionType,\n  MoveCallTransaction,\n} from './Transactions';\nimport {\n  BuilderCallArg,\n  getIdFromCallArg,\n  Inputs,\n  isMutableSharedObjectInput,\n  ObjectCallArg,\n  PureCallArg,\n} from './Inputs';\nimport { getPureSerializationType, isTxContext } from './serializer';\nimport {\n  TransactionBlockDataBuilder,\n  TransactionExpiration,\n} from './TransactionBlockData';\nimport { TRANSACTION_TYPE, create, WellKnownEncoding } from './utils';\n\ntype TransactionResult = TransactionArgument & TransactionArgument[];\n\nconst DefaultOfflineLimits = {\n  maxPureArgumentSize: 16 * 1024,\n  maxTxGas: 50_000_000_000,\n  maxGasObjects: 256,\n  maxTxSizeBytes: 128 * 1024,\n} satisfies Limits;\n\nfunction createTransactionResult(index: number): TransactionResult {\n  const baseResult: TransactionArgument = { kind: 'Result', index };\n\n  const nestedResults: TransactionArgument[] = [];\n  const nestedResultFor = (resultIndex: number): TransactionArgument =>\n    (nestedResults[resultIndex] ??= {\n      kind: 'NestedResult',\n      index,\n      resultIndex,\n    });\n\n  return new Proxy(baseResult, {\n    set() {\n      throw new Error(\n        'The transaction result is a proxy, and does not support setting properties directly',\n      );\n    },\n    // TODO: Instead of making this return a concrete argument, we should ideally\n    // make it reference-based (so that this gets resolved at build-time), which\n    // allows re-ordering transactions.\n    get(target, property) {\n      // This allows this transaction argument to be used in the singular form:\n      if (property in target) {\n        return Reflect.get(target, property);\n      }\n\n      // Support destructuring:\n      if (property === Symbol.iterator) {\n        return function* () {\n          let i = 0;\n          while (true) {\n            yield nestedResultFor(i);\n            i++;\n          }\n        };\n      }\n\n      if (typeof property === 'symbol') return;\n\n      const resultIndex = parseInt(property, 10);\n      if (Number.isNaN(resultIndex) || resultIndex < 0) return;\n      return nestedResultFor(resultIndex);\n    },\n  }) as TransactionResult;\n}\n\nfunction expectProvider(options: BuildOptions): JsonRpcProvider {\n  if (!options.provider) {\n    throw new Error(\n      `No provider passed to Transaction#build, but transaction data was not sufficient to build offline.`,\n    );\n  }\n\n  return options.provider;\n}\n\nconst TRANSACTION_BRAND = Symbol.for('@mysten/transaction');\n\nconst LIMITS = {\n  // The maximum gas that is allowed.\n  maxTxGas: 'max_tx_gas',\n  // The maximum number of gas objects that can be selected for one transaction.\n  maxGasObjects: 'max_gas_payment_objects',\n  // The maximum size (in bytes) that the transaction can be:\n  maxTxSizeBytes: 'max_tx_size_bytes',\n  // The maximum size (in bytes) that pure arguments can be:\n  maxPureArgumentSize: 'max_pure_argument_size',\n} as const;\n\ntype Limits = Partial<Record<keyof typeof LIMITS, number>>;\n\n// An amount of gas (in gas units) that is added to transactions as an overhead to ensure transactions do not fail.\nconst GAS_SAFE_OVERHEAD = 1000n;\n\n// The maximum objects that can be fetched at once using multiGetObjects.\nconst MAX_OBJECTS_PER_FETCH = 50;\n\nconst chunk = <T>(arr: T[], size: number): T[][] =>\n  Array.from({ length: Math.ceil(arr.length / size) }, (_, i) =>\n    arr.slice(i * size, i * size + size),\n  );\n\ninterface BuildOptions {\n  provider?: JsonRpcProvider;\n  onlyTransactionKind?: boolean;\n  /** Define a protocol config to build against, instead of having it fetched from the provider at build time. */\n  protocolConfig?: ProtocolConfig;\n  /** Define limits that are used when building the transaction. In general, we recommend using the protocol configuration instead of defining limits. */\n  limits?: Limits;\n}\n\n/**\n * Transaction Builder\n */\nexport class TransactionBlock {\n  /** Returns `true` if the object is an instance of the Transaction builder class. */\n  static is(obj: unknown): obj is TransactionBlock {\n    return (\n      !!obj &&\n      typeof obj === 'object' &&\n      (obj as any)[TRANSACTION_BRAND] === true\n    );\n  }\n\n  /**\n   * Converts from a serialize transaction kind (built with `build({ onlyTransactionKind: true })`) to a `Transaction` class.\n   * Supports either a byte array, or base64-encoded bytes.\n   */\n  static fromKind(serialized: string | Uint8Array) {\n    const tx = new TransactionBlock();\n\n    tx.#blockData = TransactionBlockDataBuilder.fromKindBytes(\n      typeof serialized === 'string' ? fromB64(serialized) : serialized,\n    );\n\n    return tx;\n  }\n\n  /**\n   * Converts from a serialized transaction format to a `Transaction` class.\n   * There are two supported serialized formats:\n   * - A string returned from `Transaction#serialize`. The serialized format must be compatible, or it will throw an error.\n   * - A byte array (or base64-encoded bytes) containing BCS transaction data.\n   */\n  static from(serialized: string | Uint8Array) {\n    const tx = new TransactionBlock();\n\n    // Check for bytes:\n    if (typeof serialized !== 'string' || !serialized.startsWith('{')) {\n      tx.#blockData = TransactionBlockDataBuilder.fromBytes(\n        typeof serialized === 'string' ? fromB64(serialized) : serialized,\n      );\n    } else {\n      tx.#blockData = TransactionBlockDataBuilder.restore(\n        JSON.parse(serialized),\n      );\n    }\n\n    return tx;\n  }\n\n  /** A helper to retrieve the Transaction builder `Transactions` */\n  static get Transactions() {\n    return Transactions;\n  }\n\n  /** A helper to retrieve the Transaction builder `Inputs` */\n  static get Inputs() {\n    return Inputs;\n  }\n\n  setSender(sender: string) {\n    this.#blockData.sender = sender;\n  }\n  /**\n   * Sets the sender only if it has not already been set.\n   * This is useful for sponsored transaction flows where the sender may not be the same as the signer address.\n   */\n  setSenderIfNotSet(sender: string) {\n    if (!this.#blockData.sender) {\n      this.#blockData.sender = sender;\n    }\n  }\n  setExpiration(expiration?: TransactionExpiration) {\n    this.#blockData.expiration = expiration;\n  }\n  setGasPrice(price: number | bigint) {\n    this.#blockData.gasConfig.price = String(price);\n  }\n  setGasBudget(budget: number | bigint) {\n    this.#blockData.gasConfig.budget = String(budget);\n  }\n  setGasOwner(owner: string) {\n    this.#blockData.gasConfig.owner = owner;\n  }\n  setGasPayment(payments: SuiObjectRef[]) {\n    this.#blockData.gasConfig.payment = payments.map((payment) =>\n      mask(payment, SuiObjectRef),\n    );\n  }\n\n  #blockData: TransactionBlockDataBuilder;\n  /** Get a snapshot of the transaction data, in JSON form: */\n  get blockData() {\n    return this.#blockData.snapshot();\n  }\n\n  // Used to brand transaction classes so that they can be identified, even between multiple copies\n  // of the builder.\n  get [TRANSACTION_BRAND]() {\n    return true;\n  }\n\n  constructor(transaction?: TransactionBlock) {\n    this.#blockData = new TransactionBlockDataBuilder(\n      transaction ? transaction.blockData : undefined,\n    );\n  }\n\n  /** Returns an argument for the gas coin, to be used in a transaction. */\n  get gas(): TransactionArgument {\n    return { kind: 'GasCoin' };\n  }\n\n  /**\n   * Dynamically create a new input, which is separate from the `input`. This is important\n   * for generated clients to be able to define unique inputs that are non-overlapping with the\n   * defined inputs.\n   *\n   * For `Uint8Array` type automatically convert the input into a `Pure` CallArg, since this\n   * is the format required for custom serialization.\n   *\n   */\n  #input(type: 'object' | 'pure', value?: unknown) {\n    const index = this.#blockData.inputs.length;\n    const input = create(\n      {\n        kind: 'Input',\n        // bigints can't be serialized to JSON, so just string-convert them here:\n        value: typeof value === 'bigint' ? String(value) : value,\n        index,\n        type,\n      },\n      TransactionBlockInput,\n    );\n    this.#blockData.inputs.push(input);\n    return input;\n  }\n\n  /**\n   * Add a new object input to the transaction.\n   */\n  object(value: ObjectId | ObjectCallArg) {\n    const id = getIdFromCallArg(value);\n    // deduplicate\n    const inserted = this.#blockData.inputs.find(\n      (i) => i.type === 'object' && id === getIdFromCallArg(i.value),\n    );\n    return inserted ?? this.#input('object', value);\n  }\n\n  /**\n   * Add a new object input to the transaction using the fully-resolved object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  objectRef(...args: Parameters<(typeof Inputs)['ObjectRef']>) {\n    return this.object(Inputs.ObjectRef(...args));\n  }\n\n  /**\n   * Add a new shared object input to the transaction using the fully-resolved shared object reference.\n   * If you only have an object ID, use `builder.object(id)` instead.\n   */\n  sharedObjectRef(...args: Parameters<(typeof Inputs)['SharedObjectRef']>) {\n    return this.object(Inputs.SharedObjectRef(...args));\n  }\n\n  /**\n   * Add a new non-object input to the transaction.\n   */\n  pure(\n    /**\n     * The pure value that will be used as the input value. If this is a Uint8Array, then the value\n     * is assumed to be raw bytes, and will be used directly.\n     */\n    value: unknown,\n    /**\n     * The BCS type to serialize the value into. If not provided, the type will automatically be determined\n     * based on how the input is used.\n     */\n    type?: string,\n  ) {\n    // TODO: we can also do some deduplication here\n    return this.#input(\n      'pure',\n      value instanceof Uint8Array\n        ? Inputs.Pure(value)\n        : type\n        ? Inputs.Pure(value, type)\n        : value,\n    );\n  }\n\n  /** Add a transaction to the transaction block. */\n  add(transaction: TransactionType) {\n    const index = this.#blockData.transactions.push(transaction);\n    return createTransactionResult(index - 1);\n  }\n\n  // Method shorthands:\n\n  splitCoins(...args: Parameters<(typeof Transactions)['SplitCoins']>) {\n    return this.add(Transactions.SplitCoins(...args));\n  }\n  mergeCoins(...args: Parameters<(typeof Transactions)['MergeCoins']>) {\n    return this.add(Transactions.MergeCoins(...args));\n  }\n  publish(...args: Parameters<(typeof Transactions)['Publish']>) {\n    return this.add(Transactions.Publish(...args));\n  }\n  upgrade(...args: Parameters<(typeof Transactions)['Upgrade']>) {\n    return this.add(Transactions.Upgrade(...args));\n  }\n  moveCall(...args: Parameters<(typeof Transactions)['MoveCall']>) {\n    return this.add(Transactions.MoveCall(...args));\n  }\n  transferObjects(\n    ...args: Parameters<(typeof Transactions)['TransferObjects']>\n  ) {\n    return this.add(Transactions.TransferObjects(...args));\n  }\n  makeMoveVec(...args: Parameters<(typeof Transactions)['MakeMoveVec']>) {\n    return this.add(Transactions.MakeMoveVec(...args));\n  }\n\n  /**\n   * Serialize the transaction to a string so that it can be sent to a separate context.\n   * This is different from `build` in that it does not serialize to BCS bytes, and instead\n   * uses a separate format that is unique to the transaction builder. This allows\n   * us to serialize partially-complete transactions, that can then be completed and\n   * built in a separate context.\n   *\n   * For example, a dapp can construct a transaction, but not provide gas objects\n   * or a gas budget. The transaction then can be sent to the wallet, where this\n   * information is automatically filled in (e.g. by querying for coin objects\n   * and performing a dry run).\n   */\n  serialize() {\n    return JSON.stringify(this.#blockData.snapshot());\n  }\n\n  #getConfig(\n    key: keyof typeof LIMITS,\n    { protocolConfig, limits }: BuildOptions,\n  ) {\n    // Use the limits definition if that exists:\n    if (limits && typeof limits[key] === 'number') {\n      return limits[key]!;\n    }\n\n    if (!protocolConfig) {\n      return DefaultOfflineLimits[key];\n    }\n\n    // Fallback to protocol config:\n    const attribute = protocolConfig?.attributes[LIMITS[key]];\n    if (!attribute) {\n      throw new Error(`Missing expected protocol config: \"${LIMITS[key]}\"`);\n    }\n\n    const value =\n      'u64' in attribute\n        ? attribute.u64\n        : 'u32' in attribute\n        ? attribute.u32\n        : attribute.f64;\n\n    if (!value) {\n      throw new Error(\n        `Unexpected protocol config value found for: \"${LIMITS[key]}\"`,\n      );\n    }\n\n    // NOTE: Technically this is not a safe conversion, but we know all of the values in protocol config are safe\n    return Number(value);\n  }\n\n  /** Build the transaction to BCS bytes. */\n  async build(options: BuildOptions = {}): Promise<Uint8Array> {\n    await this.#prepare(options);\n    return this.#blockData.build({\n      maxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n      onlyTransactionKind: options.onlyTransactionKind,\n    });\n  }\n\n  /** Derive transaction digest */\n  async getDigest({\n    provider,\n  }: {\n    provider?: JsonRpcProvider;\n  } = {}): Promise<string> {\n    await this.#prepare({ provider });\n    return this.#blockData.getDigest();\n  }\n\n  #validate(options: BuildOptions) {\n    const maxPureArgumentSize = this.#getConfig('maxPureArgumentSize', options);\n    // Validate all inputs are the correct size:\n    this.#blockData.inputs.forEach((input, index) => {\n      if (is(input.value, PureCallArg)) {\n        if (input.value.Pure.length > maxPureArgumentSize) {\n          throw new Error(\n            `Input at index ${index} is too large, max pure input size is ${maxPureArgumentSize} bytes, got ${input.value.Pure.length} bytes`,\n          );\n        }\n      }\n    });\n  }\n\n  // The current default is just picking _all_ coins we can which may not be ideal.\n  async #prepareGasPayment(options: BuildOptions) {\n    if (this.#blockData.gasConfig.payment) {\n      const maxGasObjects = this.#getConfig('maxGasObjects', options);\n      if (this.#blockData.gasConfig.payment.length > maxGasObjects) {\n        throw new Error(\n          `Payment objects exceed maximum amount: ${maxGasObjects}`,\n        );\n      }\n    }\n\n    // Early return if the payment is already set:\n    if (options.onlyTransactionKind || this.#blockData.gasConfig.payment) {\n      return;\n    }\n\n    const gasOwner = this.#blockData.gasConfig.owner ?? this.#blockData.sender;\n\n    const coins = await expectProvider(options).getCoins({\n      owner: gasOwner!,\n      coinType: SUI_TYPE_ARG,\n    });\n\n    const paymentCoins = coins.data\n      // Filter out coins that are also used as input:\n      .filter((coin) => {\n        const matchingInput = this.#blockData.inputs.find((input) => {\n          if (\n            is(input.value, BuilderCallArg) &&\n            'Object' in input.value &&\n            'ImmOrOwned' in input.value.Object\n          ) {\n            return coin.coinObjectId === input.value.Object.ImmOrOwned.objectId;\n          }\n\n          return false;\n        });\n\n        return !matchingInput;\n      })\n      .slice(0, this.#getConfig('maxGasObjects', options) - 1)\n      .map((coin) => ({\n        objectId: coin.coinObjectId,\n        digest: coin.digest,\n        version: coin.version,\n      }));\n\n    if (!paymentCoins.length) {\n      throw new Error('No valid gas coins found for the transaction.');\n    }\n\n    this.setGasPayment(paymentCoins);\n  }\n\n  async #prepareGasPrice(options: BuildOptions) {\n    if (options.onlyTransactionKind || this.#blockData.gasConfig.price) {\n      return;\n    }\n\n    this.setGasPrice(await expectProvider(options).getReferenceGasPrice());\n  }\n\n  async #prepareTransactions(options: BuildOptions) {\n    const { inputs, transactions } = this.#blockData;\n\n    const moveModulesToResolve: MoveCallTransaction[] = [];\n\n    // Keep track of the object references that will need to be resolved at the end of the transaction.\n    // We keep the input by-reference to avoid needing to re-resolve it:\n    const objectsToResolve: {\n      id: string;\n      input: TransactionBlockInput;\n      normalizedType?: SuiMoveNormalizedType;\n    }[] = [];\n\n    transactions.forEach((transaction) => {\n      // Special case move call:\n      if (transaction.kind === 'MoveCall') {\n        // Determine if any of the arguments require encoding.\n        // - If they don't, then this is good to go.\n        // - If they do, then we need to fetch the normalized move module.\n        const needsResolution = transaction.arguments.some(\n          (arg) =>\n            arg.kind === 'Input' &&\n            !is(inputs[arg.index].value, BuilderCallArg),\n        );\n\n        if (needsResolution) {\n          moveModulesToResolve.push(transaction);\n        }\n\n        return;\n      }\n\n      // Get the matching struct definition for the transaction, and use it to attempt to automatically\n      // encode the matching inputs.\n      const transactionType = getTransactionType(transaction);\n      if (!transactionType.schema) return;\n\n      Object.entries(transaction).forEach(([key, value]) => {\n        if (key === 'kind') return;\n        const keySchema = (transactionType.schema as any)[key];\n        const isArray = keySchema.type === 'array';\n        const wellKnownEncoding: WellKnownEncoding = isArray\n          ? keySchema.schema[TRANSACTION_TYPE]\n          : keySchema[TRANSACTION_TYPE];\n\n        // This argument has unknown encoding, assume it must be fully-encoded:\n        if (!wellKnownEncoding) return;\n\n        const encodeInput = (index: number) => {\n          const input = inputs[index];\n          if (!input) {\n            throw new Error(`Missing input ${value.index}`);\n          }\n\n          // Input is fully resolved:\n          if (is(input.value, BuilderCallArg)) return;\n          if (\n            wellKnownEncoding.kind === 'object' &&\n            typeof input.value === 'string'\n          ) {\n            // The input is a string that we need to resolve to an object reference:\n            objectsToResolve.push({ id: input.value, input });\n          } else if (wellKnownEncoding.kind === 'pure') {\n            // Pure encoding, so construct BCS bytes:\n            input.value = Inputs.Pure(input.value, wellKnownEncoding.type);\n          } else {\n            throw new Error('Unexpected input format.');\n          }\n        };\n\n        if (isArray) {\n          value.forEach((arrayItem: TransactionArgument) => {\n            if (arrayItem.kind !== 'Input') return;\n            encodeInput(arrayItem.index);\n          });\n        } else {\n          if (value.kind !== 'Input') return;\n          encodeInput(value.index);\n        }\n      });\n    });\n\n    if (moveModulesToResolve.length) {\n      await Promise.all(\n        moveModulesToResolve.map(async (moveCall) => {\n          const [packageId, moduleName, functionName] =\n            moveCall.target.split('::');\n\n          const normalized = await expectProvider(\n            options,\n          ).getNormalizedMoveFunction({\n            package: normalizeSuiObjectId(packageId),\n            module: moduleName,\n            function: functionName,\n          });\n\n          // Entry functions can have a mutable reference to an instance of the TxContext\n          // struct defined in the TxContext module as the last parameter. The caller of\n          // the function does not need to pass it in as an argument.\n          const hasTxContext =\n            normalized.parameters.length > 0 &&\n            isTxContext(normalized.parameters.at(-1)!);\n\n          const params = hasTxContext\n            ? normalized.parameters.slice(0, normalized.parameters.length - 1)\n            : normalized.parameters;\n\n          if (params.length !== moveCall.arguments.length) {\n            throw new Error('Incorrect number of arguments.');\n          }\n\n          params.forEach((param, i) => {\n            const arg = moveCall.arguments[i];\n            if (arg.kind !== 'Input') return;\n            const input = inputs[arg.index];\n            // Skip if the input is already resolved\n            if (is(input.value, BuilderCallArg)) return;\n\n            const inputValue = input.value;\n\n            const serType = getPureSerializationType(param, inputValue);\n\n            if (serType) {\n              input.value = Inputs.Pure(inputValue, serType);\n              return;\n            }\n\n            const structVal = extractStructTag(param);\n            if (\n              structVal != null ||\n              (typeof param === 'object' && 'TypeParameter' in param)\n            ) {\n              if (typeof inputValue !== 'string') {\n                throw new Error(\n                  `Expect the argument to be an object id string, got ${JSON.stringify(\n                    inputValue,\n                    null,\n                    2,\n                  )}`,\n                );\n              }\n              objectsToResolve.push({\n                id: inputValue,\n                input,\n                normalizedType: param,\n              });\n              return;\n            }\n\n            throw new Error(\n              `Unknown call arg type ${JSON.stringify(\n                param,\n                null,\n                2,\n              )} for value ${JSON.stringify(inputValue, null, 2)}`,\n            );\n          });\n        }),\n      );\n    }\n\n    if (objectsToResolve.length) {\n      const dedupedIds = [...new Set(objectsToResolve.map(({ id }) => id))];\n      const objectChunks = chunk(dedupedIds, MAX_OBJECTS_PER_FETCH);\n      const objects = (\n        await Promise.all(\n          objectChunks.map((chunk) =>\n            expectProvider(options).multiGetObjects({\n              ids: chunk,\n              options: { showOwner: true },\n            }),\n          ),\n        )\n      ).flat();\n\n      let objectsById = new Map(\n        dedupedIds.map((id, index) => {\n          return [id, objects[index]];\n        }),\n      );\n\n      const invalidObjects = Array.from(objectsById)\n        .filter(([_, obj]) => obj.error)\n        .map(([id, _]) => id);\n      if (invalidObjects.length) {\n        throw new Error(\n          `The following input objects are not invalid: ${invalidObjects.join(\n            ', ',\n          )}`,\n        );\n      }\n\n      objectsToResolve.forEach(({ id, input, normalizedType }) => {\n        const object = objectsById.get(id)!;\n        const initialSharedVersion = getSharedObjectInitialVersion(object);\n\n        if (initialSharedVersion) {\n          // There could be multiple transactions that reference the same shared object.\n          // If one of them is a mutable reference, then we should mark the input\n          // as mutable.\n          const mutable =\n            isMutableSharedObjectInput(input.value) ||\n            (normalizedType != null &&\n              extractMutableReference(normalizedType) != null);\n\n          input.value = Inputs.SharedObjectRef({\n            objectId: id,\n            initialSharedVersion,\n            mutable,\n          });\n        } else {\n          input.value = Inputs.ObjectRef(getObjectReference(object)!);\n        }\n      });\n    }\n  }\n\n  /**\n   * Prepare the transaction by valdiating the transaction data and resolving all inputs\n   * so that it can be built into bytes.\n   */\n  async #prepare(options: BuildOptions) {\n    if (!options.onlyTransactionKind && !this.#blockData.sender) {\n      throw new Error('Missing transaction sender');\n    }\n\n    if (!options.protocolConfig && !options.limits && options.provider) {\n      options.protocolConfig = await options.provider.getProtocolConfig();\n    }\n\n    await Promise.all([\n      this.#prepareGasPrice(options),\n      this.#prepareTransactions(options),\n    ]);\n\n    if (!options.onlyTransactionKind) {\n      await this.#prepareGasPayment(options);\n\n      if (!this.#blockData.gasConfig.budget) {\n        const dryRunResult = await expectProvider(\n          options,\n        ).dryRunTransactionBlock({\n          transactionBlock: this.#blockData.build({\n            maxSizeBytes: this.#getConfig('maxTxSizeBytes', options),\n            overrides: {\n              gasConfig: {\n                budget: String(this.#getConfig('maxTxGas', options)),\n                payment: [],\n              },\n            },\n          }),\n        });\n        if (dryRunResult.effects.status.status !== 'success') {\n          throw new Error(\n            `Dry run failed, could not automatically determine a budget: ${dryRunResult.effects.status.error}`,\n            { cause: dryRunResult },\n          );\n        }\n\n        const safeOverhead =\n          GAS_SAFE_OVERHEAD * BigInt(this.blockData.gasConfig.price || 1n);\n\n        const baseComputationCostWithOverhead =\n          BigInt(dryRunResult.effects.gasUsed.computationCost) + safeOverhead;\n\n        const gasBudget =\n          baseComputationCostWithOverhead +\n          BigInt(dryRunResult.effects.gasUsed.storageCost) -\n          BigInt(dryRunResult.effects.gasUsed.storageRebate);\n\n        // Set the budget to max(computation, computation + storage - rebate)\n        this.setGasBudget(\n          gasBudget > baseComputationCostWithOverhead\n            ? gasBudget\n            : baseComputationCostWithOverhead,\n        );\n      }\n    }\n\n    // Perform final validation on the transaction:\n    this.#validate(options);\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { BCS, fromB64 } from '@mysten/bcs';\nimport {\n  is,\n  any,\n  array,\n  Infer,\n  integer,\n  literal,\n  object,\n  optional,\n  string,\n  union,\n  assert,\n  Struct,\n  define,\n  unknown,\n  record,\n} from 'superstruct';\nimport { ObjectId, normalizeSuiObjectId } from '../types/common';\nimport { TRANSACTION_TYPE, WellKnownEncoding, create } from './utils';\nimport { TypeTagSerializer } from '../signers/txn-data-serializers/type-tag-serializer';\n\nconst option = <T extends Struct<any, any>>(some: T) =>\n  union([\n    object({ None: union([literal(true), literal(null)]) }),\n    object({ Some: some }),\n  ]);\n\nexport const TransactionBlockInput = object({\n  kind: literal('Input'),\n  index: integer(),\n  value: optional(any()),\n  type: optional(union([literal('pure'), literal('object')])),\n});\nexport type TransactionBlockInput = Infer<typeof TransactionBlockInput>;\n\nconst TransactionArgumentTypes = [\n  TransactionBlockInput,\n  object({ kind: literal('GasCoin') }),\n  object({ kind: literal('Result'), index: integer() }),\n  object({\n    kind: literal('NestedResult'),\n    index: integer(),\n    resultIndex: integer(),\n  }),\n] as const;\n\n// Generic transaction argument\nexport const TransactionArgument = union([...TransactionArgumentTypes]);\nexport type TransactionArgument = Infer<typeof TransactionArgument>;\n\n// Transaction argument referring to an object:\nexport const ObjectTransactionArgument = union([...TransactionArgumentTypes]);\n(ObjectTransactionArgument as any)[TRANSACTION_TYPE] = {\n  kind: 'object',\n} as WellKnownEncoding;\n\nexport const PureTransactionArgument = (type: string) => {\n  const struct = union([...TransactionArgumentTypes]);\n  (struct as any)[TRANSACTION_TYPE] = {\n    kind: 'pure',\n    type,\n  } as WellKnownEncoding;\n  return struct;\n};\n\nexport const MoveCallTransaction = object({\n  kind: literal('MoveCall'),\n  target: define<`${string}::${string}::${string}`>(\n    'target',\n    string().validator,\n  ),\n  typeArguments: array(string()),\n  arguments: array(TransactionArgument),\n});\nexport type MoveCallTransaction = Infer<typeof MoveCallTransaction>;\n\nexport const TransferObjectsTransaction = object({\n  kind: literal('TransferObjects'),\n  objects: array(ObjectTransactionArgument),\n  address: PureTransactionArgument(BCS.ADDRESS),\n});\nexport type TransferObjectsTransaction = Infer<\n  typeof TransferObjectsTransaction\n>;\n\nexport const SplitCoinsTransaction = object({\n  kind: literal('SplitCoins'),\n  coin: ObjectTransactionArgument,\n  amounts: array(PureTransactionArgument('u64')),\n});\nexport type SplitCoinsTransaction = Infer<typeof SplitCoinsTransaction>;\n\nexport const MergeCoinsTransaction = object({\n  kind: literal('MergeCoins'),\n  destination: ObjectTransactionArgument,\n  sources: array(ObjectTransactionArgument),\n});\nexport type MergeCoinsTransaction = Infer<typeof MergeCoinsTransaction>;\n\nexport const MakeMoveVecTransaction = object({\n  kind: literal('MakeMoveVec'),\n  // TODO: ideally we should use `TypeTag` instead of `record()` here,\n  // but TypeTag is recursively defined and it's tricky to define a\n  // recursive struct in superstruct\n  type: optional(option(record(string(), unknown()))),\n  objects: array(ObjectTransactionArgument),\n});\nexport type MakeMoveVecTransaction = Infer<typeof MakeMoveVecTransaction>;\n\nexport const PublishTransaction = object({\n  kind: literal('Publish'),\n  modules: array(array(integer())),\n  dependencies: array(ObjectId),\n});\nexport type PublishTransaction = Infer<typeof PublishTransaction>;\n\n// Keep in sync with constants in\n// crates/sui-framework/packages/sui-framework/sources/package.move\nexport enum UpgradePolicy {\n  COMPATIBLE = 0,\n  ADDITIVE = 128,\n  DEP_ONLY = 192,\n}\n\nexport const UpgradeTransaction = object({\n  kind: literal('Upgrade'),\n  modules: array(array(integer())),\n  dependencies: array(ObjectId),\n  packageId: ObjectId,\n  ticket: ObjectTransactionArgument,\n});\nexport type UpgradeTransaction = Infer<typeof UpgradeTransaction>;\n\nconst TransactionTypes = [\n  MoveCallTransaction,\n  TransferObjectsTransaction,\n  SplitCoinsTransaction,\n  MergeCoinsTransaction,\n  PublishTransaction,\n  UpgradeTransaction,\n  MakeMoveVecTransaction,\n] as const;\n\nexport const TransactionType = union([...TransactionTypes]);\nexport type TransactionType = Infer<typeof TransactionType>;\n\nexport function getTransactionType(data: unknown) {\n  assert(data, TransactionType);\n  return TransactionTypes.find((schema) => is(data, schema as Struct))!;\n}\n\n/**\n * Simple helpers used to construct transactions:\n */\nexport const Transactions = {\n  MoveCall(\n    input: Omit<MoveCallTransaction, 'kind' | 'arguments' | 'typeArguments'> & {\n      arguments?: TransactionArgument[];\n      typeArguments?: string[];\n    },\n  ): MoveCallTransaction {\n    return create(\n      {\n        kind: 'MoveCall',\n        target: input.target,\n        arguments: input.arguments ?? [],\n        typeArguments: input.typeArguments ?? [],\n      },\n      MoveCallTransaction,\n    );\n  },\n  TransferObjects(\n    objects: TransactionArgument[],\n    address: TransactionArgument,\n  ): TransferObjectsTransaction {\n    return create(\n      { kind: 'TransferObjects', objects, address },\n      TransferObjectsTransaction,\n    );\n  },\n  SplitCoins(\n    coin: TransactionArgument,\n    amounts: TransactionArgument[],\n  ): SplitCoinsTransaction {\n    return create({ kind: 'SplitCoins', coin, amounts }, SplitCoinsTransaction);\n  },\n  MergeCoins(\n    destination: TransactionArgument,\n    sources: TransactionArgument[],\n  ): MergeCoinsTransaction {\n    return create(\n      { kind: 'MergeCoins', destination, sources },\n      MergeCoinsTransaction,\n    );\n  },\n  Publish({\n    modules,\n    dependencies,\n  }: {\n    modules: number[][] | string[];\n    dependencies: ObjectId[];\n  }): PublishTransaction {\n    return create(\n      {\n        kind: 'Publish',\n        modules: modules.map((module) =>\n          typeof module === 'string' ? Array.from(fromB64(module)) : module,\n        ),\n        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n      },\n      PublishTransaction,\n    );\n  },\n  Upgrade({\n    modules,\n    dependencies,\n    packageId,\n    ticket,\n  }: {\n    modules: number[][] | string[];\n    dependencies: ObjectId[];\n    packageId: ObjectId;\n    ticket: TransactionArgument;\n  }): UpgradeTransaction {\n    return create(\n      {\n        kind: 'Upgrade',\n        modules: modules.map((module) =>\n          typeof module === 'string' ? Array.from(fromB64(module)) : module,\n        ),\n        dependencies: dependencies.map((dep) => normalizeSuiObjectId(dep)),\n        packageId,\n        ticket,\n      },\n      UpgradeTransaction,\n    );\n  },\n  MakeMoveVec({\n    type,\n    objects,\n  }: Omit<MakeMoveVecTransaction, 'kind' | 'type'> & {\n    type?: string;\n  }): MakeMoveVecTransaction {\n    return create(\n      {\n        kind: 'MakeMoveVec',\n        type: type\n          ? { Some: TypeTagSerializer.parseFromStr(type) }\n          : { None: null },\n        objects,\n      },\n      MakeMoveVecTransaction,\n    );\n  },\n};\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { create as superstructCreate, Struct } from 'superstruct';\n\nexport function create<T, S>(value: T, struct: Struct<T, S>): T {\n  return superstructCreate(value, struct);\n}\n\nexport type WellKnownEncoding =\n  | {\n      kind: 'object';\n    }\n  | {\n      kind: 'pure';\n      type: string;\n    };\n\nexport const TRANSACTION_TYPE = Symbol('transaction-argument-type');\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { normalizeSuiAddress, TypeTag } from '../../types';\n\nconst VECTOR_REGEX = /^vector<(.+)>$/;\nconst STRUCT_REGEX = /^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;\n\nexport class TypeTagSerializer {\n  static parseFromStr(str: string, normalizeAddress = false): TypeTag {\n    if (str === 'address') {\n      return { address: null };\n    } else if (str === 'bool') {\n      return { bool: null };\n    } else if (str === 'u8') {\n      return { u8: null };\n    } else if (str === 'u16') {\n      return { u16: null };\n    } else if (str === 'u32') {\n      return { u32: null };\n    } else if (str === 'u64') {\n      return { u64: null };\n    } else if (str === 'u128') {\n      return { u128: null };\n    } else if (str === 'u256') {\n      return { u256: null };\n    } else if (str === 'signer') {\n      return { signer: null };\n    }\n    const vectorMatch = str.match(VECTOR_REGEX);\n    if (vectorMatch) {\n      return {\n        vector: TypeTagSerializer.parseFromStr(\n          vectorMatch[1],\n          normalizeAddress,\n        ),\n      };\n    }\n\n    const structMatch = str.match(STRUCT_REGEX);\n    if (structMatch) {\n      const address = normalizeAddress\n        ? normalizeSuiAddress(structMatch[1])\n        : structMatch[1];\n      return {\n        struct: {\n          address,\n          module: structMatch[2],\n          name: structMatch[3],\n          typeParams:\n            structMatch[5] === undefined\n              ? []\n              : TypeTagSerializer.parseStructTypeArgs(\n                  structMatch[5],\n                  normalizeAddress,\n                ),\n        },\n      };\n    }\n\n    throw new Error(\n      `Encountered unexpected token when parsing type args for ${str}`,\n    );\n  }\n\n  static parseStructTypeArgs(str: string, normalizeAddress = false): TypeTag[] {\n    // split `str` by all `,` outside angle brackets\n    const tok: Array<string> = [];\n    let word = '';\n    let nestedAngleBrackets = 0;\n    for (let i = 0; i < str.length; i++) {\n      const char = str[i];\n      if (char === '<') {\n        nestedAngleBrackets++;\n      }\n      if (char === '>') {\n        nestedAngleBrackets--;\n      }\n      if (nestedAngleBrackets === 0 && char === ',') {\n        tok.push(word.trim());\n        word = '';\n        continue;\n      }\n      word += char;\n    }\n\n    tok.push(word.trim());\n\n    return tok.map((tok) =>\n      TypeTagSerializer.parseFromStr(tok, normalizeAddress),\n    );\n  }\n\n  static tagToString(tag: TypeTag): string {\n    if ('bool' in tag) {\n      return 'bool';\n    }\n    if ('u8' in tag) {\n      return 'u8';\n    }\n    if ('u16' in tag) {\n      return 'u16';\n    }\n    if ('u32' in tag) {\n      return 'u32';\n    }\n    if ('u64' in tag) {\n      return 'u64';\n    }\n    if ('u128' in tag) {\n      return 'u128';\n    }\n    if ('u256' in tag) {\n      return 'u256';\n    }\n    if ('address' in tag) {\n      return 'address';\n    }\n    if ('signer' in tag) {\n      return 'signer';\n    }\n    if ('vector' in tag) {\n      return `vector<${TypeTagSerializer.tagToString(tag.vector)}>`;\n    }\n    if ('struct' in tag) {\n      const struct = tag.struct;\n      const typeParams = struct.typeParams\n        .map(TypeTagSerializer.tagToString)\n        .join(', ');\n      return `${struct.address}::${struct.module}::${struct.name}${\n        typeParams ? `<${typeParams}>` : ''\n      }`;\n    }\n    throw new Error('Invalid TypeTag');\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  array,\n  boolean,\n  Infer,\n  integer,\n  object,\n  string,\n  union,\n} from 'superstruct';\nimport {\n  normalizeSuiAddress,\n  ObjectId,\n  SharedObjectRef,\n  SuiObjectRef,\n} from '../types';\nimport { builder } from './bcs';\n\nconst ObjectArg = union([\n  object({ ImmOrOwned: SuiObjectRef }),\n  object({\n    Shared: object({\n      objectId: string(),\n      initialSharedVersion: union([integer(), string()]),\n      mutable: boolean(),\n    }),\n  }),\n]);\n\nexport const PureCallArg = object({ Pure: array(integer()) });\nexport const ObjectCallArg = object({ Object: ObjectArg });\nexport type PureCallArg = Infer<typeof PureCallArg>;\nexport type ObjectCallArg = Infer<typeof ObjectCallArg>;\n\nexport const BuilderCallArg = union([PureCallArg, ObjectCallArg]);\nexport type BuilderCallArg = Infer<typeof BuilderCallArg>;\n\nexport const Inputs = {\n  Pure(data: unknown, type?: string): PureCallArg {\n    return {\n      Pure: Array.from(\n        data instanceof Uint8Array\n          ? data\n          : // NOTE: We explicitly set this to be growable to infinity, because we have maxSize validation at the builder-level:\n            builder.ser(type!, data, { maxSize: Infinity }).toBytes(),\n      ),\n    };\n  },\n  ObjectRef({ objectId, digest, version }: SuiObjectRef): ObjectCallArg {\n    return {\n      Object: {\n        ImmOrOwned: {\n          digest,\n          version,\n          objectId: normalizeSuiAddress(objectId),\n        },\n      },\n    };\n  },\n  SharedObjectRef({\n    objectId,\n    mutable,\n    initialSharedVersion,\n  }: SharedObjectRef): ObjectCallArg {\n    return {\n      Object: {\n        Shared: {\n          mutable,\n          initialSharedVersion,\n          objectId: normalizeSuiAddress(objectId),\n        },\n      },\n    };\n  },\n};\n\nexport function getIdFromCallArg(arg: ObjectId | ObjectCallArg) {\n  if (typeof arg === 'string') {\n    return normalizeSuiAddress(arg);\n  }\n  if ('ImmOrOwned' in arg.Object) {\n    return normalizeSuiAddress(arg.Object.ImmOrOwned.objectId);\n  }\n  return normalizeSuiAddress(arg.Object.Shared.objectId);\n}\n\nexport function getSharedObjectInput(\n  arg: BuilderCallArg,\n): SharedObjectRef | undefined {\n  return typeof arg === 'object' && 'Object' in arg && 'Shared' in arg.Object\n    ? arg.Object.Shared\n    : undefined;\n}\n\nexport function isSharedObjectInput(arg: BuilderCallArg): boolean {\n  return !!getSharedObjectInput(arg);\n}\n\nexport function isMutableSharedObjectInput(arg: BuilderCallArg): boolean {\n  return getSharedObjectInput(arg)?.mutable ?? false;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { BCS, TypeName } from '@mysten/bcs';\nimport { bcs } from '../types/sui-bcs';\nimport { normalizeSuiAddress, TypeTag } from '../types';\nimport { TypeTagSerializer } from '../signers/txn-data-serializers/type-tag-serializer';\nimport { TransactionArgument, MoveCallTransaction } from './Transactions';\n\nexport const ARGUMENT_INNER = 'Argument';\nexport const VECTOR = 'vector';\nexport const OPTION = 'Option';\nexport const CALL_ARG = 'CallArg';\nexport const TYPE_TAG = 'TypeTag';\nexport const OBJECT_ARG = 'ObjectArg';\nexport const PROGRAMMABLE_TX_BLOCK = 'ProgrammableTransaction';\nexport const PROGRAMMABLE_CALL_INNER = 'ProgrammableMoveCall';\nexport const TRANSACTION_INNER = 'Transaction';\nexport const COMPRESSED_SIGNATURE = 'CompressedSignature';\nexport const PUBLIC_KEY = 'PublicKey';\nexport const MULTISIG_PUBLIC_KEY = 'MultiSigPublicKey';\nexport const MULTISIG_PK_MAP = 'MultiSigPkMap';\nexport const MULTISIG = 'MultiSig';\n\nexport const ENUM_KIND = 'EnumKind';\n\n/** Wrapper around transaction Enum to support `kind` matching in TS */\nexport const TRANSACTION: TypeName = [ENUM_KIND, TRANSACTION_INNER];\n/** Wrapper around Argument Enum to support `kind` matching in TS */\nexport const ARGUMENT: TypeName = [ENUM_KIND, ARGUMENT_INNER];\n\n/** Custom serializer for decoding package, module, function easier */\nexport const PROGRAMMABLE_CALL = 'SimpleProgrammableMoveCall';\n\n/** Transaction types */\n\nexport type Option<T> = { some: T } | { none: true };\n\nexport const builder = new BCS(bcs);\nregisterFixedArray(builder, 'FixedArray[64]', 64);\nregisterFixedArray(builder, 'FixedArray[33]', 33);\nregisterFixedArray(builder, 'FixedArray[32]', 32);\n\nbuilder\n  .registerStructType(PROGRAMMABLE_TX_BLOCK, {\n    inputs: [VECTOR, CALL_ARG],\n    transactions: [VECTOR, TRANSACTION],\n  })\n  .registerEnumType(ARGUMENT_INNER, {\n    GasCoin: null,\n    Input: { index: BCS.U16 },\n    Result: { index: BCS.U16 },\n    NestedResult: { index: BCS.U16, resultIndex: BCS.U16 },\n  })\n  .registerStructType(PROGRAMMABLE_CALL_INNER, {\n    package: BCS.ADDRESS,\n    module: BCS.STRING,\n    function: BCS.STRING,\n    type_arguments: [VECTOR, TYPE_TAG],\n    arguments: [VECTOR, ARGUMENT],\n  })\n  // Keep this in sync with crates/sui-types/src/messages.rs\n  .registerEnumType(TRANSACTION_INNER, {\n    /**\n     * A Move Call - any public Move function can be called via\n     * this transaction. The results can be used that instant to pass\n     * into the next transaction.\n     */\n    MoveCall: PROGRAMMABLE_CALL,\n    /**\n     * Transfer vector of objects to a receiver.\n     */\n    TransferObjects: {\n      objects: [VECTOR, ARGUMENT],\n      address: ARGUMENT,\n    },\n    /**\n     * Split `amount` from a `coin`.\n     */\n    SplitCoins: { coin: ARGUMENT, amounts: [VECTOR, ARGUMENT] },\n    /**\n     * Merge Vector of Coins (`sources`) into a `destination`.\n     */\n    MergeCoins: { destination: ARGUMENT, sources: [VECTOR, ARGUMENT] },\n    /**\n     * Publish a Move module.\n     */\n    Publish: {\n      modules: [VECTOR, [VECTOR, BCS.U8]],\n      dependencies: [VECTOR, BCS.ADDRESS],\n    },\n    /**\n     * Build a vector of objects using the input arguments.\n     * It is impossible to construct a `vector<T: key>` otherwise,\n     * so this call serves a utility function.\n     */\n    MakeMoveVec: {\n      type: [OPTION, TYPE_TAG],\n      objects: [VECTOR, ARGUMENT],\n    },\n    /**  */\n    Upgrade: {\n      modules: [VECTOR, [VECTOR, BCS.U8]],\n      dependencies: [VECTOR, BCS.ADDRESS],\n      packageId: BCS.ADDRESS,\n      ticket: ARGUMENT,\n    },\n  })\n  .registerEnumType(COMPRESSED_SIGNATURE, {\n    ED25519: ['FixedArray[64]', 'u8'],\n    Secp256k1: ['FixedArray[64]', 'u8'],\n    Secp256r1: ['FixedArray[64]', 'u8'],\n  })\n  .registerEnumType(PUBLIC_KEY, {\n    ED25519: ['FixedArray[32]', 'u8'],\n    Secp256k1: ['FixedArray[33]', 'u8'],\n    Secp256r1: ['FixedArray[33]', 'u8'],\n  })\n  .registerStructType(MULTISIG_PK_MAP, {\n    pubKey: PUBLIC_KEY,\n    weight: BCS.U8,\n  })\n  .registerStructType(MULTISIG_PUBLIC_KEY, {\n    pk_map: [VECTOR, MULTISIG_PK_MAP],\n    threshold: BCS.U16,\n  })\n  .registerStructType(MULTISIG, {\n    sigs: [VECTOR, COMPRESSED_SIGNATURE],\n    bitmap: BCS.U16,\n    multisig_pk: MULTISIG_PUBLIC_KEY,\n  });\n/**\n * Utilities for better decoding.\n */\n\ntype ProgrammableCallInner = {\n  package: string;\n  module: string;\n  function: string;\n  type_arguments: TypeTag[];\n  arguments: TransactionArgument[];\n};\n\n/**\n * Wrapper around Enum, which transforms any `T` into an object with `kind` property:\n * @example\n * ```\n * let bcsEnum = { TransferObjects: { objects: [], address: ... } }\n * // becomes\n * let translatedEnum = { kind: 'TransferObjects', objects: [], address: ... };\n * ```\n */\nbuilder.registerType(\n  [ENUM_KIND, 'T'],\n  function encode(\n    this: BCS,\n    writer,\n    data: { kind: string },\n    typeParams,\n    typeMap,\n  ) {\n    const kind = data.kind;\n    const invariant = { [kind]: data };\n    const [enumType] = typeParams;\n\n    return this.getTypeInterface(enumType as string)._encodeRaw.call(\n      this,\n      writer,\n      invariant,\n      typeParams,\n      typeMap,\n    );\n  },\n  function decode(this: BCS, reader, typeParams, typeMap) {\n    const [enumType] = typeParams;\n    const data = this.getTypeInterface(enumType as string)._decodeRaw.call(\n      this,\n      reader,\n      typeParams,\n      typeMap,\n    );\n\n    // enum invariant can only have one `key` field\n    const kind = Object.keys(data)[0];\n    return { kind, ...data[kind] };\n  },\n  (data: { kind: string }) => {\n    if (typeof data !== 'object' && !('kind' in data)) {\n      throw new Error(\n        `EnumKind: Missing property \"kind\" in the input ${JSON.stringify(\n          data,\n        )}`,\n      );\n    }\n\n    return true;\n  },\n);\n\n/**\n * Custom deserializer for the ProgrammableCall.\n *\n * Hides the inner structure and gives a simpler, more convenient\n * interface to encode and decode this struct as a part of `TransactionData`.\n *\n * - `(package)::(module)::(function)` are now `target` property.\n * - `TypeTag[]` array is now passed as strings, not as a struct.\n */\nbuilder.registerType(\n  PROGRAMMABLE_CALL,\n  function encodeProgrammableTx(\n    this: BCS,\n    writer,\n    data: MoveCallTransaction,\n    typeParams,\n    typeMap,\n  ) {\n    const [pkg, module, fun] = data.target.split('::');\n    const type_arguments = data.typeArguments.map((tag) =>\n      TypeTagSerializer.parseFromStr(tag, true),\n    );\n\n    return this.getTypeInterface(PROGRAMMABLE_CALL_INNER)._encodeRaw.call(\n      this,\n      writer,\n      {\n        package: normalizeSuiAddress(pkg),\n        module,\n        function: fun,\n        type_arguments,\n        arguments: data.arguments,\n      } as ProgrammableCallInner,\n      typeParams,\n      typeMap,\n    );\n  },\n  function decodeProgrammableTx(this: BCS, reader, typeParams, typeMap) {\n    let data: ProgrammableCallInner = builder\n      .getTypeInterface(PROGRAMMABLE_CALL_INNER)\n      ._decodeRaw.call(this, reader, typeParams, typeMap);\n\n    return {\n      target: [data.package, data.module, data.function].join('::'),\n      arguments: data.arguments,\n      typeArguments: data.type_arguments.map(TypeTagSerializer.tagToString),\n    };\n  },\n  // Validation callback to error out if the data format is invalid.\n  // TODO: make sure TypeTag can be parsed.\n  (data: MoveCallTransaction) => {\n    return data.target.split('::').length === 3;\n  },\n);\n\nfunction registerFixedArray(bcs: BCS, name: string, length: number) {\n  bcs.registerType(\n    name,\n    function encode(this: BCS, writer, data, typeParams, typeMap) {\n      if (data.length !== length) {\n        throw new Error(\n          `Expected fixed array of length ${length}, got ${data.length}`,\n        );\n      }\n\n      if (typeParams.length !== 1) {\n        throw new Error(\n          `Expected one type parameter in a fixed array, got ${typeParams.length}`,\n        );\n      }\n\n      let [type] =\n        typeof typeParams[0] === 'string' ? [typeParams[0], []] : typeParams[0];\n\n      for (let piece of data) {\n        this.getTypeInterface(type)._encodeRaw.call(\n          this,\n          writer,\n          piece,\n          typeParams,\n          typeMap,\n        );\n      }\n\n      return writer;\n    },\n    function decode(this: BCS, reader, typeParams, typeMap) {\n      if (typeParams.length !== 1) {\n        throw new Error(\n          `Expected one type parameter in a fixed array, got ${typeParams.length}`,\n        );\n      }\n\n      let result: any = [];\n      let [type] =\n        typeof typeParams[0] === 'string' ? [typeParams[0], []] : typeParams[0];\n\n      for (let i = 0; i < length; i++) {\n        result.push(\n          this.getTypeInterface(type)._decodeRaw.call(\n            this,\n            reader,\n            typeParams,\n            typeMap,\n          ),\n        );\n      }\n\n      return result;\n    },\n  );\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n  extractStructTag,\n  ID_STRUCT_NAME,\n  isValidSuiAddress,\n  MOVE_STDLIB_ADDRESS,\n  OBJECT_MODULE_NAME,\n  SuiJsonValue,\n  SuiMoveNormalizedType,\n  SUI_FRAMEWORK_ADDRESS,\n} from '../types';\n\nconst STD_ASCII_MODULE_NAME = 'ascii';\nconst STD_ASCII_STRUCT_NAME = 'String';\n\nconst STD_UTF8_MODULE_NAME = 'string';\nconst STD_UTF8_STRUCT_NAME = 'String';\n\nconst STD_OPTION_MODULE_NAME = 'option';\nconst STD_OPTION_STRUCT_NAME = 'Option';\n\nconst RESOLVED_SUI_ID = {\n  address: SUI_FRAMEWORK_ADDRESS,\n  module: OBJECT_MODULE_NAME,\n  name: ID_STRUCT_NAME,\n};\nconst RESOLVED_ASCII_STR = {\n  address: MOVE_STDLIB_ADDRESS,\n  module: STD_ASCII_MODULE_NAME,\n  name: STD_ASCII_STRUCT_NAME,\n};\nconst RESOLVED_UTF8_STR = {\n  address: MOVE_STDLIB_ADDRESS,\n  module: STD_UTF8_MODULE_NAME,\n  name: STD_UTF8_STRUCT_NAME,\n};\n\nconst RESOLVED_STD_OPTION = {\n  address: MOVE_STDLIB_ADDRESS,\n  module: STD_OPTION_MODULE_NAME,\n  name: STD_OPTION_STRUCT_NAME,\n};\n\nconst isSameStruct = (a: any, b: any) =>\n  a.address === b.address && a.module === b.module && a.name === b.name;\n\nexport function isTxContext(param: SuiMoveNormalizedType): boolean {\n  const struct = extractStructTag(param)?.Struct;\n  return (\n    struct?.address === '0x2' &&\n    struct?.module === 'tx_context' &&\n    struct?.name === 'TxContext'\n  );\n}\n\nfunction expectType(typeName: string, argVal?: SuiJsonValue) {\n  if (typeof argVal === 'undefined') {\n    return;\n  }\n  if (typeof argVal !== typeName) {\n    throw new Error(\n      `Expect ${argVal} to be ${typeName}, received ${typeof argVal}`,\n    );\n  }\n}\n\nconst allowedTypes = [\n  'Address',\n  'Bool',\n  'U8',\n  'U16',\n  'U32',\n  'U64',\n  'U128',\n  'U256',\n];\n\nexport function getPureSerializationType(\n  normalizedType: SuiMoveNormalizedType,\n  argVal: SuiJsonValue | undefined,\n): string | undefined {\n  if (\n    typeof normalizedType === 'string' &&\n    allowedTypes.includes(normalizedType)\n  ) {\n    if (normalizedType in ['U8', 'U16', 'U32', 'U64', 'U128', 'U256']) {\n      expectType('number', argVal);\n    } else if (normalizedType === 'Bool') {\n      expectType('boolean', argVal);\n    } else if (normalizedType === 'Address') {\n      expectType('string', argVal);\n      if (argVal && !isValidSuiAddress(argVal as string)) {\n        throw new Error('Invalid Sui Address');\n      }\n    }\n    return normalizedType.toLowerCase();\n  } else if (typeof normalizedType === 'string') {\n    throw new Error(\n      `Unknown pure normalized type ${JSON.stringify(normalizedType, null, 2)}`,\n    );\n  }\n\n  if ('Vector' in normalizedType) {\n    if (\n      (argVal === undefined || typeof argVal === 'string') &&\n      normalizedType.Vector === 'U8'\n    ) {\n      return 'string';\n    }\n\n    if (argVal !== undefined && !Array.isArray(argVal)) {\n      throw new Error(\n        `Expect ${argVal} to be a array, received ${typeof argVal}`,\n      );\n    }\n\n    const innerType = getPureSerializationType(\n      normalizedType.Vector,\n      // undefined when argVal is empty\n      argVal ? argVal[0] : undefined,\n    );\n\n    if (innerType === undefined) {\n      return;\n    }\n\n    return `vector<${innerType}>`;\n  }\n\n  if ('Struct' in normalizedType) {\n    if (isSameStruct(normalizedType.Struct, RESOLVED_ASCII_STR)) {\n      return 'string';\n    } else if (isSameStruct(normalizedType.Struct, RESOLVED_UTF8_STR)) {\n      return 'utf8string';\n    } else if (isSameStruct(normalizedType.Struct, RESOLVED_SUI_ID)) {\n      return 'address';\n    } else if (isSameStruct(normalizedType.Struct, RESOLVED_STD_OPTION)) {\n      const optionToVec: SuiMoveNormalizedType = {\n        Vector: normalizedType.Struct.typeArguments[0],\n      };\n      return getPureSerializationType(optionToVec, argVal);\n    }\n  }\n\n  return undefined;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from '@mysten/bcs';\nimport {\n  array,\n  assert,\n  define,\n  Infer,\n  integer,\n  is,\n  literal,\n  nullable,\n  object,\n  optional,\n  string,\n  union,\n} from 'superstruct';\nimport { hashTypedData } from '../cryptography/hash';\nimport { normalizeSuiAddress, SuiObjectRef } from '../types';\nimport { builder } from './bcs';\nimport { TransactionType, TransactionBlockInput } from './Transactions';\nimport { BuilderCallArg, PureCallArg } from './Inputs';\nimport { create } from './utils';\n\nexport const TransactionExpiration = optional(\n  nullable(\n    union([\n      object({ Epoch: integer() }),\n      object({ None: union([literal(true), literal(null)]) }),\n    ]),\n  ),\n);\nexport type TransactionExpiration = Infer<typeof TransactionExpiration>;\n\nconst SuiAddress = string();\n\nconst StringEncodedBigint = define<string>('StringEncodedBigint', (val) => {\n  if (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n  try {\n    BigInt(val as string);\n    return true;\n  } catch {\n    return false;\n  }\n});\n\nconst GasConfig = object({\n  budget: optional(StringEncodedBigint),\n  price: optional(StringEncodedBigint),\n  payment: optional(array(SuiObjectRef)),\n  owner: optional(SuiAddress),\n});\ntype GasConfig = Infer<typeof GasConfig>;\n\nexport const SerializedTransactionDataBuilder = object({\n  version: literal(1),\n  sender: optional(SuiAddress),\n  expiration: TransactionExpiration,\n  gasConfig: GasConfig,\n  inputs: array(TransactionBlockInput),\n  transactions: array(TransactionType),\n});\nexport type SerializedTransactionDataBuilder = Infer<\n  typeof SerializedTransactionDataBuilder\n>;\n\nfunction prepareSuiAddress(address: string) {\n  return normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionBlockDataBuilder {\n  static fromKindBytes(bytes: Uint8Array) {\n    const kind = builder.de('TransactionKind', bytes);\n    const programmableTx = kind?.ProgrammableTransaction;\n    if (!programmableTx) {\n      throw new Error('Unable to deserialize from bytes.');\n    }\n\n    const serialized = create(\n      {\n        version: 1,\n        gasConfig: {},\n        inputs: programmableTx.inputs.map((value: unknown, index: number) =>\n          create(\n            {\n              kind: 'Input',\n              value,\n              index,\n              type: is(value, PureCallArg) ? 'pure' : 'object',\n            },\n            TransactionBlockInput,\n          ),\n        ),\n        transactions: programmableTx.transactions,\n      },\n      SerializedTransactionDataBuilder,\n    );\n\n    return TransactionBlockDataBuilder.restore(serialized);\n  }\n\n  static fromBytes(bytes: Uint8Array) {\n    const rawData = builder.de('TransactionData', bytes);\n    const data = rawData?.V1;\n    const programmableTx = data?.kind?.ProgrammableTransaction;\n    if (!data || !programmableTx) {\n      throw new Error('Unable to deserialize from bytes.');\n    }\n\n    const serialized = create(\n      {\n        version: 1,\n        sender: data.sender,\n        expiration: data.expiration,\n        gasConfig: data.gasData,\n        inputs: programmableTx.inputs.map((value: unknown, index: number) =>\n          create(\n            {\n              kind: 'Input',\n              value,\n              index,\n              type: is(value, PureCallArg) ? 'pure' : 'object',\n            },\n            TransactionBlockInput,\n          ),\n        ),\n        transactions: programmableTx.transactions,\n      },\n      SerializedTransactionDataBuilder,\n    );\n\n    return TransactionBlockDataBuilder.restore(serialized);\n  }\n\n  static restore(data: SerializedTransactionDataBuilder) {\n    assert(data, SerializedTransactionDataBuilder);\n    const transactionData = new TransactionBlockDataBuilder();\n    Object.assign(transactionData, data);\n    return transactionData;\n  }\n\n  /**\n   * Generate transaction digest.\n   *\n   * @param bytes BCS serialized transaction data\n   * @returns transaction digest.\n   */\n  static getDigestFromBytes(bytes: Uint8Array) {\n    const hash = hashTypedData('TransactionData', bytes);\n    return toB58(hash);\n  }\n\n  version = 1 as const;\n  sender?: string;\n  expiration?: TransactionExpiration;\n  gasConfig: GasConfig;\n  inputs: TransactionBlockInput[];\n  transactions: TransactionType[];\n\n  constructor(clone?: SerializedTransactionDataBuilder) {\n    this.sender = clone?.sender;\n    this.expiration = clone?.expiration;\n    this.gasConfig = clone?.gasConfig ?? {};\n    this.inputs = clone?.inputs ?? [];\n    this.transactions = clone?.transactions ?? [];\n  }\n\n  build({\n    maxSizeBytes = Infinity,\n    overrides,\n    onlyTransactionKind,\n  }: {\n    maxSizeBytes?: number;\n    overrides?: Pick<\n      Partial<TransactionBlockDataBuilder>,\n      'sender' | 'gasConfig' | 'expiration'\n    >;\n    onlyTransactionKind?: boolean;\n  } = {}) {\n    // Resolve inputs down to values:\n    const inputs = this.inputs.map((input) => {\n      assert(input.value, BuilderCallArg);\n      return input.value;\n    });\n\n    const kind = {\n      ProgrammableTransaction: {\n        inputs,\n        transactions: this.transactions,\n      },\n    };\n\n    if (onlyTransactionKind) {\n      return builder\n        .ser('TransactionKind', kind, { maxSize: maxSizeBytes })\n        .toBytes();\n    }\n\n    const expiration = overrides?.expiration ?? this.expiration;\n    const sender = overrides?.sender ?? this.sender;\n    const gasConfig = { ...this.gasConfig, ...overrides?.gasConfig };\n\n    if (!sender) {\n      throw new Error('Missing transaction sender');\n    }\n\n    if (!gasConfig.budget) {\n      throw new Error('Missing gas budget');\n    }\n\n    if (!gasConfig.payment) {\n      throw new Error('Missing gas payment');\n    }\n\n    if (!gasConfig.price) {\n      throw new Error('Missing gas price');\n    }\n\n    const transactionData = {\n      sender: prepareSuiAddress(sender),\n      expiration: expiration ? expiration : { None: true },\n      gasData: {\n        payment: gasConfig.payment,\n        owner: prepareSuiAddress(this.gasConfig.owner ?? sender),\n        price: BigInt(gasConfig.price),\n        budget: BigInt(gasConfig.budget),\n      },\n      kind: {\n        ProgrammableTransaction: {\n          inputs,\n          transactions: this.transactions,\n        },\n      },\n    };\n\n    return builder\n      .ser(\n        'TransactionData',\n        { V1: transactionData },\n        { maxSize: maxSizeBytes },\n      )\n      .toBytes();\n  }\n\n  getDigest() {\n    const bytes = this.build({ onlyTransactionKind: false });\n    return TransactionBlockDataBuilder.getDigestFromBytes(bytes);\n  }\n\n  snapshot(): SerializedTransactionDataBuilder {\n    return create(this, SerializedTransactionDataBuilder);\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\n\n/**\n * Generates a Blake2b hash of typed data as a base64 string.\n *\n * @param typeTag type tag (e.g. TransactionData, SenderSignedData)\n * @param data data to hash\n */\nexport function hashTypedData(typeTag: string, data: Uint8Array): Uint8Array {\n  const typeTagBytes = Array.from(`${typeTag}::`).map((e) => e.charCodeAt(0));\n\n  const dataWithTag = new Uint8Array(typeTagBytes.length + data.length);\n  dataWithTag.set(typeTagBytes);\n  dataWithTag.set(data, typeTagBytes.length);\n\n  return blake2b(dataWithTag, { dkLen: 32 });\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { number, object, string } from 'superstruct';\n\nexport const NetworkMetrics = object({\n  currentTps: number(),\n  tps30Days: number(),\n  currentCheckpoint: string(),\n  currentEpoch: string(),\n  totalAddresses: string(),\n  totalObjects: string(),\n  totalPackages: string(),\n});\n\nexport const AddressMetrics = object({\n  checkpoint: number(),\n  epoch: number(),\n  timestampMs: number(),\n  cumulativeAddresses: number(),\n  cumulativeActiveAddresses: number(),\n  dailyActiveAddresses: number(),\n});\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { blake2b } from '@noble/hashes/blake2b';\nimport { Keypair } from '../cryptography/keypair';\nimport {\n  SerializedSignature,\n  toSerializedSignature,\n} from '../cryptography/signature';\nimport { JsonRpcProvider } from '../providers/json-rpc-provider';\nimport { SuiAddress } from '../types';\nimport { SignerWithProvider } from './signer-with-provider';\n\nexport class RawSigner extends SignerWithProvider {\n  private readonly keypair: Keypair;\n\n  constructor(keypair: Keypair, provider: JsonRpcProvider) {\n    super(provider);\n    this.keypair = keypair;\n  }\n\n  async getAddress(): Promise<SuiAddress> {\n    return this.keypair.getPublicKey().toSuiAddress();\n  }\n\n  async signData(data: Uint8Array): Promise<SerializedSignature> {\n    const pubkey = this.keypair.getPublicKey();\n    const digest = blake2b(data, { dkLen: 32 });\n    const signature = this.keypair.signData(digest);\n    const signatureScheme = this.keypair.getKeyScheme();\n\n    return toSerializedSignature({\n      signatureScheme,\n      signature,\n      pubKey: pubkey,\n    });\n  }\n\n  connect(provider: JsonRpcProvider): SignerWithProvider {\n    return new RawSigner(this.keypair, provider);\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64, toB64 } from '@mysten/bcs';\nimport { TransactionBlock } from '../builder';\nimport { TransactionBlockDataBuilder } from '../builder/TransactionBlockData';\nimport { SerializedSignature } from '../cryptography/signature';\nimport { JsonRpcProvider } from '../providers/json-rpc-provider';\nimport { HttpHeaders } from '../rpc/client';\nimport {\n  ExecuteTransactionRequestType,\n  FaucetResponse,\n  getTotalGasUsedUpperBound,\n  SuiAddress,\n  DevInspectResults,\n  DryRunTransactionBlockResponse,\n  SuiTransactionBlockResponse,\n  SuiTransactionBlockResponseOptions,\n} from '../types';\nimport { IntentScope, messageWithIntent } from '../utils/intent';\nimport { Signer } from './signer';\nimport { SignedTransaction, SignedMessage } from './types';\n\n///////////////////////////////\n// Exported Abstracts\nexport abstract class SignerWithProvider implements Signer {\n  readonly provider: JsonRpcProvider;\n\n  ///////////////////\n  // Sub-classes MUST implement these\n\n  // Returns the checksum address\n  abstract getAddress(): Promise<SuiAddress>;\n\n  /**\n   * Returns the signature for the data and the public key of the signer\n   */\n  abstract signData(data: Uint8Array): Promise<SerializedSignature>;\n\n  // Returns a new instance of the Signer, connected to provider.\n  // This MAY throw if changing providers is not supported.\n  abstract connect(provider: JsonRpcProvider): SignerWithProvider;\n\n  ///////////////////\n  // Sub-classes MAY override these\n\n  /**\n   * Request gas tokens from a faucet server and send to the signer\n   * address\n   * @param httpHeaders optional request headers\n   */\n  async requestSuiFromFaucet(\n    httpHeaders?: HttpHeaders,\n  ): Promise<FaucetResponse> {\n    return this.provider.requestSuiFromFaucet(\n      await this.getAddress(),\n      httpHeaders,\n    );\n  }\n\n  constructor(provider: JsonRpcProvider) {\n    this.provider = provider;\n  }\n\n  /**\n   * Sign a message using the keypair, with the `PersonalMessage` intent.\n   */\n  async signMessage(input: { message: Uint8Array }): Promise<SignedMessage> {\n    const signature = await this.signData(\n      messageWithIntent(IntentScope.PersonalMessage, input.message),\n    );\n\n    return {\n      messageBytes: toB64(input.message),\n      signature,\n    };\n  }\n\n  protected async prepareTransactionBlock(\n    transactionBlock: Uint8Array | TransactionBlock,\n  ) {\n    if (TransactionBlock.is(transactionBlock)) {\n      // If the sender has not yet been set on the transaction, then set it.\n      // NOTE: This allows for signing transactions with mis-matched senders, which is important for sponsored transactions.\n      transactionBlock.setSenderIfNotSet(await this.getAddress());\n      return await transactionBlock.build({\n        provider: this.provider,\n      });\n    }\n    if (transactionBlock instanceof Uint8Array) {\n      return transactionBlock;\n    }\n    throw new Error('Unknown transaction format');\n  }\n\n  /**\n   * Sign a transaction.\n   */\n  async signTransactionBlock(input: {\n    transactionBlock: Uint8Array | TransactionBlock;\n  }): Promise<SignedTransaction> {\n    const transactionBlockBytes = await this.prepareTransactionBlock(\n      input.transactionBlock,\n    );\n\n    const intentMessage = messageWithIntent(\n      IntentScope.TransactionData,\n      transactionBlockBytes,\n    );\n    const signature = await this.signData(intentMessage);\n\n    return {\n      transactionBlockBytes: toB64(transactionBlockBytes),\n      signature,\n    };\n  }\n\n  /**\n   * Sign a transaction block and submit to the Fullnode for execution.\n   *\n   * @param options specify which fields to return (e.g., transaction, effects, events, etc).\n   * By default, only the transaction digest will be returned.\n   * @param requestType WaitForEffectsCert or WaitForLocalExecution, see details in `ExecuteTransactionRequestType`.\n   * Defaults to `WaitForLocalExecution` if options.show_effects or options.show_events is true\n   */\n  async signAndExecuteTransactionBlock(input: {\n    transactionBlock: Uint8Array | TransactionBlock;\n    /** specify which fields to return (e.g., transaction, effects, events, etc). By default, only the transaction digest will be returned. */\n    options?: SuiTransactionBlockResponseOptions;\n    /** `WaitForEffectsCert` or `WaitForLocalExecution`, see details in `ExecuteTransactionRequestType`.\n     * Defaults to `WaitForLocalExecution` if options.show_effects or options.show_events is true\n     */\n    requestType?: ExecuteTransactionRequestType;\n  }): Promise<SuiTransactionBlockResponse> {\n    const { transactionBlockBytes, signature } =\n      await this.signTransactionBlock({\n        transactionBlock: input.transactionBlock,\n      });\n\n    return await this.provider.executeTransactionBlock({\n      transactionBlock: transactionBlockBytes,\n      signature,\n      options: input.options,\n      requestType: input.requestType,\n    });\n  }\n\n  /**\n   * Derive transaction digest from\n   * @param tx BCS serialized transaction data or a `Transaction` object\n   * @returns transaction digest\n   */\n  async getTransactionBlockDigest(\n    tx: Uint8Array | TransactionBlock,\n  ): Promise<string> {\n    if (TransactionBlock.is(tx)) {\n      tx.setSenderIfNotSet(await this.getAddress());\n      return tx.getDigest({ provider: this.provider });\n    } else if (tx instanceof Uint8Array) {\n      return TransactionBlockDataBuilder.getDigestFromBytes(tx);\n    } else {\n      throw new Error('Unknown transaction format.');\n    }\n  }\n\n  /**\n   * Runs the transaction in dev-inpsect mode. Which allows for nearly any\n   * transaction (or Move call) with any arguments. Detailed results are\n   * provided, including both the transaction effects and any return values.\n   */\n  async devInspectTransactionBlock(\n    input: Omit<\n      Parameters<JsonRpcProvider['devInspectTransactionBlock']>[0],\n      'sender'\n    >,\n  ): Promise<DevInspectResults> {\n    const address = await this.getAddress();\n    return this.provider.devInspectTransactionBlock({\n      sender: address,\n      ...input,\n    });\n  }\n\n  /**\n   * Dry run a transaction and return the result.\n   */\n  async dryRunTransactionBlock(input: {\n    transactionBlock: TransactionBlock | string | Uint8Array;\n  }): Promise<DryRunTransactionBlockResponse> {\n    let dryRunTxBytes: Uint8Array;\n    if (TransactionBlock.is(input.transactionBlock)) {\n      input.transactionBlock.setSenderIfNotSet(await this.getAddress());\n      dryRunTxBytes = await input.transactionBlock.build({\n        provider: this.provider,\n      });\n    } else if (typeof input.transactionBlock === 'string') {\n      dryRunTxBytes = fromB64(input.transactionBlock);\n    } else if (input.transactionBlock instanceof Uint8Array) {\n      dryRunTxBytes = input.transactionBlock;\n    } else {\n      throw new Error('Unknown transaction format');\n    }\n\n    return this.provider.dryRunTransactionBlock({\n      transactionBlock: dryRunTxBytes,\n    });\n  }\n\n  /**\n   * Returns the estimated gas cost for the transaction\n   * @param tx The transaction to estimate the gas cost. When string it is assumed it's a serialized tx in base64\n   * @returns total gas cost estimation\n   * @throws whens fails to estimate the gas cost\n   */\n  async getGasCostEstimation(\n    ...args: Parameters<SignerWithProvider['dryRunTransactionBlock']>\n  ) {\n    const txEffects = await this.dryRunTransactionBlock(...args);\n    const gasEstimation = getTotalGasUsedUpperBound(txEffects.effects);\n    if (typeof gasEstimation === 'undefined') {\n      throw new Error('Failed to estimate the gas cost from transaction');\n    }\n    return gasEstimation;\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\n// See: sui/crates/sui-types/src/intent.rs\nexport enum AppId {\n  Sui = 0,\n}\n\nexport enum IntentVersion {\n  V0 = 0,\n}\n\nexport enum IntentScope {\n  TransactionData = 0,\n  TransactionEffects = 1,\n  CheckpointSummary = 2,\n  PersonalMessage = 3,\n}\n\nexport type Intent = [IntentScope, IntentVersion, AppId];\n\nfunction intentWithScope(scope: IntentScope): Intent {\n  return [scope, IntentVersion.V0, AppId.Sui];\n}\n\nexport function messageWithIntent(scope: IntentScope, message: Uint8Array) {\n  const intent = intentWithScope(scope);\n  const intentMessage = new Uint8Array(intent.length + message.length);\n  intentMessage.set(intent);\n  intentMessage.set(message, intent.length);\n  return intentMessage;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nconst ELLIPSIS = '\\u{2026}';\n\nexport function formatAddress(address: string) {\n  if (address.length <= 6) {\n    return address;\n  }\n\n  const offset = address.startsWith('0x') ? 2 : 0;\n\n  return `0x${address.slice(offset, offset + 4)}${ELLIPSIS}${address.slice(\n    -4,\n  )}`;\n}\n\nexport function formatDigest(digest: string) {\n  // Use 10 first characters\n  return `${digest.slice(0, 10)}${ELLIPSIS}`;\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fromB64 } from '@mysten/bcs';\nimport nacl from 'tweetnacl';\nimport { IntentScope, messageWithIntent } from './intent';\nimport { secp256k1 } from '@noble/curves/secp256k1';\nimport { sha256 } from '@noble/hashes/sha256';\nimport {\n  fromSerializedSignature,\n  SerializedSignature,\n} from '../cryptography/signature';\nimport { blake2b } from '@noble/hashes/blake2b';\n\n// TODO: This might actually make sense to eventually move to the `Keypair` instances themselves, as\n// it could allow the Sui.js to be tree-shaken a little better, possibly allowing keypairs that are\n// not used (and their deps) to be entirely removed from the bundle.\n\n/** Verify data that is signed with the expected scope. */\nexport async function verifyMessage(\n  message: Uint8Array | string,\n  serializedSignature: SerializedSignature,\n  scope: IntentScope,\n) {\n  const signature = fromSerializedSignature(serializedSignature);\n  const messageBytes = messageWithIntent(\n    scope,\n    typeof message === 'string' ? fromB64(message) : message,\n  );\n  const digest = blake2b(messageBytes, { dkLen: 32 });\n  switch (signature.signatureScheme) {\n    case 'ED25519':\n      return nacl.sign.detached.verify(\n        digest,\n        signature.signature,\n        signature.pubKey.toBytes(),\n      );\n    case 'Secp256k1':\n      return secp256k1.verify(\n        secp256k1.Signature.fromCompact(signature.signature),\n        sha256(digest),\n        signature.pubKey.toBytes(),\n      );\n    default:\n      throw new Error(\n        `Unknown signature scheme: \"${signature.signatureScheme}\"`,\n      );\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { TransactionBlock } from '../builder';\nimport { JsonRpcProvider } from '../providers/json-rpc-provider';\nimport {\n  getObjectReference,\n  normalizeSuiObjectId,\n  ObjectId,\n  SuiAddress,\n  SUI_SYSTEM_ADDRESS,\n} from '../types';\n\n/**\n * Address of the Sui System object.\n * Always the same in every Sui network (local, devnet, testnet).\n */\nexport const SUI_SYSTEM_STATE_OBJECT_ID: string = normalizeSuiObjectId('0x5');\n\nexport const SUI_SYSTEM_MODULE_NAME = 'sui_system';\nexport const ADD_STAKE_FUN_NAME = 'request_add_stake';\nexport const ADD_STAKE_LOCKED_COIN_FUN_NAME =\n  'request_add_stake_with_locked_coin';\nexport const WITHDRAW_STAKE_FUN_NAME = 'request_withdraw_stake';\n\n/**\n * Utility class for `0x5` object\n */\nexport class SuiSystemStateUtil {\n  /**\n   * Create a new transaction for staking coins ready to be signed and executed with `signer-and-provider`.\n   *\n   * @param coins the coins to be staked\n   * @param amount the amount to stake\n   * @param gasBudget omittable only for DevInspect mode\n   */\n  public static async newRequestAddStakeTxn(\n    provider: JsonRpcProvider,\n    coins: ObjectId[],\n    amount: bigint,\n    validatorAddress: SuiAddress,\n  ): Promise<TransactionBlock> {\n    // TODO: validate coin types and handle locked coins\n    const tx = new TransactionBlock();\n\n    const coin = tx.splitCoins(tx.gas, [tx.pure(amount)]);\n    tx.moveCall({\n      target: `${SUI_SYSTEM_ADDRESS}::${SUI_SYSTEM_MODULE_NAME}::${ADD_STAKE_FUN_NAME}`,\n      arguments: [\n        tx.object(SUI_SYSTEM_STATE_OBJECT_ID),\n        coin,\n        tx.pure(validatorAddress),\n      ],\n    });\n    const coinObjects = await provider.multiGetObjects({\n      ids: coins,\n      options: {\n        showOwner: true,\n      },\n    });\n    tx.setGasPayment(coinObjects.map((obj) => getObjectReference(obj)!));\n    return tx;\n  }\n\n  /**\n   * Create a new transaction for withdrawing coins ready to be signed and\n   * executed with `signer-and-provider`.\n   *\n   * @param stake the stake object created in the requestAddStake txn\n   * @param stakedCoinId the coins to withdraw\n   * @param gasBudget omittable only for DevInspect mode\n   */\n  public static async newRequestWithdrawlStakeTxn(\n    stake: ObjectId,\n    stakedCoinId: ObjectId,\n  ): Promise<TransactionBlock> {\n    const tx = new TransactionBlock();\n    tx.moveCall({\n      target: `${SUI_SYSTEM_ADDRESS}::${SUI_SYSTEM_MODULE_NAME}::${WITHDRAW_STAKE_FUN_NAME}`,\n      arguments: [\n        tx.object(SUI_SYSTEM_STATE_OBJECT_ID),\n        tx.object(stake),\n        tx.object(stakedCoinId),\n      ],\n    });\n\n    return tx;\n  }\n}\n","// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\nexport * from './cryptography/ed25519-keypair';\nexport * from './cryptography/secp256k1-keypair';\nexport * from './cryptography/secp256r1-keypair';\nexport * from './cryptography/keypair';\nexport * from './cryptography/ed25519-publickey';\nexport * from './cryptography/secp256k1-publickey';\nexport * from './cryptography/secp256r1-publickey';\nexport * from './cryptography/multisig';\nexport * from './cryptography/publickey';\nexport * from './cryptography/mnemonics';\nexport * from './cryptography/signature';\n\nexport * from './providers/json-rpc-provider';\n\nexport * from './rpc/client';\nexport * from './rpc/faucet-client';\nexport * from './rpc/websocket-client';\nexport * from './rpc/connection';\n\nexport * from './signers/txn-data-serializers/type-tag-serializer';\n\nexport * from './signers/signer';\nexport * from './signers/raw-signer';\nexport * from './signers/signer-with-provider';\nexport * from './signers/types';\n\nexport * from './types';\nexport * from './utils/format';\nexport * from './utils/intent';\nexport * from './utils/verify';\nexport * from './utils/errors';\n\nexport * from './framework';\n\nexport * from './builder';\n\nexport { fromB64, toB64 } from '@mysten/bcs';\n\nexport { is, assert } from 'superstruct';\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}