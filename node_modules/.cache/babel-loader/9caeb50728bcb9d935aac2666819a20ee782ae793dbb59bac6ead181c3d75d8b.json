{"ast":null,"code":"import { toB58 } from \"@mysten/bcs\";\nimport { array, assert, define, integer, is, literal, nullable, object, optional, string, union } from \"superstruct\";\nimport { hashTypedData } from \"../cryptography/hash.js\";\nimport { normalizeSuiAddress, SuiObjectRef } from \"../types/index.js\";\nimport { builder } from \"./bcs.js\";\nimport { TransactionType, TransactionBlockInput } from \"./Transactions.js\";\nimport { BuilderCallArg, PureCallArg } from \"./Inputs.js\";\nimport { create } from \"./utils.js\";\nconst TransactionExpiration = optional(nullable(union([object({\n  Epoch: integer()\n}), object({\n  None: union([literal(true), literal(null)])\n})])));\nconst SuiAddress = string();\nconst StringEncodedBigint = define(\"StringEncodedBigint\", val => {\n  if (![\"string\", \"number\", \"bigint\"].includes(typeof val)) return false;\n  try {\n    BigInt(val);\n    return true;\n  } catch {\n    return false;\n  }\n});\nconst GasConfig = object({\n  budget: optional(StringEncodedBigint),\n  price: optional(StringEncodedBigint),\n  payment: optional(array(SuiObjectRef)),\n  owner: optional(SuiAddress)\n});\nconst SerializedTransactionDataBuilder = object({\n  version: literal(1),\n  sender: optional(SuiAddress),\n  expiration: TransactionExpiration,\n  gasConfig: GasConfig,\n  inputs: array(TransactionBlockInput),\n  transactions: array(TransactionType)\n});\nfunction prepareSuiAddress(address) {\n  return normalizeSuiAddress(address).replace(\"0x\", \"\");\n}\nclass TransactionBlockDataBuilder {\n  constructor(clone) {\n    this.version = 1;\n    this.sender = clone?.sender;\n    this.expiration = clone?.expiration;\n    this.gasConfig = clone?.gasConfig ?? {};\n    this.inputs = clone?.inputs ?? [];\n    this.transactions = clone?.transactions ?? [];\n  }\n  static fromKindBytes(bytes) {\n    const kind = builder.de(\"TransactionKind\", bytes);\n    const programmableTx = kind?.ProgrammableTransaction;\n    if (!programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    const serialized = create({\n      version: 1,\n      gasConfig: {},\n      inputs: programmableTx.inputs.map((value, index) => create({\n        kind: \"Input\",\n        value,\n        index,\n        type: is(value, PureCallArg) ? \"pure\" : \"object\"\n      }, TransactionBlockInput)),\n      transactions: programmableTx.transactions\n    }, SerializedTransactionDataBuilder);\n    return TransactionBlockDataBuilder.restore(serialized);\n  }\n  static fromBytes(bytes) {\n    const rawData = builder.de(\"TransactionData\", bytes);\n    const data = rawData?.V1;\n    const programmableTx = data?.kind?.ProgrammableTransaction;\n    if (!data || !programmableTx) {\n      throw new Error(\"Unable to deserialize from bytes.\");\n    }\n    const serialized = create({\n      version: 1,\n      sender: data.sender,\n      expiration: data.expiration,\n      gasConfig: data.gasData,\n      inputs: programmableTx.inputs.map((value, index) => create({\n        kind: \"Input\",\n        value,\n        index,\n        type: is(value, PureCallArg) ? \"pure\" : \"object\"\n      }, TransactionBlockInput)),\n      transactions: programmableTx.transactions\n    }, SerializedTransactionDataBuilder);\n    return TransactionBlockDataBuilder.restore(serialized);\n  }\n  static restore(data) {\n    assert(data, SerializedTransactionDataBuilder);\n    const transactionData = new TransactionBlockDataBuilder();\n    Object.assign(transactionData, data);\n    return transactionData;\n  }\n  /**\n   * Generate transaction digest.\n   *\n   * @param bytes BCS serialized transaction data\n   * @returns transaction digest.\n   */\n  static getDigestFromBytes(bytes) {\n    const hash = hashTypedData(\"TransactionData\", bytes);\n    return toB58(hash);\n  }\n  build() {\n    let {\n      maxSizeBytes = Infinity,\n      overrides,\n      onlyTransactionKind\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const inputs = this.inputs.map(input => {\n      assert(input.value, BuilderCallArg);\n      return input.value;\n    });\n    const kind = {\n      ProgrammableTransaction: {\n        inputs,\n        transactions: this.transactions\n      }\n    };\n    if (onlyTransactionKind) {\n      return builder.ser(\"TransactionKind\", kind, {\n        maxSize: maxSizeBytes\n      }).toBytes();\n    }\n    const expiration = overrides?.expiration ?? this.expiration;\n    const sender = overrides?.sender ?? this.sender;\n    const gasConfig = {\n      ...this.gasConfig,\n      ...overrides?.gasConfig\n    };\n    if (!sender) {\n      throw new Error(\"Missing transaction sender\");\n    }\n    if (!gasConfig.budget) {\n      throw new Error(\"Missing gas budget\");\n    }\n    if (!gasConfig.payment) {\n      throw new Error(\"Missing gas payment\");\n    }\n    if (!gasConfig.price) {\n      throw new Error(\"Missing gas price\");\n    }\n    const transactionData = {\n      sender: prepareSuiAddress(sender),\n      expiration: expiration ? expiration : {\n        None: true\n      },\n      gasData: {\n        payment: gasConfig.payment,\n        owner: prepareSuiAddress(this.gasConfig.owner ?? sender),\n        price: BigInt(gasConfig.price),\n        budget: BigInt(gasConfig.budget)\n      },\n      kind: {\n        ProgrammableTransaction: {\n          inputs,\n          transactions: this.transactions\n        }\n      }\n    };\n    return builder.ser(\"TransactionData\", {\n      V1: transactionData\n    }, {\n      maxSize: maxSizeBytes\n    }).toBytes();\n  }\n  getDigest() {\n    const bytes = this.build({\n      onlyTransactionKind: false\n    });\n    return TransactionBlockDataBuilder.getDigestFromBytes(bytes);\n  }\n  snapshot() {\n    return create(this, SerializedTransactionDataBuilder);\n  }\n}\nexport { SerializedTransactionDataBuilder, TransactionBlockDataBuilder, TransactionExpiration };","map":{"version":3,"names":["toB58","array","assert","define","integer","is","literal","nullable","object","optional","string","union","hashTypedData","normalizeSuiAddress","SuiObjectRef","builder","TransactionType","TransactionBlockInput","BuilderCallArg","PureCallArg","create","TransactionExpiration","Epoch","None","SuiAddress","StringEncodedBigint","val","includes","BigInt","GasConfig","budget","price","payment","owner","SerializedTransactionDataBuilder","version","sender","expiration","gasConfig","inputs","transactions","prepareSuiAddress","address","replace","TransactionBlockDataBuilder","constructor","clone","fromKindBytes","bytes","kind","de","programmableTx","ProgrammableTransaction","Error","serialized","map","value","index","type","restore","fromBytes","rawData","data","V1","gasData","transactionData","Object","assign","getDigestFromBytes","hash","build","maxSizeBytes","Infinity","overrides","onlyTransactionKind","arguments","length","undefined","input","ser","maxSize","toBytes","getDigest","snapshot"],"sources":["/Users/admin/Downloads/tree-web-three1/tree-web-three-react/node_modules/@mysten/sui.js/src/builder/TransactionBlockData.ts"],"sourcesContent":["// Copyright (c) Mysten Labs, Inc.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { toB58 } from '@mysten/bcs';\nimport type { Infer } from 'superstruct';\nimport {\n\tarray,\n\tassert,\n\tdefine,\n\tinteger,\n\tis,\n\tliteral,\n\tnullable,\n\tobject,\n\toptional,\n\tstring,\n\tunion,\n} from 'superstruct';\nimport { hashTypedData } from '../cryptography/hash.js';\nimport { normalizeSuiAddress, SuiObjectRef } from '../types/index.js';\nimport { builder } from './bcs.js';\nimport { TransactionType, TransactionBlockInput } from './Transactions.js';\nimport { BuilderCallArg, PureCallArg } from './Inputs.js';\nimport { create } from './utils.js';\n\nexport const TransactionExpiration = optional(\n\tnullable(\n\t\tunion([object({ Epoch: integer() }), object({ None: union([literal(true), literal(null)]) })]),\n\t),\n);\nexport type TransactionExpiration = Infer<typeof TransactionExpiration>;\n\nconst SuiAddress = string();\n\nconst StringEncodedBigint = define<string>('StringEncodedBigint', (val) => {\n\tif (!['string', 'number', 'bigint'].includes(typeof val)) return false;\n\n\ttry {\n\t\tBigInt(val as string);\n\t\treturn true;\n\t} catch {\n\t\treturn false;\n\t}\n});\n\nconst GasConfig = object({\n\tbudget: optional(StringEncodedBigint),\n\tprice: optional(StringEncodedBigint),\n\tpayment: optional(array(SuiObjectRef)),\n\towner: optional(SuiAddress),\n});\ntype GasConfig = Infer<typeof GasConfig>;\n\nexport const SerializedTransactionDataBuilder = object({\n\tversion: literal(1),\n\tsender: optional(SuiAddress),\n\texpiration: TransactionExpiration,\n\tgasConfig: GasConfig,\n\tinputs: array(TransactionBlockInput),\n\ttransactions: array(TransactionType),\n});\nexport type SerializedTransactionDataBuilder = Infer<typeof SerializedTransactionDataBuilder>;\n\nfunction prepareSuiAddress(address: string) {\n\treturn normalizeSuiAddress(address).replace('0x', '');\n}\n\nexport class TransactionBlockDataBuilder {\n\tstatic fromKindBytes(bytes: Uint8Array) {\n\t\tconst kind = builder.de('TransactionKind', bytes);\n\t\tconst programmableTx = kind?.ProgrammableTransaction;\n\t\tif (!programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\tconst serialized = create(\n\t\t\t{\n\t\t\t\tversion: 1,\n\t\t\t\tgasConfig: {},\n\t\t\t\tinputs: programmableTx.inputs.map((value: unknown, index: number) =>\n\t\t\t\t\tcreate(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'Input',\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\ttype: is(value, PureCallArg) ? 'pure' : 'object',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTransactionBlockInput,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\ttransactions: programmableTx.transactions,\n\t\t\t},\n\t\t\tSerializedTransactionDataBuilder,\n\t\t);\n\n\t\treturn TransactionBlockDataBuilder.restore(serialized);\n\t}\n\n\tstatic fromBytes(bytes: Uint8Array) {\n\t\tconst rawData = builder.de('TransactionData', bytes);\n\t\tconst data = rawData?.V1;\n\t\tconst programmableTx = data?.kind?.ProgrammableTransaction;\n\t\tif (!data || !programmableTx) {\n\t\t\tthrow new Error('Unable to deserialize from bytes.');\n\t\t}\n\n\t\tconst serialized = create(\n\t\t\t{\n\t\t\t\tversion: 1,\n\t\t\t\tsender: data.sender,\n\t\t\t\texpiration: data.expiration,\n\t\t\t\tgasConfig: data.gasData,\n\t\t\t\tinputs: programmableTx.inputs.map((value: unknown, index: number) =>\n\t\t\t\t\tcreate(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tkind: 'Input',\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tindex,\n\t\t\t\t\t\t\ttype: is(value, PureCallArg) ? 'pure' : 'object',\n\t\t\t\t\t\t},\n\t\t\t\t\t\tTransactionBlockInput,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t\ttransactions: programmableTx.transactions,\n\t\t\t},\n\t\t\tSerializedTransactionDataBuilder,\n\t\t);\n\n\t\treturn TransactionBlockDataBuilder.restore(serialized);\n\t}\n\n\tstatic restore(data: SerializedTransactionDataBuilder) {\n\t\tassert(data, SerializedTransactionDataBuilder);\n\t\tconst transactionData = new TransactionBlockDataBuilder();\n\t\tObject.assign(transactionData, data);\n\t\treturn transactionData;\n\t}\n\n\t/**\n\t * Generate transaction digest.\n\t *\n\t * @param bytes BCS serialized transaction data\n\t * @returns transaction digest.\n\t */\n\tstatic getDigestFromBytes(bytes: Uint8Array) {\n\t\tconst hash = hashTypedData('TransactionData', bytes);\n\t\treturn toB58(hash);\n\t}\n\n\tversion = 1 as const;\n\tsender?: string;\n\texpiration?: TransactionExpiration;\n\tgasConfig: GasConfig;\n\tinputs: TransactionBlockInput[];\n\ttransactions: TransactionType[];\n\n\tconstructor(clone?: SerializedTransactionDataBuilder) {\n\t\tthis.sender = clone?.sender;\n\t\tthis.expiration = clone?.expiration;\n\t\tthis.gasConfig = clone?.gasConfig ?? {};\n\t\tthis.inputs = clone?.inputs ?? [];\n\t\tthis.transactions = clone?.transactions ?? [];\n\t}\n\n\tbuild({\n\t\tmaxSizeBytes = Infinity,\n\t\toverrides,\n\t\tonlyTransactionKind,\n\t}: {\n\t\tmaxSizeBytes?: number;\n\t\toverrides?: Pick<Partial<TransactionBlockDataBuilder>, 'sender' | 'gasConfig' | 'expiration'>;\n\t\tonlyTransactionKind?: boolean;\n\t} = {}) {\n\t\t// Resolve inputs down to values:\n\t\tconst inputs = this.inputs.map((input) => {\n\t\t\tassert(input.value, BuilderCallArg);\n\t\t\treturn input.value;\n\t\t});\n\n\t\tconst kind = {\n\t\t\tProgrammableTransaction: {\n\t\t\t\tinputs,\n\t\t\t\ttransactions: this.transactions,\n\t\t\t},\n\t\t};\n\n\t\tif (onlyTransactionKind) {\n\t\t\treturn builder.ser('TransactionKind', kind, { maxSize: maxSizeBytes }).toBytes();\n\t\t}\n\n\t\tconst expiration = overrides?.expiration ?? this.expiration;\n\t\tconst sender = overrides?.sender ?? this.sender;\n\t\tconst gasConfig = { ...this.gasConfig, ...overrides?.gasConfig };\n\n\t\tif (!sender) {\n\t\t\tthrow new Error('Missing transaction sender');\n\t\t}\n\n\t\tif (!gasConfig.budget) {\n\t\t\tthrow new Error('Missing gas budget');\n\t\t}\n\n\t\tif (!gasConfig.payment) {\n\t\t\tthrow new Error('Missing gas payment');\n\t\t}\n\n\t\tif (!gasConfig.price) {\n\t\t\tthrow new Error('Missing gas price');\n\t\t}\n\n\t\tconst transactionData = {\n\t\t\tsender: prepareSuiAddress(sender),\n\t\t\texpiration: expiration ? expiration : { None: true },\n\t\t\tgasData: {\n\t\t\t\tpayment: gasConfig.payment,\n\t\t\t\towner: prepareSuiAddress(this.gasConfig.owner ?? sender),\n\t\t\t\tprice: BigInt(gasConfig.price),\n\t\t\t\tbudget: BigInt(gasConfig.budget),\n\t\t\t},\n\t\t\tkind: {\n\t\t\t\tProgrammableTransaction: {\n\t\t\t\t\tinputs,\n\t\t\t\t\ttransactions: this.transactions,\n\t\t\t\t},\n\t\t\t},\n\t\t};\n\n\t\treturn builder\n\t\t\t.ser('TransactionData', { V1: transactionData }, { maxSize: maxSizeBytes })\n\t\t\t.toBytes();\n\t}\n\n\tgetDigest() {\n\t\tconst bytes = this.build({ onlyTransactionKind: false });\n\t\treturn TransactionBlockDataBuilder.getDigestFromBytes(bytes);\n\t}\n\n\tsnapshot(): SerializedTransactionDataBuilder {\n\t\treturn create(this, SerializedTransactionDataBuilder);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}